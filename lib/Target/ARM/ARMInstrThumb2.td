//===-- ARMInstrThumb2.td - Thumb2 support for ARM ---------*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file describes the Thumb2 instruction set.
//
//===----------------------------------------------------------------------===//

// IT block predicate field
def it_pred_asmoperand : AsmOperandClass {
  let Name = "ITCondCode";
  let ParserMethod = "parseITCondCode";
}
def it_pred : Operand<i32> {
  let PrintMethod = "printMandatoryPredicateOperand";
  let ParserMatchClass = it_pred_asmoperand;
}

// IT block condition mask
def it_mask_asmoperand : AsmOperandClass { let Name = "ITMask"; }
def it_mask : Operand<i32> {
  let PrintMethod = "printThumbITMask";
  let ParserMatchClass = it_mask_asmoperand;
}

// t2_shift_imm: An integer that encodes a shift amount and the type of shift
// (asr or lsl). The 6-bit immediate encodes as:
//    {5}     0 ==> lsl
//            1     asr
//    {4-0}   imm5 shift amount.
//            asr #32 not allowed
def t2_shift_imm : Operand<i32> {
  let PrintMethod = "printShiftImmOperand";
  let ParserMatchClass = ShifterImmAsmOperand;
  let DecoderMethod = "DecodeT2ShifterImmOperand";
}

// Shifted operands. No register controlled shifts for Thumb2.
// Note: We do not support rrx shifted operands yet.
def t2_so_reg : Operand<i32>,    // reg imm
                ComplexPattern<i32, 2, "SelectT2ShifterOperandReg",
                               [shl,srl,sra,rotr]> {
  let EncoderMethod = "getT2SORegOpValue";
  let PrintMethod = "printT2SOOperand";
  let DecoderMethod = "DecodeSORegImmOperand";
  let ParserMatchClass = ShiftedImmAsmOperand;
  let MIOperandInfo = (ops rGPR, i32imm);
}

// t2_so_imm_not_XFORM - Return the complement of a t2_so_imm value
def t2_so_imm_not_XFORM : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(~((uint32_t)N->getZExtValue()), MVT::i32);
}]>;

// t2_so_imm_neg_XFORM - Return the negation of a t2_so_imm value
def t2_so_imm_neg_XFORM : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(-((int)N->getZExtValue()), MVT::i32);
}]>;

// so_imm_notSext_XFORM - Return a so_imm value packed into the format
// described for so_imm_notSext def below, with sign extension from 16
// bits.
def t2_so_imm_notSext16_XFORM : SDNodeXForm<imm, [{
  APInt apIntN = N->getAPIntValue();
  unsigned N16bitSignExt = apIntN.trunc(16).sext(32).getZExtValue();
  return CurDAG->getTargetConstant(~N16bitSignExt, MVT::i32);
}]>;

// t2_so_imm - Match a 32-bit immediate operand, which is an
// 8-bit immediate rotated by an arbitrary number of bits, or an 8-bit
// immediate splatted into multiple bytes of the word.
def t2_so_imm_asmoperand : ImmAsmOperand { let Name = "T2SOImm"; }
def t2_so_imm : Operand<i32>, ImmLeaf<i32, [{
    return ARM_AM::getT2SOImmVal(Imm) != -1;
  }]> {
  let ParserMatchClass = t2_so_imm_asmoperand;
  let EncoderMethod = "getT2SOImmOpValue";
  let DecoderMethod = "DecodeT2SOImm";
}

// t2_so_imm_not - Match an immediate that is a complement
// of a t2_so_imm.
// Note: this pattern doesn't require an encoder method and such, as it's
// only used on aliases (Pat<> and InstAlias<>). The actual encoding
// is handled by the destination instructions, which use t2_so_imm.
def t2_so_imm_not_asmoperand : AsmOperandClass { let Name = "T2SOImmNot"; }
def t2_so_imm_not : Operand<i32>, PatLeaf<(imm), [{
  return ARM_AM::getT2SOImmVal(~((uint32_t)N->getZExtValue())) != -1;
}], t2_so_imm_not_XFORM> {
  let ParserMatchClass = t2_so_imm_not_asmoperand;
}

// t2_so_imm_notSext - match an immediate that is a complement of a t2_so_imm
// if the upper 16 bits are zero.
def t2_so_imm_notSext : Operand<i32>, PatLeaf<(imm), [{
    APInt apIntN = N->getAPIntValue();
    if (!apIntN.isIntN(16)) return false;
    unsigned N16bitSignExt = apIntN.trunc(16).sext(32).getZExtValue();
    return ARM_AM::getT2SOImmVal(~N16bitSignExt) != -1;
  }], t2_so_imm_notSext16_XFORM> {
  let ParserMatchClass = t2_so_imm_not_asmoperand;
}

// t2_so_imm_neg - Match an immediate that is a negation of a t2_so_imm.
def t2_so_imm_neg_asmoperand : AsmOperandClass { let Name = "T2SOImmNeg"; }
def t2_so_imm_neg : Operand<i32>, PatLeaf<(imm), [{
  int64_t Value = -(int)N->getZExtValue();
  return Value && ARM_AM::getT2SOImmVal(Value) != -1;
}], t2_so_imm_neg_XFORM> {
  let ParserMatchClass = t2_so_imm_neg_asmoperand;
}

/// imm0_4095 predicate - True if the 32-bit immediate is in the range [0.4095].
def imm0_4095_asmoperand: ImmAsmOperand { let Name = "Imm0_4095"; }
def imm0_4095 : Operand<i32>, ImmLeaf<i32, [{
  return Imm >= 0 && Imm < 4096;
}]> {
  let ParserMatchClass = imm0_4095_asmoperand;
}

def imm0_4095_neg_asmoperand: AsmOperandClass { let Name = "Imm0_4095Neg"; }
def imm0_4095_neg : Operand<i32>, PatLeaf<(i32 imm), [{
 return (uint32_t)(-N->getZExtValue()) < 4096;
}], imm_neg_XFORM> {
  let ParserMatchClass = imm0_4095_neg_asmoperand;
}

def imm1_255_neg : PatLeaf<(i32 imm), [{
  uint32_t Val = -N->getZExtValue();
  return (Val > 0 && Val < 255);
}], imm_neg_XFORM>;

def imm0_255_not : PatLeaf<(i32 imm), [{
  return (uint32_t)(~N->getZExtValue()) < 255;
}], imm_comp_XFORM>;

def lo5AllOne : PatLeaf<(i32 imm), [{
  // Returns true if all low 5-bits are 1.
  return (((uint32_t)N->getZExtValue()) & 0x1FUL) == 0x1FUL;
}]>;

// Define Thumb2 specific addressing modes.

// t2addrmode_imm12  := reg + imm12
def t2addrmode_imm12_asmoperand : AsmOperandClass {let Name="MemUImm12Offset";}
def t2addrmode_imm12 : Operand<i32>,
                       ComplexPattern<i32, 2, "SelectT2AddrModeImm12", []> {
  let PrintMethod = "printAddrModeImm12Operand<false>";
  let EncoderMethod = "getAddrModeImm12OpValue";
  let DecoderMethod = "DecodeT2AddrModeImm12";
  let ParserMatchClass = t2addrmode_imm12_asmoperand;
  let MIOperandInfo = (ops GPR:$base, i32imm:$offsimm);
}

// t2ldrlabel  := imm12
def t2ldrlabel : Operand<i32> {
  let EncoderMethod = "getAddrModeImm12OpValue";
  let PrintMethod = "printThumbLdrLabelOperand";
}

def t2ldr_pcrel_imm12_asmoperand : AsmOperandClass {let Name = "MemPCRelImm12";}
def t2ldr_pcrel_imm12 : Operand<i32> {
  let ParserMatchClass = t2ldr_pcrel_imm12_asmoperand;
  // used for assembler pseudo instruction and maps to t2ldrlabel, so
  // doesn't need encoder or print methods of its own.
}

// ADR instruction labels.
def t2adrlabel : Operand<i32> {
  let EncoderMethod = "getT2AdrLabelOpValue";
  let PrintMethod = "printAdrLabelOperand<0>";
}

// t2addrmode_posimm8  := reg + imm8
def MemPosImm8OffsetAsmOperand : AsmOperandClass {let Name="MemPosImm8Offset";}
def t2addrmode_posimm8 : Operand<i32> {
  let PrintMethod = "printT2AddrModeImm8Operand<false>";
  let EncoderMethod = "getT2AddrModeImm8OpValue";
  let DecoderMethod = "DecodeT2AddrModeImm8";
  let ParserMatchClass = MemPosImm8OffsetAsmOperand;
  let MIOperandInfo = (ops GPR:$base, i32imm:$offsimm);
}

// t2addrmode_negimm8  := reg - imm8
def MemNegImm8OffsetAsmOperand : AsmOperandClass {let Name="MemNegImm8Offset";}
def t2addrmode_negimm8 : Operand<i32>,
                      ComplexPattern<i32, 2, "SelectT2AddrModeImm8", []> {
  let PrintMethod = "printT2AddrModeImm8Operand<false>";
  let EncoderMethod = "getT2AddrModeImm8OpValue";
  let DecoderMethod = "DecodeT2AddrModeImm8";
  let ParserMatchClass = MemNegImm8OffsetAsmOperand;
  let MIOperandInfo = (ops GPR:$base, i32imm:$offsimm);
}

// t2addrmode_imm8  := reg +/- imm8
def MemImm8OffsetAsmOperand : AsmOperandClass { let Name = "MemImm8Offset"; }
class T2AddrMode_Imm8 : Operand<i32>,
                        ComplexPattern<i32, 2, "SelectT2AddrModeImm8", []> {
  let EncoderMethod = "getT2AddrModeImm8OpValue";
  let DecoderMethod = "DecodeT2AddrModeImm8";
  let ParserMatchClass = MemImm8OffsetAsmOperand;
  let MIOperandInfo = (ops GPR:$base, i32imm:$offsimm);
}

def t2addrmode_imm8 : T2AddrMode_Imm8 {
  let PrintMethod = "printT2AddrModeImm8Operand<false>";
}

def t2addrmode_imm8_pre : T2AddrMode_Imm8 {
  let PrintMethod = "printT2AddrModeImm8Operand<true>";
}

def t2am_imm8_offset : Operand<i32>,
                       ComplexPattern<i32, 1, "SelectT2AddrModeImm8Offset",
                                      [], [SDNPWantRoot]> {
  let PrintMethod = "printT2AddrModeImm8OffsetOperand";
  let EncoderMethod = "getT2AddrModeImm8OffsetOpValue";
  let DecoderMethod = "DecodeT2Imm8";
}

// t2addrmode_imm8s4  := reg +/- (imm8 << 2)
def MemImm8s4OffsetAsmOperand : AsmOperandClass {let Name = "MemImm8s4Offset";}
class T2AddrMode_Imm8s4 : Operand<i32> {
  let EncoderMethod = "getT2AddrModeImm8s4OpValue";
  let DecoderMethod = "DecodeT2AddrModeImm8s4";
  let ParserMatchClass = MemImm8s4OffsetAsmOperand;
  let MIOperandInfo = (ops GPR:$base, i32imm:$offsimm);
}

def t2addrmode_imm8s4 : T2AddrMode_Imm8s4 {
  let PrintMethod = "printT2AddrModeImm8s4Operand<false>";
}

def t2addrmode_imm8s4_pre : T2AddrMode_Imm8s4 {
  let PrintMethod = "printT2AddrModeImm8s4Operand<true>";
}

def t2am_imm8s4_offset_asmoperand : AsmOperandClass { let Name = "Imm8s4"; }
def t2am_imm8s4_offset : Operand<i32> {
  let PrintMethod = "printT2AddrModeImm8s4OffsetOperand";
  let EncoderMethod = "getT2Imm8s4OpValue";
  let DecoderMethod = "DecodeT2Imm8S4";
}

// t2addrmode_imm0_1020s4  := reg + (imm8 << 2)
def MemImm0_1020s4OffsetAsmOperand : AsmOperandClass {
  let Name = "MemImm0_1020s4Offset";
}
def t2addrmode_imm0_1020s4 : Operand<i32>,
                         ComplexPattern<i32, 2, "SelectT2AddrModeExclusive"> {
  let PrintMethod = "printT2AddrModeImm0_1020s4Operand";
  let EncoderMethod = "getT2AddrModeImm0_1020s4OpValue";
  let DecoderMethod = "DecodeT2AddrModeImm0_1020s4";
  let ParserMatchClass = MemImm0_1020s4OffsetAsmOperand;
  let MIOperandInfo = (ops GPRnopc:$base, i32imm:$offsimm);
}

// t2addrmode_so_reg  := reg + (reg << imm2)
def t2addrmode_so_reg_asmoperand : AsmOperandClass {let Name="T2MemRegOffset";}
def t2addrmode_so_reg : Operand<i32>,
                        ComplexPattern<i32, 3, "SelectT2AddrModeSoReg", []> {
  let PrintMethod = "printT2AddrModeSoRegOperand";
  let EncoderMethod = "getT2AddrModeSORegOpValue";
  let DecoderMethod = "DecodeT2AddrModeSOReg";
  let ParserMatchClass = t2addrmode_so_reg_asmoperand;
  let MIOperandInfo = (ops GPR:$base, rGPR:$offsreg, i32imm:$offsimm);
}

// Addresses for the TBB/TBH instructions.
def addrmode_tbb_asmoperand : AsmOperandClass { let Name = "MemTBB"; }
def addrmode_tbb : Operand<i32> {
  let PrintMethod = "printAddrModeTBB";
  let ParserMatchClass = addrmode_tbb_asmoperand;
  let MIOperandInfo = (ops GPR:$Rn, rGPR:$Rm);
}
def addrmode_tbh_asmoperand : AsmOperandClass { let Name = "MemTBH"; }
def addrmode_tbh : Operand<i32> {
  let PrintMethod = "printAddrModeTBH";
  let ParserMatchClass = addrmode_tbh_asmoperand;
  let MIOperandInfo = (ops GPR:$Rn, rGPR:$Rm);
}

//===----------------------------------------------------------------------===//
// Multiclass helpers...
//


class T2OneRegImm<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<12> imm;

  let Inst{11-8}  = Rd;
  let Inst{26}    = imm{11};
  let Inst{14-12} = imm{10-8};
  let Inst{7-0}   = imm{7-0};
}


class T2sOneRegImm<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2sI<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rn;
  bits<12> imm;

  let Inst{11-8}  = Rd;
  let Inst{26}    = imm{11};
  let Inst{14-12} = imm{10-8};
  let Inst{7-0}   = imm{7-0};
}

class T2OneRegCmpImm<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rn;
  bits<12> imm;

  let Inst{19-16}  = Rn;
  let Inst{26}    = imm{11};
  let Inst{14-12} = imm{10-8};
  let Inst{7-0}   = imm{7-0};
}


class T2OneRegShiftedReg<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<12> ShiftedRm;

  let Inst{11-8}  = Rd;
  let Inst{3-0}   = ShiftedRm{3-0};
  let Inst{5-4}   = ShiftedRm{6-5};
  let Inst{14-12} = ShiftedRm{11-9};
  let Inst{7-6}   = ShiftedRm{8-7};
}

class T2sOneRegShiftedReg<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2sI<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<12> ShiftedRm;

  let Inst{11-8}  = Rd;
  let Inst{3-0}   = ShiftedRm{3-0};
  let Inst{5-4}   = ShiftedRm{6-5};
  let Inst{14-12} = ShiftedRm{11-9};
  let Inst{7-6}   = ShiftedRm{8-7};
}

class T2OneRegCmpShiftedReg<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rn;
  bits<12> ShiftedRm;

  let Inst{19-16} = Rn;
  let Inst{3-0}   = ShiftedRm{3-0};
  let Inst{5-4}   = ShiftedRm{6-5};
  let Inst{14-12} = ShiftedRm{11-9};
  let Inst{7-6}   = ShiftedRm{8-7};
}

class T2TwoReg<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rm;

  let Inst{11-8}  = Rd;
  let Inst{3-0}   = Rm;
}

class T2sTwoReg<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2sI<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rm;

  let Inst{11-8}  = Rd;
  let Inst{3-0}   = Rm;
}

class T2TwoRegCmp<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rn;
  bits<4> Rm;

  let Inst{19-16} = Rn;
  let Inst{3-0}   = Rm;
}


class T2TwoRegImm<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rn;
  bits<12> imm;

  let Inst{11-8}  = Rd;
  let Inst{19-16} = Rn;
  let Inst{26}    = imm{11};
  let Inst{14-12} = imm{10-8};
  let Inst{7-0}   = imm{7-0};
}

class T2sTwoRegImm<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2sI<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rn;
  bits<12> imm;

  let Inst{11-8}  = Rd;
  let Inst{19-16} = Rn;
  let Inst{26}    = imm{11};
  let Inst{14-12} = imm{10-8};
  let Inst{7-0}   = imm{7-0};
}

class T2TwoRegShiftImm<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rm;
  bits<5> imm;

  let Inst{11-8}  = Rd;
  let Inst{3-0}   = Rm;
  let Inst{14-12} = imm{4-2};
  let Inst{7-6}   = imm{1-0};
}

class T2sTwoRegShiftImm<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2sI<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rm;
  bits<5> imm;

  let Inst{11-8}  = Rd;
  let Inst{3-0}   = Rm;
  let Inst{14-12} = imm{4-2};
  let Inst{7-6}   = imm{1-0};
}

class T2ThreeReg<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rn;
  bits<4> Rm;

  let Inst{11-8}  = Rd;
  let Inst{19-16} = Rn;
  let Inst{3-0}   = Rm;
}

class T2sThreeReg<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2sI<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rn;
  bits<4> Rm;

  let Inst{11-8}  = Rd;
  let Inst{19-16} = Rn;
  let Inst{3-0}   = Rm;
}

class T2TwoRegShiftedReg<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rn;
  bits<12> ShiftedRm;

  let Inst{11-8}  = Rd;
  let Inst{19-16} = Rn;
  let Inst{3-0}   = ShiftedRm{3-0};
  let Inst{5-4}   = ShiftedRm{6-5};
  let Inst{14-12} = ShiftedRm{11-9};
  let Inst{7-6}   = ShiftedRm{8-7};
}

class T2sTwoRegShiftedReg<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2sI<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rn;
  bits<12> ShiftedRm;

  let Inst{11-8}  = Rd;
  let Inst{19-16} = Rn;
  let Inst{3-0}   = ShiftedRm{3-0};
  let Inst{5-4}   = ShiftedRm{6-5};
  let Inst{14-12} = ShiftedRm{11-9};
  let Inst{7-6}   = ShiftedRm{8-7};
}

class T2FourReg<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rn;
  bits<4> Rm;
  bits<4> Ra;

  let Inst{19-16} = Rn;
  let Inst{15-12} = Ra;
  let Inst{11-8}  = Rd;
  let Inst{3-0}   = Rm;
}

class T2MulLong<bits<3> opc22_20, bits<4> opc7_4,
                dag oops, dag iops, InstrItinClass itin,
                string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> RdLo;
  bits<4> RdHi;
  bits<4> Rn;
  bits<4> Rm;

  let Inst{31-23} = 0b111110111;
  let Inst{22-20} = opc22_20;
  let Inst{19-16} = Rn;
  let Inst{15-12} = RdLo;
  let Inst{11-8}  = RdHi;
  let Inst{7-4}   = opc7_4;
  let Inst{3-0}   = Rm;
}
class T2MlaLong<bits<3> opc22_20, bits<4> opc7_4,
                dag oops, dag iops, InstrItinClass itin,
                string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> RdLo;
  bits<4> RdHi;
  bits<4> Rn;
  bits<4> Rm;

  let Inst{31-23} = 0b111110111;
  let Inst{22-20} = opc22_20;
  let Inst{19-16} = Rn;
  let Inst{15-12} = RdLo;
  let Inst{11-8}  = RdHi;
  let Inst{7-4}   = opc7_4;
  let Inst{3-0}   = Rm;
}


/// T2I_bin_irs - Defines a set of (op reg, {so_imm|r|so_reg}) patterns for a
/// binary operation that produces a value. These are predicable and can be
/// changed to modify CPSR.
multiclass T2I_bin_irs<bits<4> opcod, string opc,
                     InstrItinClass iii, InstrItinClass iir, InstrItinClass iis,
                       PatFrag opnode, bit Commutable = 0,
                       string wide = ""> {
   // shifted imm
   def ri : T2sTwoRegImm<
                (outs rGPR:$Rd), (ins rGPR:$Rn, t2_so_imm:$imm), iii,
                 opc, "\t$Rd, $Rn, $imm",
                 [(set rGPR:$Rd, (opnode rGPR:$Rn, t2_so_imm:$imm))]>,
                 Sched<[WriteALU, ReadALU]> {
     let Inst{31-27} = 0b11110;
     let Inst{25} = 0;
     let Inst{24-21} = opcod;
     let Inst{15} = 0;
   }
   // register
   def rr : T2sThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), iir,
                 opc, !strconcat(wide, "\t$Rd, $Rn, $Rm"),
                 [(set rGPR:$Rd, (opnode rGPR:$Rn, rGPR:$Rm))]>,
                 Sched<[WriteALU, ReadALU, ReadALU]> {
     let isCommutable = Commutable;
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = opcod;
     let Inst{14-12} = 0b000; // imm3
     let Inst{7-6} = 0b00; // imm2
     let Inst{5-4} = 0b00; // type
   }
   // shifted register
   def rs : T2sTwoRegShiftedReg<
                 (outs rGPR:$Rd), (ins rGPR:$Rn, t2_so_reg:$ShiftedRm), iis,
                 opc, !strconcat(wide, "\t$Rd, $Rn, $ShiftedRm"),
                 [(set rGPR:$Rd, (opnode rGPR:$Rn, t2_so_reg:$ShiftedRm))]>,
                 Sched<[WriteALUsi, ReadALU]>  {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = opcod;
   }
  // Assembly aliases for optional destination operand when it's the same
  // as the source operand.
  def : t2InstAlias<!strconcat(opc, "${s}${p} $Rdn, $imm"),
     (!cast<Instruction>(NAME#"ri") rGPR:$Rdn, rGPR:$Rdn,
                                                    t2_so_imm:$imm, pred:$p,
                                                    cc_out:$s)>;
  def : t2InstAlias<!strconcat(opc, "${s}${p}", wide, " $Rdn, $Rm"),
     (!cast<Instruction>(NAME#"rr") rGPR:$Rdn, rGPR:$Rdn,
                                                    rGPR:$Rm, pred:$p,
                                                    cc_out:$s)>;
  def : t2InstAlias<!strconcat(opc, "${s}${p}", wide, " $Rdn, $shift"),
     (!cast<Instruction>(NAME#"rs") rGPR:$Rdn, rGPR:$Rdn,
                                                    t2_so_reg:$shift, pred:$p,
                                                    cc_out:$s)>;
}

/// T2I_bin_w_irs - Same as T2I_bin_irs except these operations need
//  the ".w" suffix to indicate that they are wide.
multiclass T2I_bin_w_irs<bits<4> opcod, string opc,
                     InstrItinClass iii, InstrItinClass iir, InstrItinClass iis,
                         PatFrag opnode, bit Commutable = 0> :
    T2I_bin_irs<opcod, opc, iii, iir, iis, opnode, Commutable, ".w"> {
  // Assembler aliases w/ the ".w" suffix.
  def : t2InstAlias<!strconcat(opc, "${s}${p}.w", " $Rd, $Rn, $imm"),
     (!cast<Instruction>(NAME#"ri") rGPR:$Rd, rGPR:$Rn, t2_so_imm:$imm, pred:$p,
                                    cc_out:$s)>;
  // Assembler aliases w/o the ".w" suffix.
  def : t2InstAlias<!strconcat(opc, "${s}${p}", " $Rd, $Rn, $Rm"),
     (!cast<Instruction>(NAME#"rr") rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, pred:$p,
                                    cc_out:$s)>;
  def : t2InstAlias<!strconcat(opc, "${s}${p}", " $Rd, $Rn, $shift"),
     (!cast<Instruction>(NAME#"rs") rGPR:$Rd, rGPR:$Rn, t2_so_reg:$shift,
                                    pred:$p, cc_out:$s)>;

  // and with the optional destination operand, too.
  def : t2InstAlias<!strconcat(opc, "${s}${p}.w", " $Rdn, $imm"),
     (!cast<Instruction>(NAME#"ri") rGPR:$Rdn, rGPR:$Rdn, t2_so_imm:$imm,
                                    pred:$p, cc_out:$s)>;
  def : t2InstAlias<!strconcat(opc, "${s}${p}", " $Rdn, $Rm"),
     (!cast<Instruction>(NAME#"rr") rGPR:$Rdn, rGPR:$Rdn, rGPR:$Rm, pred:$p,
                                    cc_out:$s)>;
  def : t2InstAlias<!strconcat(opc, "${s}${p}", " $Rdn, $shift"),
     (!cast<Instruction>(NAME#"rs") rGPR:$Rdn, rGPR:$Rdn, t2_so_reg:$shift,
                                    pred:$p, cc_out:$s)>;
}

/// T2I_rbin_is - Same as T2I_bin_irs except the order of operands are
/// reversed.  The 'rr' form is only defined for the disassembler; for codegen
/// it is equivalent to the T2I_bin_irs counterpart.
multiclass T2I_rbin_irs<bits<4> opcod, string opc, PatFrag opnode> {
   // shifted imm
   def ri : T2sTwoRegImm<
                 (outs rGPR:$Rd), (ins rGPR:$Rn, t2_so_imm:$imm), IIC_iALUi,
                 opc, ".w\t$Rd, $Rn, $imm",
                 [(set rGPR:$Rd, (opnode t2_so_imm:$imm, rGPR:$Rn))]>,
                 Sched<[WriteALU, ReadALU]> {
     let Inst{31-27} = 0b11110;
     let Inst{25} = 0;
     let Inst{24-21} = opcod;
     let Inst{15} = 0;
   }
   // register
   def rr : T2sThreeReg<
                 (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iALUr,
                 opc, "\t$Rd, $Rn, $Rm",
                 [/* For disassembly only; pattern left blank */]>,
                 Sched<[WriteALU, ReadALU, ReadALU]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = opcod;
     let Inst{14-12} = 0b000; // imm3
     let Inst{7-6} = 0b00; // imm2
     let Inst{5-4} = 0b00; // type
   }
   // shifted register
   def rs : T2sTwoRegShiftedReg<
                 (outs rGPR:$Rd), (ins rGPR:$Rn, t2_so_reg:$ShiftedRm),
                 IIC_iALUsir, opc, "\t$Rd, $Rn, $ShiftedRm",
                 [(set rGPR:$Rd, (opnode t2_so_reg:$ShiftedRm, rGPR:$Rn))]>,
                 Sched<[WriteALUsi, ReadALU]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = opcod;
   }
}

/// T2I_bin_s_irs - Similar to T2I_bin_irs except it sets the 's' bit so the
/// instruction modifies the CPSR register.
///
/// These opcodes will be converted to the real non-S opcodes by
/// AdjustInstrPostInstrSelection after giving then an optional CPSR operand.
let hasPostISelHook = 1, Defs = [CPSR] in {
multiclass T2I_bin_s_irs<InstrItinClass iii, InstrItinClass iir,
                         InstrItinClass iis, PatFrag opnode,
                         bit Commutable = 0> {
   // shifted imm
   def ri : t2PseudoInst<(outs rGPR:$Rd),
                         (ins GPRnopc:$Rn, t2_so_imm:$imm, pred:$p),
                         4, iii,
                         [(set rGPR:$Rd, CPSR, (opnode GPRnopc:$Rn,
                                                t2_so_imm:$imm))]>,
            Sched<[WriteALU, ReadALU]>;
   // register
   def rr : t2PseudoInst<(outs rGPR:$Rd), (ins GPRnopc:$Rn, rGPR:$Rm, pred:$p),
                         4, iir,
                         [(set rGPR:$Rd, CPSR, (opnode GPRnopc:$Rn,
                                                rGPR:$Rm))]>,
            Sched<[WriteALU, ReadALU, ReadALU]> {
     let isCommutable = Commutable;
   }
   // shifted register
   def rs : t2PseudoInst<(outs rGPR:$Rd),
                         (ins GPRnopc:$Rn, t2_so_reg:$ShiftedRm, pred:$p),
                         4, iis,
                         [(set rGPR:$Rd, CPSR, (opnode GPRnopc:$Rn,
                                                t2_so_reg:$ShiftedRm))]>,
            Sched<[WriteALUsi, ReadALUsr]>;
}
}

/// T2I_rbin_s_is -  Same as T2I_bin_s_irs, except selection DAG
/// operands are reversed.
let hasPostISelHook = 1, Defs = [CPSR] in {
multiclass T2I_rbin_s_is<PatFrag opnode> {
   // shifted imm
   def ri : t2PseudoInst<(outs rGPR:$Rd),
                         (ins rGPR:$Rn, t2_so_imm:$imm, pred:$p),
                         4, IIC_iALUi,
                         [(set rGPR:$Rd, CPSR, (opnode t2_so_imm:$imm,
                                                rGPR:$Rn))]>,
            Sched<[WriteALU, ReadALU]>;
   // shifted register
   def rs : t2PseudoInst<(outs rGPR:$Rd),
                         (ins rGPR:$Rn, t2_so_reg:$ShiftedRm, pred:$p),
                         4, IIC_iALUsi,
                         [(set rGPR:$Rd, CPSR, (opnode t2_so_reg:$ShiftedRm,
                                                rGPR:$Rn))]>,
            Sched<[WriteALUsi, ReadALU]>;
}
}

/// T2I_bin_ii12rs - Defines a set of (op reg, {so_imm|imm0_4095|r|so_reg})
/// patterns for a binary operation that produces a value.
multiclass T2I_bin_ii12rs<bits<3> op23_21, string opc, PatFrag opnode,
                          bit Commutable = 0> {
   // shifted imm
   // The register-immediate version is re-materializable. This is useful
   // in particular for taking the address of a local.
   let isReMaterializable = 1 in {
   def ri : T2sTwoRegImm<
               (outs GPRnopc:$Rd), (ins GPRnopc:$Rn, t2_so_imm:$imm), IIC_iALUi,
               opc, ".w\t$Rd, $Rn, $imm",
               [(set GPRnopc:$Rd, (opnode GPRnopc:$Rn, t2_so_imm:$imm))]>,
               Sched<[WriteALU, ReadALU]> {
     let Inst{31-27} = 0b11110;
     let Inst{25} = 0;
     let Inst{24} = 1;
     let Inst{23-21} = op23_21;
     let Inst{15} = 0;
   }
   }
   // 12-bit imm
   def ri12 : T2I<
                  (outs GPRnopc:$Rd), (ins GPR:$Rn, imm0_4095:$imm), IIC_iALUi,
                  !strconcat(opc, "w"), "\t$Rd, $Rn, $imm",
                  [(set GPRnopc:$Rd, (opnode GPR:$Rn, imm0_4095:$imm))]>,
                  Sched<[WriteALU, ReadALU]> {
     bits<4> Rd;
     bits<4> Rn;
     bits<12> imm;
     let Inst{31-27} = 0b11110;
     let Inst{26} = imm{11};
     let Inst{25-24} = 0b10;
     let Inst{23-21} = op23_21;
     let Inst{20} = 0; // The S bit.
     let Inst{19-16} = Rn;
     let Inst{15} = 0;
     let Inst{14-12} = imm{10-8};
     let Inst{11-8} = Rd;
     let Inst{7-0} = imm{7-0};
   }
   // register
   def rr : T2sThreeReg<(outs GPRnopc:$Rd), (ins GPRnopc:$Rn, rGPR:$Rm),
                 IIC_iALUr, opc, ".w\t$Rd, $Rn, $Rm",
                 [(set GPRnopc:$Rd, (opnode GPRnopc:$Rn, rGPR:$Rm))]>,
                 Sched<[WriteALU, ReadALU, ReadALU]> {
     let isCommutable = Commutable;
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24} = 1;
     let Inst{23-21} = op23_21;
     let Inst{14-12} = 0b000; // imm3
     let Inst{7-6} = 0b00; // imm2
     let Inst{5-4} = 0b00; // type
   }
   // shifted register
   def rs : T2sTwoRegShiftedReg<
                 (outs GPRnopc:$Rd), (ins GPRnopc:$Rn, t2_so_reg:$ShiftedRm),
                 IIC_iALUsi, opc, ".w\t$Rd, $Rn, $ShiftedRm",
              [(set GPRnopc:$Rd, (opnode GPRnopc:$Rn, t2_so_reg:$ShiftedRm))]>,
              Sched<[WriteALUsi, ReadALU]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24} = 1;
     let Inst{23-21} = op23_21;
   }
}

/// T2I_adde_sube_irs - Defines a set of (op reg, {so_imm|r|so_reg}) patterns
/// for a binary operation that produces a value and use the carry
/// bit. It's not predicable.
let Defs = [CPSR], Uses = [CPSR] in {
multiclass T2I_adde_sube_irs<bits<4> opcod, string opc, PatFrag opnode,
                             bit Commutable = 0> {
   // shifted imm
   def ri : T2sTwoRegImm<(outs rGPR:$Rd), (ins rGPR:$Rn, t2_so_imm:$imm),
                 IIC_iALUi, opc, "\t$Rd, $Rn, $imm",
               [(set rGPR:$Rd, CPSR, (opnode rGPR:$Rn, t2_so_imm:$imm, CPSR))]>,
                 Requires<[IsThumb2]>, Sched<[WriteALU, ReadALU]> {
     let Inst{31-27} = 0b11110;
     let Inst{25} = 0;
     let Inst{24-21} = opcod;
     let Inst{15} = 0;
   }
   // register
   def rr : T2sThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iALUr,
                 opc, ".w\t$Rd, $Rn, $Rm",
                 [(set rGPR:$Rd, CPSR, (opnode rGPR:$Rn, rGPR:$Rm, CPSR))]>,
                 Requires<[IsThumb2]>, Sched<[WriteALU, ReadALU, ReadALU]> {
     let isCommutable = Commutable;
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = opcod;
     let Inst{14-12} = 0b000; // imm3
     let Inst{7-6} = 0b00; // imm2
     let Inst{5-4} = 0b00; // type
   }
   // shifted register
   def rs : T2sTwoRegShiftedReg<
                 (outs rGPR:$Rd), (ins rGPR:$Rn, t2_so_reg:$ShiftedRm),
                 IIC_iALUsi, opc, ".w\t$Rd, $Rn, $ShiftedRm",
         [(set rGPR:$Rd, CPSR, (opnode rGPR:$Rn, t2_so_reg:$ShiftedRm, CPSR))]>,
                 Requires<[IsThumb2]>, Sched<[WriteALUsi, ReadALU]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = opcod;
   }
}
}

/// T2I_sh_ir - Defines a set of (op reg, {so_imm|r}) patterns for a shift /
//  rotate operation that produces a value.
multiclass T2I_sh_ir<bits<2> opcod, string opc, Operand ty, PatFrag opnode> {
   // 5-bit imm
   def ri : T2sTwoRegShiftImm<
                 (outs rGPR:$Rd), (ins rGPR:$Rm, ty:$imm), IIC_iMOVsi,
                 opc, ".w\t$Rd, $Rm, $imm",
                 [(set rGPR:$Rd, (opnode rGPR:$Rm, (i32 ty:$imm)))]>,
                 Sched<[WriteALU]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-21} = 0b010010;
     let Inst{19-16} = 0b1111; // Rn
     let Inst{5-4} = opcod;
   }
   // register
   def rr : T2sThreeReg<
                 (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iMOVsr,
                 opc, ".w\t$Rd, $Rn, $Rm",
                 [(set rGPR:$Rd, (opnode rGPR:$Rn, rGPR:$Rm))]>,
                 Sched<[WriteALU]> {
     let Inst{31-27} = 0b11111;
     let Inst{26-23} = 0b0100;
     let Inst{22-21} = opcod;
     let Inst{15-12} = 0b1111;
     let Inst{7-4} = 0b0000;
   }

  // Optional destination register
  def : t2InstAlias<!strconcat(opc, "${s}${p}", ".w $Rdn, $imm"),
     (!cast<Instruction>(NAME#"ri") rGPR:$Rdn, rGPR:$Rdn, ty:$imm, pred:$p,
                                    cc_out:$s)>;
  def : t2InstAlias<!strconcat(opc, "${s}${p}", ".w $Rdn, $Rm"),
     (!cast<Instruction>(NAME#"rr") rGPR:$Rdn, rGPR:$Rdn, rGPR:$Rm, pred:$p,
                                    cc_out:$s)>;

  // Assembler aliases w/o the ".w" suffix.
  def : t2InstAlias<!strconcat(opc, "${s}${p}", " $Rd, $Rn, $imm"),
     (!cast<Instruction>(NAME#"ri") rGPR:$Rd, rGPR:$Rn, ty:$imm, pred:$p,
                                    cc_out:$s)>;
  def : t2InstAlias<!strconcat(opc, "${s}${p}", " $Rd, $Rn, $Rm"),
     (!cast<Instruction>(NAME#"rr") rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, pred:$p,
                                    cc_out:$s)>;

  // and with the optional destination operand, too.
  def : t2InstAlias<!strconcat(opc, "${s}${p}", " $Rdn, $imm"),
     (!cast<Instruction>(NAME#"ri") rGPR:$Rdn, rGPR:$Rdn, ty:$imm, pred:$p,
                                    cc_out:$s)>;
  def : t2InstAlias<!strconcat(opc, "${s}${p}", " $Rdn, $Rm"),
     (!cast<Instruction>(NAME#"rr") rGPR:$Rdn, rGPR:$Rdn, rGPR:$Rm, pred:$p,
                                    cc_out:$s)>;
}

/// T2I_cmp_irs - Defines a set of (op r, {so_imm|r|so_reg}) cmp / test
/// patterns. Similar to T2I_bin_irs except the instruction does not produce
/// a explicit result, only implicitly set CPSR.
multiclass T2I_cmp_irs<bits<4> opcod, string opc,
                     InstrItinClass iii, InstrItinClass iir, InstrItinClass iis,
                       PatFrag opnode> {
let isCompare = 1, Defs = [CPSR] in {
   // shifted imm
   def ri : T2OneRegCmpImm<
                (outs), (ins GPRnopc:$Rn, t2_so_imm:$imm), iii,
                opc, ".w\t$Rn, $imm",
                [(opnode GPRnopc:$Rn, t2_so_imm:$imm)]>, Sched<[WriteCMP]> {
     let Inst{31-27} = 0b11110;
     let Inst{25} = 0;
     let Inst{24-21} = opcod;
     let Inst{20} = 1; // The S bit.
     let Inst{15} = 0;
     let Inst{11-8} = 0b1111; // Rd
   }
   // register
   def rr : T2TwoRegCmp<
                (outs), (ins GPRnopc:$Rn, rGPR:$Rm), iir,
                opc, ".w\t$Rn, $Rm",
                [(opnode GPRnopc:$Rn, rGPR:$Rm)]>, Sched<[WriteCMP]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = opcod;
     let Inst{20} = 1; // The S bit.
     let Inst{14-12} = 0b000; // imm3
     let Inst{11-8} = 0b1111; // Rd
     let Inst{7-6} = 0b00; // imm2
     let Inst{5-4} = 0b00; // type
   }
   // shifted register
   def rs : T2OneRegCmpShiftedReg<
                (outs), (ins GPRnopc:$Rn, t2_so_reg:$ShiftedRm), iis,
                opc, ".w\t$Rn, $ShiftedRm",
                [(opnode GPRnopc:$Rn, t2_so_reg:$ShiftedRm)]>,
                Sched<[WriteCMPsi]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = opcod;
     let Inst{20} = 1; // The S bit.
     let Inst{11-8} = 0b1111; // Rd
   }
}

  // Assembler aliases w/o the ".w" suffix.
  // No alias here for 'rr' version as not all instantiations of this
  // multiclass want one (CMP in particular, does not).
  def : t2InstAlias<!strconcat(opc, "${p}", " $Rn, $imm"),
     (!cast<Instruction>(NAME#"ri") GPRnopc:$Rn, t2_so_imm:$imm, pred:$p)>;
  def : t2InstAlias<!strconcat(opc, "${p}", " $Rn, $shift"),
     (!cast<Instruction>(NAME#"rs") GPRnopc:$Rn, t2_so_reg:$shift, pred:$p)>;
}

/// T2I_ld - Defines a set of (op r, {imm12|imm8|so_reg}) load patterns.
multiclass T2I_ld<bit signed, bits<2> opcod, string opc,
                  InstrItinClass iii, InstrItinClass iis, RegisterClass target,
                  PatFrag opnode> {
  def i12 : T2Ii12<(outs target:$Rt), (ins t2addrmode_imm12:$addr), iii,
                   opc, ".w\t$Rt, $addr",
                   [(set target:$Rt, (opnode t2addrmode_imm12:$addr))]> {
    bits<4> Rt;
    bits<17> addr;
    let Inst{31-25} = 0b1111100;
    let Inst{24} = signed;
    let Inst{23} = 1;
    let Inst{22-21} = opcod;
    let Inst{20} = 1; // load
    let Inst{19-16} = addr{16-13}; // Rn
    let Inst{15-12} = Rt;
    let Inst{11-0}  = addr{11-0};  // imm

    let DecoderMethod = "DecodeT2LoadImm12";
  }
  def i8  : T2Ii8 <(outs target:$Rt), (ins t2addrmode_negimm8:$addr), iii,
                   opc, "\t$Rt, $addr",
                   [(set target:$Rt, (opnode t2addrmode_negimm8:$addr))]> {
    bits<4> Rt;
    bits<13> addr;
    let Inst{31-27} = 0b11111;
    let Inst{26-25} = 0b00;
    let Inst{24} = signed;
    let Inst{23} = 0;
    let Inst{22-21} = opcod;
    let Inst{20} = 1; // load
    let Inst{19-16} = addr{12-9}; // Rn
    let Inst{15-12} = Rt;
    let Inst{11} = 1;
    // Offset: index==TRUE, wback==FALSE
    let Inst{10} = 1; // The P bit.
    let Inst{9}     = addr{8};    // U
    let Inst{8} = 0; // The W bit.
    let Inst{7-0}   = addr{7-0};  // imm

    let DecoderMethod = "DecodeT2LoadImm8";
  }
  def s   : T2Iso <(outs target:$Rt), (ins t2addrmode_so_reg:$addr), iis,
                   opc, ".w\t$Rt, $addr",
                   [(set target:$Rt, (opnode t2addrmode_so_reg:$addr))]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-25} = 0b00;
    let Inst{24} = signed;
    let Inst{23} = 0;
    let Inst{22-21} = opcod;
    let Inst{20} = 1; // load
    let Inst{11-6} = 0b000000;

    bits<4> Rt;
    let Inst{15-12} = Rt;

    bits<10> addr;
    let Inst{19-16} = addr{9-6}; // Rn
    let Inst{3-0}   = addr{5-2}; // Rm
    let Inst{5-4}   = addr{1-0}; // imm

    let DecoderMethod = "DecodeT2LoadShift";
  }

  // pci variant is very similar to i12, but supports negative offsets
  // from the PC.
  def pci : T2Ipc <(outs target:$Rt), (ins t2ldrlabel:$addr), iii,
                   opc, ".w\t$Rt, $addr",
                   [(set target:$Rt, (opnode (ARMWrapper tconstpool:$addr)))]> {
    let isReMaterializable = 1;
    let Inst{31-27} = 0b11111;
    let Inst{26-25} = 0b00;
    let Inst{24} = signed;
    let Inst{22-21} = opcod;
    let Inst{20} = 1; // load
    let Inst{19-16} = 0b1111; // Rn

    bits<4> Rt;
    let Inst{15-12} = Rt{3-0};

    bits<13> addr;
    let Inst{23} = addr{12}; // add = (U == '1')
    let Inst{11-0}  = addr{11-0};

    let DecoderMethod = "DecodeT2LoadLabel";
  }
}

/// T2I_st - Defines a set of (op r, {imm12|imm8|so_reg}) store patterns.
multiclass T2I_st<bits<2> opcod, string opc,
                  InstrItinClass iii, InstrItinClass iis, RegisterClass target,
                  PatFrag opnode> {
  def i12 : T2Ii12<(outs), (ins target:$Rt, t2addrmode_imm12:$addr), iii,
                   opc, ".w\t$Rt, $addr",
                   [(opnode target:$Rt, t2addrmode_imm12:$addr)]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0001;
    let Inst{22-21} = opcod;
    let Inst{20} = 0; // !load

    bits<4> Rt;
    let Inst{15-12} = Rt;

    bits<17> addr;
    let addr{12}    = 1;           // add = TRUE
    let Inst{19-16} = addr{16-13}; // Rn
    let Inst{23}    = addr{12};    // U
    let Inst{11-0}  = addr{11-0};  // imm
  }
  def i8  : T2Ii8 <(outs), (ins target:$Rt, t2addrmode_negimm8:$addr), iii,
                   opc, "\t$Rt, $addr",
                   [(opnode target:$Rt, t2addrmode_negimm8:$addr)]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0000;
    let Inst{22-21} = opcod;
    let Inst{20} = 0; // !load
    let Inst{11} = 1;
    // Offset: index==TRUE, wback==FALSE
    let Inst{10} = 1; // The P bit.
    let Inst{8} = 0; // The W bit.

    bits<4> Rt;
    let Inst{15-12} = Rt;

    bits<13> addr;
    let Inst{19-16} = addr{12-9}; // Rn
    let Inst{9}     = addr{8};    // U
    let Inst{7-0}   = addr{7-0};  // imm
  }
  def s   : T2Iso <(outs), (ins target:$Rt, t2addrmode_so_reg:$addr), iis,
                   opc, ".w\t$Rt, $addr",
                   [(opnode target:$Rt, t2addrmode_so_reg:$addr)]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0000;
    let Inst{22-21} = opcod;
    let Inst{20} = 0; // !load
    let Inst{11-6} = 0b000000;

    bits<4> Rt;
    let Inst{15-12} = Rt;

    bits<10> addr;
    let Inst{19-16}   = addr{9-6}; // Rn
    let Inst{3-0} = addr{5-2}; // Rm
    let Inst{5-4}   = addr{1-0}; // imm
  }
}

/// T2I_ext_rrot - A unary operation with two forms: one whose operand is a
/// register and one whose operand is a register rotated by 8/16/24.
class T2I_ext_rrot<bits<3> opcod, string opc, PatFrag opnode>
  : T2TwoReg<(outs rGPR:$Rd), (ins rGPR:$Rm, rot_imm:$rot), IIC_iEXTr,
             opc, ".w\t$Rd, $Rm$rot",
             [(set rGPR:$Rd, (opnode (rotr rGPR:$Rm, rot_imm:$rot)))]>,
             Requires<[IsThumb2]> {
   let Inst{31-27} = 0b11111;
   let Inst{26-23} = 0b0100;
   let Inst{22-20} = opcod;
   let Inst{19-16} = 0b1111; // Rn
   let Inst{15-12} = 0b1111;
   let Inst{7} = 1;

   bits<2> rot;
   let Inst{5-4} = rot{1-0}; // rotate
}

// UXTB16 - Requres T2ExtractPack, does not need the .w qualifier.
class T2I_ext_rrot_uxtb16<bits<3> opcod, string opc, PatFrag opnode>
  : T2TwoReg<(outs rGPR:$Rd), (ins rGPR:$Rm, rot_imm:$rot),
             IIC_iEXTr, opc, "\t$Rd, $Rm$rot",
            [(set rGPR:$Rd, (opnode (rotr rGPR:$Rm, rot_imm:$rot)))]>,
          Requires<[HasT2ExtractPack, IsThumb2]> {
  bits<2> rot;
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0100;
  let Inst{22-20} = opcod;
  let Inst{19-16} = 0b1111; // Rn
  let Inst{15-12} = 0b1111;
  let Inst{7} = 1;
  let Inst{5-4} = rot;
}

// SXTB16 - Requres T2ExtractPack, does not need the .w qualifier, no pattern
// supported yet.
class T2I_ext_rrot_sxtb16<bits<3> opcod, string opc>
  : T2TwoReg<(outs rGPR:$Rd), (ins rGPR:$Rm, rot_imm:$rot), IIC_iEXTr,
             opc, "\t$Rd, $Rm$rot", []>,
          Requires<[IsThumb2, HasT2ExtractPack]> {
  bits<2> rot;
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0100;
  let Inst{22-20} = opcod;
  let Inst{19-16} = 0b1111; // Rn
  let Inst{15-12} = 0b1111;
  let Inst{7} = 1;
  let Inst{5-4} = rot;
}

/// T2I_exta_rrot - A binary operation with two forms: one whose operand is a
/// register and one whose operand is a register rotated by 8/16/24.
class T2I_exta_rrot<bits<3> opcod, string opc, PatFrag opnode>
  : T2ThreeReg<(outs rGPR:$Rd),
               (ins rGPR:$Rn, rGPR:$Rm, rot_imm:$rot),
               IIC_iEXTAsr, opc, "\t$Rd, $Rn, $Rm$rot",
             [(set rGPR:$Rd, (opnode rGPR:$Rn, (rotr rGPR:$Rm,rot_imm:$rot)))]>,
           Requires<[HasT2ExtractPack, IsThumb2]> {
  bits<2> rot;
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0100;
  let Inst{22-20} = opcod;
  let Inst{15-12} = 0b1111;
  let Inst{7} = 1;
  let Inst{5-4} = rot;
}

class T2I_exta_rrot_np<bits<3> opcod, string opc>
  : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm,rot_imm:$rot),
               IIC_iEXTAsr, opc, "\t$Rd, $Rn, $Rm$rot", []> {
  bits<2> rot;
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0100;
  let Inst{22-20} = opcod;
  let Inst{15-12} = 0b1111;
  let Inst{7} = 1;
  let Inst{5-4} = rot;
}

//===----------------------------------------------------------------------===//
// Instructions
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
//  Miscellaneous Instructions.
//

class T2PCOneRegImm<dag oops, dag iops, InstrItinClass itin,
           string asm, list<dag> pattern>
  : T2XI<oops, iops, itin, asm, pattern> {
  bits<4> Rd;
  bits<12> label;

  let Inst{11-8}  = Rd;
  let Inst{26}    = label{11};
  let Inst{14-12} = label{10-8};
  let Inst{7-0}   = label{7-0};
}

// LEApcrel - Load a pc-relative address into a register without offending the
// assembler.
def t2ADR : T2PCOneRegImm<(outs rGPR:$Rd),
              (ins t2adrlabel:$addr, pred:$p),
              IIC_iALUi, "adr{$p}.w\t$Rd, $addr", []>,
              Sched<[WriteALU, ReadALU]> {
  let Inst{31-27} = 0b11110;
  let Inst{25-24} = 0b10;
  // Inst{23:21} = '11' (add = FALSE) or '00' (add = TRUE)
  let Inst{22} = 0;
  let Inst{20} = 0;
  let Inst{19-16} = 0b1111; // Rn
  let Inst{15} = 0;

  bits<4> Rd;
  bits<13> addr;
  let Inst{11-8} = Rd;
  let Inst{23}    = addr{12};
  let Inst{21}    = addr{12};
  let Inst{26}    = addr{11};
  let Inst{14-12} = addr{10-8};
  let Inst{7-0}   = addr{7-0};

  let DecoderMethod = "DecodeT2Adr";
}

let neverHasSideEffects = 1, isReMaterializable = 1 in
def t2LEApcrel   : t2PseudoInst<(outs rGPR:$Rd), (ins i32imm:$label, pred:$p),
                                4, IIC_iALUi, []>, Sched<[WriteALU, ReadALU]>;
let hasSideEffects = 1 in
def t2LEApcrelJT : t2PseudoInst<(outs rGPR:$Rd),
                                (ins i32imm:$label, nohash_imm:$id, pred:$p),
                                4, IIC_iALUi,
                                []>, Sched<[WriteALU, ReadALU]>;


//===----------------------------------------------------------------------===//
//  Load / store Instructions.
//

// Load
let canFoldAsLoad = 1, isReMaterializable = 1  in
defm t2LDR   : T2I_ld<0, 0b10, "ldr", IIC_iLoad_i, IIC_iLoad_si, GPR,
                      UnOpFrag<(load node:$Src)>>;

// Loads with zero extension
defm t2LDRH  : T2I_ld<0, 0b01, "ldrh", IIC_iLoad_bh_i, IIC_iLoad_bh_si,
                      GPR, UnOpFrag<(zextloadi16 node:$Src)>>;
defm t2LDRB  : T2I_ld<0, 0b00, "ldrb", IIC_iLoad_bh_i, IIC_iLoad_bh_si,
                      GPR, UnOpFrag<(zextloadi8  node:$Src)>>;

// Loads with sign extension
defm t2LDRSH : T2I_ld<1, 0b01, "ldrsh", IIC_iLoad_bh_i, IIC_iLoad_bh_si,
                      GPR, UnOpFrag<(sextloadi16 node:$Src)>>;
defm t2LDRSB : T2I_ld<1, 0b00, "ldrsb", IIC_iLoad_bh_i, IIC_iLoad_bh_si,
                      GPR, UnOpFrag<(sextloadi8  node:$Src)>>;

let mayLoad = 1, neverHasSideEffects = 1, hasExtraDefRegAllocReq = 1 in {
// Load doubleword
def t2LDRDi8  : T2Ii8s4<1, 0, 1, (outs rGPR:$Rt, rGPR:$Rt2),
                        (ins t2addrmode_imm8s4:$addr),
                        IIC_iLoad_d_i, "ldrd", "\t$Rt, $Rt2, $addr", "", []>;
} // mayLoad = 1, neverHasSideEffects = 1, hasExtraDefRegAllocReq = 1

// zextload i1 -> zextload i8
def : T2Pat<(zextloadi1 t2addrmode_imm12:$addr),
            (t2LDRBi12  t2addrmode_imm12:$addr)>;
def : T2Pat<(zextloadi1 t2addrmode_negimm8:$addr),
            (t2LDRBi8   t2addrmode_negimm8:$addr)>;
def : T2Pat<(zextloadi1 t2addrmode_so_reg:$addr),
            (t2LDRBs    t2addrmode_so_reg:$addr)>;
def : T2Pat<(zextloadi1 (ARMWrapper tconstpool:$addr)),
            (t2LDRBpci  tconstpool:$addr)>;

// extload -> zextload
// FIXME: Reduce the number of patterns by legalizing extload to zextload
// earlier?
def : T2Pat<(extloadi1  t2addrmode_imm12:$addr),
            (t2LDRBi12  t2addrmode_imm12:$addr)>;
def : T2Pat<(extloadi1  t2addrmode_negimm8:$addr),
            (t2LDRBi8   t2addrmode_negimm8:$addr)>;
def : T2Pat<(extloadi1  t2addrmode_so_reg:$addr),
            (t2LDRBs    t2addrmode_so_reg:$addr)>;
def : T2Pat<(extloadi1  (ARMWrapper tconstpool:$addr)),
            (t2LDRBpci  tconstpool:$addr)>;

def : T2Pat<(extloadi8  t2addrmode_imm12:$addr),
            (t2LDRBi12  t2addrmode_imm12:$addr)>;
def : T2Pat<(extloadi8  t2addrmode_negimm8:$addr),
            (t2LDRBi8   t2addrmode_negimm8:$addr)>;
def : T2Pat<(extloadi8  t2addrmode_so_reg:$addr),
            (t2LDRBs    t2addrmode_so_reg:$addr)>;
def : T2Pat<(extloadi8  (ARMWrapper tconstpool:$addr)),
            (t2LDRBpci  tconstpool:$addr)>;

def : T2Pat<(extloadi16 t2addrmode_imm12:$addr),
            (t2LDRHi12  t2addrmode_imm12:$addr)>;
def : T2Pat<(extloadi16 t2addrmode_negimm8:$addr),
            (t2LDRHi8   t2addrmode_negimm8:$addr)>;
def : T2Pat<(extloadi16 t2addrmode_so_reg:$addr),
            (t2LDRHs    t2addrmode_so_reg:$addr)>;
def : T2Pat<(extloadi16 (ARMWrapper tconstpool:$addr)),
            (t2LDRHpci  tconstpool:$addr)>;

// FIXME: The destination register of the loads and stores can't be PC, but
//        can be SP. We need another regclass (similar to rGPR) to represent
//        that. Not a pressing issue since these are selected manually,
//        not via pattern.

// Indexed loads

let mayLoad = 1, neverHasSideEffects = 1 in {
def t2LDR_PRE  : T2Ipreldst<0, 0b10, 1, 1, (outs GPR:$Rt, GPR:$Rn_wb),
                            (ins t2addrmode_imm8_pre:$addr),
                            AddrModeT2_i8, IndexModePre, IIC_iLoad_iu,
                            "ldr", "\t$Rt, $addr!", "$addr.base = $Rn_wb", []>;

def t2LDR_POST : T2Ipostldst<0, 0b10, 1, 0, (outs GPR:$Rt, GPR:$Rn_wb),
                          (ins addr_offset_none:$Rn, t2am_imm8_offset:$offset),
                          AddrModeT2_i8, IndexModePost, IIC_iLoad_iu,
                          "ldr", "\t$Rt, $Rn$offset", "$Rn = $Rn_wb", []>;

def t2LDRB_PRE : T2Ipreldst<0, 0b00, 1, 1, (outs GPR:$Rt, GPR:$Rn_wb),
                            (ins t2addrmode_imm8_pre:$addr),
                            AddrModeT2_i8, IndexModePre, IIC_iLoad_bh_iu,
                            "ldrb", "\t$Rt, $addr!", "$addr.base = $Rn_wb", []>;

def t2LDRB_POST : T2Ipostldst<0, 0b00, 1, 0, (outs GPR:$Rt, GPR:$Rn_wb),
                          (ins addr_offset_none:$Rn, t2am_imm8_offset:$offset),
                          AddrModeT2_i8, IndexModePost, IIC_iLoad_bh_iu,
                          "ldrb", "\t$Rt, $Rn$offset", "$Rn = $Rn_wb", []>;

def t2LDRH_PRE : T2Ipreldst<0, 0b01, 1, 1, (outs GPR:$Rt, GPR:$Rn_wb),
                            (ins t2addrmode_imm8_pre:$addr),
                            AddrModeT2_i8, IndexModePre, IIC_iLoad_bh_iu,
                            "ldrh", "\t$Rt, $addr!", "$addr.base = $Rn_wb", []>;

def t2LDRH_POST : T2Ipostldst<0, 0b01, 1, 0, (outs GPR:$Rt, GPR:$Rn_wb),
                          (ins addr_offset_none:$Rn, t2am_imm8_offset:$offset),
                          AddrModeT2_i8, IndexModePost, IIC_iLoad_bh_iu,
                          "ldrh", "\t$Rt, $Rn$offset", "$Rn = $Rn_wb", []>;

def t2LDRSB_PRE : T2Ipreldst<1, 0b00, 1, 1, (outs GPR:$Rt, GPR:$Rn_wb),
                            (ins t2addrmode_imm8_pre:$addr),
                            AddrModeT2_i8, IndexModePre, IIC_iLoad_bh_iu,
                            "ldrsb", "\t$Rt, $addr!", "$addr.base = $Rn_wb",
                            []>;

def t2LDRSB_POST : T2Ipostldst<1, 0b00, 1, 0, (outs GPR:$Rt, GPR:$Rn_wb),
                          (ins addr_offset_none:$Rn, t2am_imm8_offset:$offset),
                          AddrModeT2_i8, IndexModePost, IIC_iLoad_bh_iu,
                          "ldrsb", "\t$Rt, $Rn$offset", "$Rn = $Rn_wb", []>;

def t2LDRSH_PRE : T2Ipreldst<1, 0b01, 1, 1, (outs GPR:$Rt, GPR:$Rn_wb),
                            (ins t2addrmode_imm8_pre:$addr),
                            AddrModeT2_i8, IndexModePre, IIC_iLoad_bh_iu,
                            "ldrsh", "\t$Rt, $addr!", "$addr.base = $Rn_wb",
                            []>;

def t2LDRSH_POST : T2Ipostldst<1, 0b01, 1, 0, (outs GPR:$Rt, GPR:$Rn_wb),
                          (ins addr_offset_none:$Rn, t2am_imm8_offset:$offset),
                          AddrModeT2_i8, IndexModePost, IIC_iLoad_bh_iu,
                          "ldrsh", "\t$Rt, $Rn$offset", "$Rn = $Rn_wb", []>;
} // mayLoad = 1, neverHasSideEffects = 1

// LDRT, LDRBT, LDRHT, LDRSBT, LDRSHT all have offset mode (PUW=0b110).
// Ref: A8.6.57 LDR (immediate, Thumb) Encoding T4
class T2IldT<bit signed, bits<2> type, string opc, InstrItinClass ii>
  : T2Ii8<(outs rGPR:$Rt), (ins t2addrmode_posimm8:$addr), ii, opc,
          "\t$Rt, $addr", []> {
  bits<4> Rt;
  bits<13> addr;
  let Inst{31-27} = 0b11111;
  let Inst{26-25} = 0b00;
  let Inst{24} = signed;
  let Inst{23} = 0;
  let Inst{22-21} = type;
  let Inst{20} = 1; // load
  let Inst{19-16} = addr{12-9};
  let Inst{15-12} = Rt;
  let Inst{11} = 1;
  let Inst{10-8} = 0b110; // PUW.
  let Inst{7-0} = addr{7-0};

  let DecoderMethod = "DecodeT2LoadT";
}

def t2LDRT   : T2IldT<0, 0b10, "ldrt", IIC_iLoad_i>;
def t2LDRBT  : T2IldT<0, 0b00, "ldrbt", IIC_iLoad_bh_i>;
def t2LDRHT  : T2IldT<0, 0b01, "ldrht", IIC_iLoad_bh_i>;
def t2LDRSBT : T2IldT<1, 0b00, "ldrsbt", IIC_iLoad_bh_i>;
def t2LDRSHT : T2IldT<1, 0b01, "ldrsht", IIC_iLoad_bh_i>;

class T2Ildacq<bits<4> bits23_20, bits<2> bit54, dag oops, dag iops,
               string opc, string asm, list<dag> pattern>
  : Thumb2I<oops, iops, AddrModeNone, 4, NoItinerary,
            opc, asm, "", pattern>, Requires<[IsThumb, HasV8]> {
  bits<4> Rt;
  bits<4> addr;

  let Inst{31-27} = 0b11101;
  let Inst{26-24} = 0b000;
  let Inst{23-20} = bits23_20;
  let Inst{11-6} = 0b111110;
  let Inst{5-4} = bit54;
  let Inst{3-0} = 0b1111;

  // Encode instruction operands
  let Inst{19-16} = addr;
  let Inst{15-12} = Rt;
}

def t2LDA : T2Ildacq<0b1101, 0b10, (outs rGPR:$Rt),
                     (ins addr_offset_none:$addr), "lda", "\t$Rt, $addr", []>;
def t2LDAB : T2Ildacq<0b1101, 0b00, (outs rGPR:$Rt),
                      (ins addr_offset_none:$addr), "ldab", "\t$Rt, $addr", []>;
def t2LDAH : T2Ildacq<0b1101, 0b01, (outs rGPR:$Rt),
                      (ins addr_offset_none:$addr), "ldah", "\t$Rt, $addr", []>;

// Store
defm t2STR :T2I_st<0b10,"str", IIC_iStore_i, IIC_iStore_si, GPR,
                   BinOpFrag<(store node:$LHS, node:$RHS)>>;
defm t2STRB:T2I_st<0b00,"strb", IIC_iStore_bh_i, IIC_iStore_bh_si,
                   rGPR, BinOpFrag<(truncstorei8 node:$LHS, node:$RHS)>>;
defm t2STRH:T2I_st<0b01,"strh", IIC_iStore_bh_i, IIC_iStore_bh_si,
                   rGPR, BinOpFrag<(truncstorei16 node:$LHS, node:$RHS)>>;

// Store doubleword
let mayStore = 1, neverHasSideEffects = 1, hasExtraSrcRegAllocReq = 1 in
def t2STRDi8 : T2Ii8s4<1, 0, 0, (outs),
                       (ins GPR:$Rt, GPR:$Rt2, t2addrmode_imm8s4:$addr),
               IIC_iStore_d_r, "strd", "\t$Rt, $Rt2, $addr", "", []>;

// Indexed stores

let mayStore = 1, neverHasSideEffects = 1 in {
def t2STR_PRE  : T2Ipreldst<0, 0b10, 0, 1, (outs GPRnopc:$Rn_wb),
                            (ins GPRnopc:$Rt, t2addrmode_imm8_pre:$addr),
                            AddrModeT2_i8, IndexModePre, IIC_iStore_iu,
                            "str", "\t$Rt, $addr!",
                            "$addr.base = $Rn_wb,@earlyclobber $Rn_wb", []>;

def t2STRH_PRE  : T2Ipreldst<0, 0b01, 0, 1, (outs GPRnopc:$Rn_wb),
                            (ins rGPR:$Rt, t2addrmode_imm8_pre:$addr),
                            AddrModeT2_i8, IndexModePre, IIC_iStore_iu,
                        "strh", "\t$Rt, $addr!",
                        "$addr.base = $Rn_wb,@earlyclobber $Rn_wb", []>;

def t2STRB_PRE  : T2Ipreldst<0, 0b00, 0, 1, (outs GPRnopc:$Rn_wb),
                            (ins rGPR:$Rt, t2addrmode_imm8_pre:$addr),
                            AddrModeT2_i8, IndexModePre, IIC_iStore_bh_iu,
                        "strb", "\t$Rt, $addr!",
                        "$addr.base = $Rn_wb,@earlyclobber $Rn_wb", []>;
} // mayStore = 1, neverHasSideEffects = 1

def t2STR_POST : T2Ipostldst<0, 0b10, 0, 0, (outs GPRnopc:$Rn_wb),
                            (ins GPRnopc:$Rt, addr_offset_none:$Rn,
                                 t2am_imm8_offset:$offset),
                            AddrModeT2_i8, IndexModePost, IIC_iStore_iu,
                          "str", "\t$Rt, $Rn$offset",
                          "$Rn = $Rn_wb,@earlyclobber $Rn_wb",
             [(set GPRnopc:$Rn_wb,
                  (post_store GPRnopc:$Rt, addr_offset_none:$Rn,
                              t2am_imm8_offset:$offset))]>;

def t2STRH_POST : T2Ipostldst<0, 0b01, 0, 0, (outs GPRnopc:$Rn_wb),
                            (ins rGPR:$Rt, addr_offset_none:$Rn,
                                 t2am_imm8_offset:$offset),
                            AddrModeT2_i8, IndexModePost, IIC_iStore_bh_iu,
                         "strh", "\t$Rt, $Rn$offset",
                         "$Rn = $Rn_wb,@earlyclobber $Rn_wb",
       [(set GPRnopc:$Rn_wb,
             (post_truncsti16 rGPR:$Rt, addr_offset_none:$Rn,
                              t2am_imm8_offset:$offset))]>;

def t2STRB_POST : T2Ipostldst<0, 0b00, 0, 0, (outs GPRnopc:$Rn_wb),
                            (ins rGPR:$Rt, addr_offset_none:$Rn,
                                 t2am_imm8_offset:$offset),
                            AddrModeT2_i8, IndexModePost, IIC_iStore_bh_iu,
                         "strb", "\t$Rt, $Rn$offset",
                         "$Rn = $Rn_wb,@earlyclobber $Rn_wb",
        [(set GPRnopc:$Rn_wb,
              (post_truncsti8 rGPR:$Rt, addr_offset_none:$Rn,
                              t2am_imm8_offset:$offset))]>;

// Pseudo-instructions for pattern matching the pre-indexed stores. We can't
// put the patterns on the instruction definitions directly as ISel wants
// the address base and offset to be separate operands, not a single
// complex operand like we represent the instructions themselves. The
// pseudos map between the two.
let usesCustomInserter = 1,
    Constraints = "$Rn = $Rn_wb,@earlyclobber $Rn_wb" in {
def t2STR_preidx: t2PseudoInst<(outs GPRnopc:$Rn_wb),
               (ins rGPR:$Rt, GPRnopc:$Rn, t2am_imm8_offset:$offset, pred:$p),
               4, IIC_iStore_ru,
      [(set GPRnopc:$Rn_wb,
            (pre_store rGPR:$Rt, GPRnopc:$Rn, t2am_imm8_offset:$offset))]>;
def t2STRB_preidx: t2PseudoInst<(outs GPRnopc:$Rn_wb),
               (ins rGPR:$Rt, GPRnopc:$Rn, t2am_imm8_offset:$offset, pred:$p),
               4, IIC_iStore_ru,
      [(set GPRnopc:$Rn_wb,
            (pre_truncsti8 rGPR:$Rt, GPRnopc:$Rn, t2am_imm8_offset:$offset))]>;
def t2STRH_preidx: t2PseudoInst<(outs GPRnopc:$Rn_wb),
               (ins rGPR:$Rt, GPRnopc:$Rn, t2am_imm8_offset:$offset, pred:$p),
               4, IIC_iStore_ru,
      [(set GPRnopc:$Rn_wb,
            (pre_truncsti16 rGPR:$Rt, GPRnopc:$Rn, t2am_imm8_offset:$offset))]>;
}

// STRT, STRBT, STRHT all have offset mode (PUW=0b110) and are for disassembly
// only.
// Ref: A8.6.193 STR (immediate, Thumb) Encoding T4
class T2IstT<bits<2> type, string opc, InstrItinClass ii>
  : T2Ii8<(outs rGPR:$Rt), (ins t2addrmode_imm8:$addr), ii, opc,
          "\t$Rt, $addr", []> {
  let Inst{31-27} = 0b11111;
  let Inst{26-25} = 0b00;
  let Inst{24} = 0; // not signed
  let Inst{23} = 0;
  let Inst{22-21} = type;
  let Inst{20} = 0; // store
  let Inst{11} = 1;
  let Inst{10-8} = 0b110; // PUW

  bits<4> Rt;
  bits<13> addr;
  let Inst{15-12} = Rt;
  let Inst{19-16} = addr{12-9};
  let Inst{7-0}   = addr{7-0};
}

def t2STRT   : T2IstT<0b10, "strt", IIC_iStore_i>;
def t2STRBT  : T2IstT<0b00, "strbt", IIC_iStore_bh_i>;
def t2STRHT  : T2IstT<0b01, "strht", IIC_iStore_bh_i>;

// ldrd / strd pre / post variants
// For disassembly only.

def t2LDRD_PRE  : T2Ii8s4<1, 1, 1, (outs rGPR:$Rt, rGPR:$Rt2, GPR:$wb),
                 (ins t2addrmode_imm8s4_pre:$addr), IIC_iLoad_d_ru,
                 "ldrd", "\t$Rt, $Rt2, $addr!", "$addr.base = $wb", []> {
  let DecoderMethod = "DecodeT2LDRDPreInstruction";
}

def t2LDRD_POST : T2Ii8s4post<0, 1, 1, (outs rGPR:$Rt, rGPR:$Rt2, GPR:$wb),
                 (ins addr_offset_none:$addr, t2am_imm8s4_offset:$imm),
                 IIC_iLoad_d_ru, "ldrd", "\t$Rt, $Rt2, $addr$imm",
                 "$addr.base = $wb", []>;

def t2STRD_PRE  : T2Ii8s4<1, 1, 0, (outs GPR:$wb),
                 (ins rGPR:$Rt, rGPR:$Rt2, t2addrmode_imm8s4_pre:$addr),
                 IIC_iStore_d_ru, "strd", "\t$Rt, $Rt2, $addr!",
                 "$addr.base = $wb", []> {
  let DecoderMethod = "DecodeT2STRDPreInstruction";
}

def t2STRD_POST : T2Ii8s4post<0, 1, 0, (outs GPR:$wb),
                 (ins rGPR:$Rt, rGPR:$Rt2, addr_offset_none:$addr,
                      t2am_imm8s4_offset:$imm),
                 IIC_iStore_d_ru, "strd", "\t$Rt, $Rt2, $addr$imm",
                 "$addr.base = $wb", []>;

class T2Istrrel<bits<2> bit54, dag oops, dag iops,
                string opc, string asm, list<dag> pattern>
  : Thumb2I<oops, iops, AddrModeNone, 4, NoItinerary, opc,
            asm, "", pattern>, Requires<[IsThumb, HasV8]> {
  bits<4> Rt;
  bits<4> addr;

  let Inst{31-27} = 0b11101;
  let Inst{26-20} = 0b0001100;
  let Inst{11-6} = 0b111110;
  let Inst{5-4} = bit54;
  let Inst{3-0} = 0b1111;

  // Encode instruction operands
  let Inst{19-16} = addr;
  let Inst{15-12} = Rt;
}

def t2STL  : T2Istrrel<0b10, (outs), (ins rGPR:$Rt, addr_offset_none:$addr),
                       "stl", "\t$Rt, $addr", []>;
def t2STLB : T2Istrrel<0b00, (outs), (ins rGPR:$Rt, addr_offset_none:$addr),
                       "stlb", "\t$Rt, $addr", []>;
def t2STLH : T2Istrrel<0b01, (outs), (ins rGPR:$Rt, addr_offset_none:$addr),
                       "stlh", "\t$Rt, $addr", []>;

// T2Ipl (Preload Data/Instruction) signals the memory system of possible future
// data/instruction access.
// instr_write is inverted for Thumb mode: (prefetch 3) -> (preload 0),
// (prefetch 1) -> (preload 2),  (prefetch 2) -> (preload 1).
multiclass T2Ipl<bits<1> write, bits<1> instr, string opc> {

  def i12 : T2Ii12<(outs), (ins t2addrmode_imm12:$addr), IIC_Preload, opc,
                "\t$addr",
              [(ARMPreload t2addrmode_imm12:$addr, (i32 write), (i32 instr))]>,
              Sched<[WritePreLd]> {
    let Inst{31-25} = 0b1111100;
    let Inst{24} = instr;
    let Inst{23} = 1;
    let Inst{22} = 0;
    let Inst{21} = write;
    let Inst{20} = 1;
    let Inst{15-12} = 0b1111;

    bits<17> addr;
    let Inst{19-16} = addr{16-13}; // Rn
    let Inst{11-0}  = addr{11-0};  // imm12

    let DecoderMethod = "DecodeT2LoadImm12";
  }

  def i8 : T2Ii8<(outs), (ins t2addrmode_negimm8:$addr), IIC_Preload, opc,
                "\t$addr",
            [(ARMPreload t2addrmode_negimm8:$addr, (i32 write), (i32 instr))]>,
            Sched<[WritePreLd]> {
    let Inst{31-25} = 0b1111100;
    let Inst{24} = instr;
    let Inst{23} = 0; // U = 0
    let Inst{22} = 0;
    let Inst{21} = write;
    let Inst{20} = 1;
    let Inst{15-12} = 0b1111;
    let Inst{11-8} = 0b1100;

    bits<13> addr;
    let Inst{19-16} = addr{12-9}; // Rn
    let Inst{7-0}   = addr{7-0};  // imm8

    let DecoderMethod = "DecodeT2LoadImm8";
  }

  def s : T2Iso<(outs), (ins t2addrmode_so_reg:$addr), IIC_Preload, opc,
               "\t$addr",
             [(ARMPreload t2addrmode_so_reg:$addr, (i32 write), (i32 instr))]>,
             Sched<[WritePreLd]> {
    let Inst{31-25} = 0b1111100;
    let Inst{24} = instr;
    let Inst{23} = 0; // add = TRUE for T1
    let Inst{22} = 0;
    let Inst{21} = write;
    let Inst{20} = 1;
    let Inst{15-12} = 0b1111;
    let Inst{11-6} = 0b000000;

    bits<10> addr;
    let Inst{19-16} = addr{9-6}; // Rn
    let Inst{3-0}   = addr{5-2}; // Rm
    let Inst{5-4}   = addr{1-0}; // imm2

    let DecoderMethod = "DecodeT2LoadShift";
  }
}

defm t2PLD    : T2Ipl<0, 0, "pld">,  Requires<[IsThumb2]>;
defm t2PLDW   : T2Ipl<1, 0, "pldw">, Requires<[IsThumb2,HasV7,HasMP]>;
defm t2PLI    : T2Ipl<0, 1, "pli">,  Requires<[IsThumb2,HasV7]>;

// pci variant is very similar to i12, but supports negative offsets
// from the PC. Only PLD and PLI have pci variants (not PLDW)
class T2Iplpci<bits<1> inst, string opc> : T2Iso<(outs), (ins t2ldrlabel:$addr),
               IIC_Preload, opc, "\t$addr", 
               [(ARMPreload (ARMWrapper tconstpool:$addr),
                (i32 0), (i32 inst))]>, Sched<[WritePreLd]> {
  let Inst{31-25} = 0b1111100;
  let Inst{24} = inst;
  let Inst{22-20} = 0b001;
  let Inst{19-16} = 0b1111;
  let Inst{15-12} = 0b1111;

  bits<13> addr;
  let Inst{23}   = addr{12};   // add = (U == '1')
  let Inst{11-0} = addr{11-0}; // imm12

  let DecoderMethod = "DecodeT2LoadLabel";
}

def t2PLDpci : T2Iplpci<0, "pld">,  Requires<[IsThumb2]>;
def t2PLIpci : T2Iplpci<1, "pli">,  Requires<[IsThumb2,HasV7]>;

//===----------------------------------------------------------------------===//
//  Load / store multiple Instructions.
//

multiclass thumb2_ld_mult<string asm, InstrItinClass itin,
                            InstrItinClass itin_upd, bit L_bit> {
  def IA :
    T2XI<(outs), (ins GPR:$Rn, pred:$p, reglist:$regs, variable_ops),
         itin, !strconcat(asm, "${p}.w\t$Rn, $regs"), []> {
    bits<4>  Rn;
    bits<16> regs;

    let Inst{31-27} = 0b11101;
    let Inst{26-25} = 0b00;
    let Inst{24-23} = 0b01;     // Increment After
    let Inst{22}    = 0;
    let Inst{21}    = 0;        // No writeback
    let Inst{20}    = L_bit;
    let Inst{19-16} = Rn;
    let Inst{15-0}  = regs;
  }
  def IA_UPD :
    T2XIt<(outs GPR:$wb), (ins GPR:$Rn, pred:$p, reglist:$regs, variable_ops),
          itin_upd, !strconcat(asm, "${p}.w\t$Rn!, $regs"), "$Rn = $wb", []> {
    bits<4>  Rn;
    bits<16> regs;

    let Inst{31-27} = 0b11101;
    let Inst{26-25} = 0b00;
    let Inst{24-23} = 0b01;     // Increment After
    let Inst{22}    = 0;
    let Inst{21}    = 1;        // Writeback
    let Inst{20}    = L_bit;
    let Inst{19-16} = Rn;
    let Inst{15-0}  = regs;
  }
  def DB :
    T2XI<(outs), (ins GPR:$Rn, pred:$p, reglist:$regs, variable_ops),
         itin, !strconcat(asm, "db${p}\t$Rn, $regs"), []> {
    bits<4>  Rn;
    bits<16> regs;

    let Inst{31-27} = 0b11101;
    let Inst{26-25} = 0b00;
    let Inst{24-23} = 0b10;     // Decrement Before
    let Inst{22}    = 0;
    let Inst{21}    = 0;        // No writeback
    let Inst{20}    = L_bit;
    let Inst{19-16} = Rn;
    let Inst{15-0}  = regs;
  }
  def DB_UPD :
    T2XIt<(outs GPR:$wb), (ins GPR:$Rn, pred:$p, reglist:$regs, variable_ops),
          itin_upd, !strconcat(asm, "db${p}\t$Rn!, $regs"), "$Rn = $wb", []> {
    bits<4>  Rn;
    bits<16> regs;

    let Inst{31-27} = 0b11101;
    let Inst{26-25} = 0b00;
    let Inst{24-23} = 0b10;     // Decrement Before
    let Inst{22}    = 0;
    let Inst{21}    = 1;        // Writeback
    let Inst{20}    = L_bit;
    let Inst{19-16} = Rn;
    let Inst{15-0}  = regs;
  }
}

let neverHasSideEffects = 1 in {

let mayLoad = 1, hasExtraDefRegAllocReq = 1 in
defm t2LDM : thumb2_ld_mult<"ldm", IIC_iLoad_m, IIC_iLoad_mu, 1>;

multiclass thumb2_st_mult<string asm, InstrItinClass itin,
                            InstrItinClass itin_upd, bit L_bit> {
  def IA :
    T2XI<(outs), (ins GPR:$Rn, pred:$p, reglist:$regs, variable_ops),
         itin, !strconcat(asm, "${p}.w\t$Rn, $regs"), []> {
    bits<4>  Rn;
    bits<16> regs;

    let Inst{31-27} = 0b11101;
    let Inst{26-25} = 0b00;
    let Inst{24-23} = 0b01;     // Increment After
    let Inst{22}    = 0;
    let Inst{21}    = 0;        // No writeback
    let Inst{20}    = L_bit;
    let Inst{19-16} = Rn;
    let Inst{15}    = 0;
    let Inst{14}    = regs{14};
    let Inst{13}    = 0;
    let Inst{12-0}  = regs{12-0};
  }
  def IA_UPD :
    T2XIt<(outs GPR:$wb), (ins GPR:$Rn, pred:$p, reglist:$regs, variable_ops),
          itin_upd, !strconcat(asm, "${p}.w\t$Rn!, $regs"), "$Rn = $wb", []> {
    bits<4>  Rn;
    bits<16> regs;

    let Inst{31-27} = 0b11101;
    let Inst{26-25} = 0b00;
    let Inst{24-23} = 0b01;     // Increment After
    let Inst{22}    = 0;
    let Inst{21}    = 1;        // Writeback
    let Inst{20}    = L_bit;
    let Inst{19-16} = Rn;
    let Inst{15}    = 0;
    let Inst{14}    = regs{14};
    let Inst{13}    = 0;
    let Inst{12-0}  = regs{12-0};
  }
  def DB :
    T2XI<(outs), (ins GPR:$Rn, pred:$p, reglist:$regs, variable_ops),
         itin, !strconcat(asm, "db${p}\t$Rn, $regs"), []> {
    bits<4>  Rn;
    bits<16> regs;

    let Inst{31-27} = 0b11101;
    let Inst{26-25} = 0b00;
    let Inst{24-23} = 0b10;     // Decrement Before
    let Inst{22}    = 0;
    let Inst{21}    = 0;        // No writeback
    let Inst{20}    = L_bit;
    let Inst{19-16} = Rn;
    let Inst{15}    = 0;
    let Inst{14}    = regs{14};
    let Inst{13}    = 0;
    let Inst{12-0}  = regs{12-0};
  }
  def DB_UPD :
    T2XIt<(outs GPR:$wb), (ins GPR:$Rn, pred:$p, reglist:$regs, variable_ops),
          itin_upd, !strconcat(asm, "db${p}\t$Rn!, $regs"), "$Rn = $wb", []> {
    bits<4>  Rn;
    bits<16> regs;

    let Inst{31-27} = 0b11101;
    let Inst{26-25} = 0b00;
    let Inst{24-23} = 0b10;     // Decrement Before
    let Inst{22}    = 0;
    let Inst{21}    = 1;        // Writeback
    let Inst{20}    = L_bit;
    let Inst{19-16} = Rn;
    let Inst{15}    = 0;
    let Inst{14}    = regs{14};
    let Inst{13}    = 0;
    let Inst{12-0}  = regs{12-0};
  }
}


let mayStore = 1, hasExtraSrcRegAllocReq = 1 in
defm t2STM : thumb2_st_mult<"stm", IIC_iStore_m, IIC_iStore_mu, 0>;

} // neverHasSideEffects


//===----------------------------------------------------------------------===//
//  Move Instructions.
//

let neverHasSideEffects = 1 in
def t2MOVr : T2sTwoReg<(outs GPRnopc:$Rd), (ins GPR:$Rm), IIC_iMOVr,
                   "mov", ".w\t$Rd, $Rm", []>, Sched<[WriteALU]> {
  let Inst{31-27} = 0b11101;
  let Inst{26-25} = 0b01;
  let Inst{24-21} = 0b0010;
  let Inst{19-16} = 0b1111; // Rn
  let Inst{14-12} = 0b000;
  let Inst{7-4} = 0b0000;
}
def : t2InstAlias<"mov${p}.w $Rd, $Rm", (t2MOVr GPRnopc:$Rd, GPR:$Rm,
                                                pred:$p, zero_reg)>;
def : t2InstAlias<"movs${p}.w $Rd, $Rm", (t2MOVr GPRnopc:$Rd, GPR:$Rm,
                                                 pred:$p, CPSR)>;
def : t2InstAlias<"movs${p} $Rd, $Rm", (t2MOVr GPRnopc:$Rd, GPR:$Rm,
                                               pred:$p, CPSR)>;

// AddedComplexity to ensure isel tries t2MOVi before t2MOVi16.
let isReMaterializable = 1, isAsCheapAsAMove = 1, isMoveImm = 1,
    AddedComplexity = 1 in
def t2MOVi : T2sOneRegImm<(outs rGPR:$Rd), (ins t2_so_imm:$imm), IIC_iMOVi,
                   "mov", ".w\t$Rd, $imm",
                   [(set rGPR:$Rd, t2_so_imm:$imm)]>, Sched<[WriteALU]> {
  let Inst{31-27} = 0b11110;
  let Inst{25} = 0;
  let Inst{24-21} = 0b0010;
  let Inst{19-16} = 0b1111; // Rn
  let Inst{15} = 0;
}

// cc_out is handled as part of the explicit mnemonic in the parser for 'mov'.
// Use aliases to get that to play nice here.
def : t2InstAlias<"movs${p}.w $Rd, $imm", (t2MOVi rGPR:$Rd, t2_so_imm:$imm,
                                                pred:$p, CPSR)>;
def : t2InstAlias<"movs${p} $Rd, $imm", (t2MOVi rGPR:$Rd, t2_so_imm:$imm,
                                                pred:$p, CPSR)>;

def : t2InstAlias<"mov${p}.w $Rd, $imm", (t2MOVi rGPR:$Rd, t2_so_imm:$imm,
                                                 pred:$p, zero_reg)>;
def : t2InstAlias<"mov${p} $Rd, $imm", (t2MOVi rGPR:$Rd, t2_so_imm:$imm,
                                               pred:$p, zero_reg)>;

let isReMaterializable = 1, isAsCheapAsAMove = 1, isMoveImm = 1 in
def t2MOVi16 : T2I<(outs rGPR:$Rd), (ins imm0_65535_expr:$imm), IIC_iMOVi,
                   "movw", "\t$Rd, $imm",
                   [(set rGPR:$Rd, imm0_65535:$imm)]>, Sched<[WriteALU]> {
  let Inst{31-27} = 0b11110;
  let Inst{25} = 1;
  let Inst{24-21} = 0b0010;
  let Inst{20} = 0; // The S bit.
  let Inst{15} = 0;

  bits<4> Rd;
  bits<16> imm;

  let Inst{11-8}  = Rd;
  let Inst{19-16} = imm{15-12};
  let Inst{26}    = imm{11};
  let Inst{14-12} = imm{10-8};
  let Inst{7-0}   = imm{7-0};
  let DecoderMethod = "DecodeT2MOVTWInstruction";
}

def : t2InstAlias<"mov${p} $Rd, $imm", 
                  (t2MOVi16 rGPR:$Rd, imm256_65535_expr:$imm, pred:$p)>;

def t2MOVi16_ga_pcrel : PseudoInst<(outs rGPR:$Rd),
                                (ins i32imm:$addr, pclabel:$id), IIC_iMOVi, []>;

let Constraints = "$src = $Rd" in {
def t2MOVTi16 : T2I<(outs rGPR:$Rd),
                    (ins rGPR:$src, imm0_65535_expr:$imm), IIC_iMOVi,
                    "movt", "\t$Rd, $imm",
                    [(set rGPR:$Rd,
                          (or (and rGPR:$src, 0xffff), lo16AllZero:$imm))]>,
                          Sched<[WriteALU]> {
  let Inst{31-27} = 0b11110;
  let Inst{25} = 1;
  let Inst{24-21} = 0b0110;
  let Inst{20} = 0; // The S bit.
  let Inst{15} = 0;

  bits<4> Rd;
  bits<16> imm;

  let Inst{11-8}  = Rd;
  let Inst{19-16} = imm{15-12};
  let Inst{26}    = imm{11};
  let Inst{14-12} = imm{10-8};
  let Inst{7-0}   = imm{7-0};
  let DecoderMethod = "DecodeT2MOVTWInstruction";
}

def t2MOVTi16_ga_pcrel : PseudoInst<(outs rGPR:$Rd),
                     (ins rGPR:$src, i32imm:$addr, pclabel:$id), IIC_iMOVi, []>,
                     Sched<[WriteALU]>;
} // Constraints

def : T2Pat<(or rGPR:$src, 0xffff0000), (t2MOVTi16 rGPR:$src, 0xffff)>;

//===----------------------------------------------------------------------===//
//  Extend Instructions.
//

// Sign extenders

def t2SXTB  : T2I_ext_rrot<0b100, "sxtb",
                              UnOpFrag<(sext_inreg node:$Src, i8)>>;
def t2SXTH  : T2I_ext_rrot<0b000, "sxth",
                              UnOpFrag<(sext_inreg node:$Src, i16)>>;
def t2SXTB16 : T2I_ext_rrot_sxtb16<0b010, "sxtb16">;

def t2SXTAB : T2I_exta_rrot<0b100, "sxtab",
                        BinOpFrag<(add node:$LHS, (sext_inreg node:$RHS, i8))>>;
def t2SXTAH : T2I_exta_rrot<0b000, "sxtah",
                        BinOpFrag<(add node:$LHS, (sext_inreg node:$RHS,i16))>>;
def t2SXTAB16 : T2I_exta_rrot_np<0b010, "sxtab16">;

// Zero extenders

let AddedComplexity = 16 in {
def t2UXTB   : T2I_ext_rrot<0b101, "uxtb",
                               UnOpFrag<(and node:$Src, 0x000000FF)>>;
def t2UXTH   : T2I_ext_rrot<0b001, "uxth",
                               UnOpFrag<(and node:$Src, 0x0000FFFF)>>;
def t2UXTB16 : T2I_ext_rrot_uxtb16<0b011, "uxtb16",
                               UnOpFrag<(and node:$Src, 0x00FF00FF)>>;

// FIXME: This pattern incorrectly assumes the shl operator is a rotate.
//        The transformation should probably be done as a combiner action
//        instead so we can include a check for masking back in the upper
//        eight bits of the source into the lower eight bits of the result.
//def : T2Pat<(and (shl rGPR:$Src, (i32 8)), 0xFF00FF),
//            (t2UXTB16 rGPR:$Src, 3)>,
//          Requires<[HasT2ExtractPack, IsThumb2]>;
def : T2Pat<(and (srl rGPR:$Src, (i32 8)), 0xFF00FF),
            (t2UXTB16 rGPR:$Src, 1)>,
        Requires<[HasT2ExtractPack, IsThumb2]>;

def t2UXTAB : T2I_exta_rrot<0b101, "uxtab",
                           BinOpFrag<(add node:$LHS, (and node:$RHS, 0x00FF))>>;
def t2UXTAH : T2I_exta_rrot<0b001, "uxtah",
                           BinOpFrag<(add node:$LHS, (and node:$RHS, 0xFFFF))>>;
def t2UXTAB16 : T2I_exta_rrot_np<0b011, "uxtab16">;
}

//===----------------------------------------------------------------------===//
//  Arithmetic Instructions.
//

defm t2ADD  : T2I_bin_ii12rs<0b000, "add",
                             BinOpFrag<(add  node:$LHS, node:$RHS)>, 1>;
defm t2SUB  : T2I_bin_ii12rs<0b101, "sub",
                             BinOpFrag<(sub  node:$LHS, node:$RHS)>>;

// ADD and SUB with 's' bit set. No 12-bit immediate (T4) variants.
//
// Currently, t2ADDS/t2SUBS are pseudo opcodes that exist only in the
// selection DAG. They are "lowered" to real t2ADD/t2SUB opcodes by
// AdjustInstrPostInstrSelection where we determine whether or not to
// set the "s" bit based on CPSR liveness.
//
// FIXME: Eliminate t2ADDS/t2SUBS pseudo opcodes after adding tablegen
// support for an optional CPSR definition that corresponds to the DAG
// node's second value. We can then eliminate the implicit def of CPSR.
defm t2ADDS : T2I_bin_s_irs <IIC_iALUi, IIC_iALUr, IIC_iALUsi,
                             BinOpFrag<(ARMaddc node:$LHS, node:$RHS)>, 1>;
defm t2SUBS : T2I_bin_s_irs <IIC_iALUi, IIC_iALUr, IIC_iALUsi,
                             BinOpFrag<(ARMsubc node:$LHS, node:$RHS)>>;

let hasPostISelHook = 1 in {
defm t2ADC  : T2I_adde_sube_irs<0b1010, "adc",
              BinOpWithFlagFrag<(ARMadde node:$LHS, node:$RHS, node:$FLAG)>, 1>;
defm t2SBC  : T2I_adde_sube_irs<0b1011, "sbc",
              BinOpWithFlagFrag<(ARMsube node:$LHS, node:$RHS, node:$FLAG)>>;
}

// RSB
defm t2RSB  : T2I_rbin_irs  <0b1110, "rsb",
                             BinOpFrag<(sub  node:$LHS, node:$RHS)>>;

// FIXME: Eliminate them if we can write def : Pat patterns which defines
// CPSR and the implicit def of CPSR is not needed.
defm t2RSBS : T2I_rbin_s_is <BinOpFrag<(ARMsubc node:$LHS, node:$RHS)>>;

// (sub X, imm) gets canonicalized to (add X, -imm).  Match this form.
// The assume-no-carry-in form uses the negation of the input since add/sub
// assume opposite meanings of the carry flag (i.e., carry == !borrow).
// See the definition of AddWithCarry() in the ARM ARM A2.2.1 for the gory
// details.
// The AddedComplexity preferences the first variant over the others since
// it can be shrunk to a 16-bit wide encoding, while the others cannot.
let AddedComplexity = 1 in
def : T2Pat<(add        GPR:$src, imm1_255_neg:$imm),
            (t2SUBri    GPR:$src, imm1_255_neg:$imm)>;
def : T2Pat<(add        GPR:$src, t2_so_imm_neg:$imm),
            (t2SUBri    GPR:$src, t2_so_imm_neg:$imm)>;
def : T2Pat<(add        GPR:$src, imm0_4095_neg:$imm),
            (t2SUBri12  GPR:$src, imm0_4095_neg:$imm)>;
def : T2Pat<(add        GPR:$src, imm0_65535_neg:$imm),
            (t2SUBrr    GPR:$src, (t2MOVi16 (imm_neg_XFORM imm:$imm)))>;

let AddedComplexity = 1 in
def : T2Pat<(ARMaddc    rGPR:$src, imm1_255_neg:$imm),
            (t2SUBSri   rGPR:$src, imm1_255_neg:$imm)>;
def : T2Pat<(ARMaddc    rGPR:$src, t2_so_imm_neg:$imm),
            (t2SUBSri   rGPR:$src, t2_so_imm_neg:$imm)>;
def : T2Pat<(ARMaddc    rGPR:$src, imm0_65535_neg:$imm),
            (t2SUBSrr   rGPR:$src, (t2MOVi16 (imm_neg_XFORM imm:$imm)))>;
// The with-carry-in form matches bitwise not instead of the negation.
// Effectively, the inverse interpretation of the carry flag already accounts
// for part of the negation.
let AddedComplexity = 1 in
def : T2Pat<(ARMadde    rGPR:$src, imm0_255_not:$imm, CPSR),
            (t2SBCri    rGPR:$src, imm0_255_not:$imm)>;
def : T2Pat<(ARMadde    rGPR:$src, t2_so_imm_not:$imm, CPSR),
            (t2SBCri    rGPR:$src, t2_so_imm_not:$imm)>;
def : T2Pat<(ARMadde    rGPR:$src, imm0_65535_neg:$imm, CPSR),
            (t2SBCrr    rGPR:$src, (t2MOVi16 (imm_not_XFORM imm:$imm)))>;

// Select Bytes -- for disassembly only

def t2SEL : T2ThreeReg<(outs GPR:$Rd), (ins GPR:$Rn, GPR:$Rm),
                NoItinerary, "sel", "\t$Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-24} = 0b010;
  let Inst{23} = 0b1;
  let Inst{22-20} = 0b010;
  let Inst{15-12} = 0b1111;
  let Inst{7} = 0b1;
  let Inst{6-4} = 0b000;
}

// A6.3.13, A6.3.14, A6.3.15 Parallel addition and subtraction (signed/unsigned)
// And Miscellaneous operations -- for disassembly only
class T2I_pam<bits<3> op22_20, bits<4> op7_4, string opc,
              list<dag> pat = [/* For disassembly only; pattern left blank */],
              dag iops = (ins rGPR:$Rn, rGPR:$Rm),
              string asm = "\t$Rd, $Rn, $Rm">
  : T2I<(outs rGPR:$Rd), iops, NoItinerary, opc, asm, pat>,
    Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0101;
  let Inst{22-20} = op22_20;
  let Inst{15-12} = 0b1111;
  let Inst{7-4} = op7_4;

  bits<4> Rd;
  bits<4> Rn;
  bits<4> Rm;

  let Inst{11-8}  = Rd;
  let Inst{19-16} = Rn;
  let Inst{3-0}   = Rm;
}

// Saturating add/subtract -- for disassembly only

def t2QADD    : T2I_pam<0b000, 0b1000, "qadd",
                        [(set rGPR:$Rd, (int_arm_qadd rGPR:$Rn, rGPR:$Rm))],
                        (ins rGPR:$Rm, rGPR:$Rn), "\t$Rd, $Rm, $Rn">;
def t2QADD16  : T2I_pam<0b001, 0b0001, "qadd16">;
def t2QADD8   : T2I_pam<0b000, 0b0001, "qadd8">;
def t2QASX    : T2I_pam<0b010, 0b0001, "qasx">;
def t2QDADD   : T2I_pam<0b000, 0b1001, "qdadd", [],
                        (ins rGPR:$Rm, rGPR:$Rn), "\t$Rd, $Rm, $Rn">;
def t2QDSUB   : T2I_pam<0b000, 0b1011, "qdsub", [],
                        (ins rGPR:$Rm, rGPR:$Rn), "\t$Rd, $Rm, $Rn">;
def t2QSAX    : T2I_pam<0b110, 0b0001, "qsax">;
def t2QSUB    : T2I_pam<0b000, 0b1010, "qsub",
                        [(set rGPR:$Rd, (int_arm_qsub rGPR:$Rn, rGPR:$Rm))],
                        (ins rGPR:$Rm, rGPR:$Rn), "\t$Rd, $Rm, $Rn">;
def t2QSUB16  : T2I_pam<0b101, 0b0001, "qsub16">;
def t2QSUB8   : T2I_pam<0b100, 0b0001, "qsub8">;
def t2UQADD16 : T2I_pam<0b001, 0b0101, "uqadd16">;
def t2UQADD8  : T2I_pam<0b000, 0b0101, "uqadd8">;
def t2UQASX   : T2I_pam<0b010, 0b0101, "uqasx">;
def t2UQSAX   : T2I_pam<0b110, 0b0101, "uqsax">;
def t2UQSUB16 : T2I_pam<0b101, 0b0101, "uqsub16">;
def t2UQSUB8  : T2I_pam<0b100, 0b0101, "uqsub8">;

// Signed/Unsigned add/subtract -- for disassembly only

def t2SASX    : T2I_pam<0b010, 0b0000, "sasx">;
def t2SADD16  : T2I_pam<0b001, 0b0000, "sadd16">;
def t2SADD8   : T2I_pam<0b000, 0b0000, "sadd8">;
def t2SSAX    : T2I_pam<0b110, 0b0000, "ssax">;
def t2SSUB16  : T2I_pam<0b101, 0b0000, "ssub16">;
def t2SSUB8   : T2I_pam<0b100, 0b0000, "ssub8">;
def t2UASX    : T2I_pam<0b010, 0b0100, "uasx">;
def t2UADD16  : T2I_pam<0b001, 0b0100, "uadd16">;
def t2UADD8   : T2I_pam<0b000, 0b0100, "uadd8">;
def t2USAX    : T2I_pam<0b110, 0b0100, "usax">;
def t2USUB16  : T2I_pam<0b101, 0b0100, "usub16">;
def t2USUB8   : T2I_pam<0b100, 0b0100, "usub8">;

// Signed/Unsigned halving add/subtract -- for disassembly only

def t2SHASX   : T2I_pam<0b010, 0b0010, "shasx">;
def t2SHADD16 : T2I_pam<0b001, 0b0010, "shadd16">;
def t2SHADD8  : T2I_pam<0b000, 0b0010, "shadd8">;
def t2SHSAX   : T2I_pam<0b110, 0b0010, "shsax">;
def t2SHSUB16 : T2I_pam<0b101, 0b0010, "shsub16">;
def t2SHSUB8  : T2I_pam<0b100, 0b0010, "shsub8">;
def t2UHASX   : T2I_pam<0b010, 0b0110, "uhasx">;
def t2UHADD16 : T2I_pam<0b001, 0b0110, "uhadd16">;
def t2UHADD8  : T2I_pam<0b000, 0b0110, "uhadd8">;
def t2UHSAX   : T2I_pam<0b110, 0b0110, "uhsax">;
def t2UHSUB16 : T2I_pam<0b101, 0b0110, "uhsub16">;
def t2UHSUB8  : T2I_pam<0b100, 0b0110, "uhsub8">;

// Helper class for disassembly only
// A6.3.16 & A6.3.17
// T2Imac - Thumb2 multiply [accumulate, and absolute difference] instructions.
class T2ThreeReg_mac<bit long, bits<3> op22_20, bits<4> op7_4, dag oops,
  dag iops, InstrItinClass itin, string opc, string asm, list<dag> pattern>
  : T2ThreeReg<oops, iops, itin, opc, asm, pattern> {
  let Inst{31-27} = 0b11111;
  let Inst{26-24} = 0b011;
  let Inst{23}    = long;
  let Inst{22-20} = op22_20;
  let Inst{7-4}   = op7_4;
}

class T2FourReg_mac<bit long, bits<3> op22_20, bits<4> op7_4, dag oops,
  dag iops, InstrItinClass itin, string opc, string asm, list<dag> pattern>
  : T2FourReg<oops, iops, itin, opc, asm, pattern> {
  let Inst{31-27} = 0b11111;
  let Inst{26-24} = 0b011;
  let Inst{23}    = long;
  let Inst{22-20} = op22_20;
  let Inst{7-4}   = op7_4;
}

// Unsigned Sum of Absolute Differences [and Accumulate].
def t2USAD8   : T2ThreeReg_mac<0, 0b111, 0b0000, (outs rGPR:$Rd),
                                           (ins rGPR:$Rn, rGPR:$Rm),
                        NoItinerary, "usad8", "\t$Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{15-12} = 0b1111;
}
def t2USADA8  : T2FourReg_mac<0, 0b111, 0b0000, (outs rGPR:$Rd),
                       (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), NoItinerary,
                        "usada8", "\t$Rd, $Rn, $Rm, $Ra", []>,
          Requires<[IsThumb2, HasThumb2DSP]>;

// Signed/Unsigned saturate.
class T2SatI<dag oops, dag iops, InstrItinClass itin,
           string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<4> Rn;
  bits<5> sat_imm;
  bits<7> sh;

  let Inst{11-8}  = Rd;
  let Inst{19-16} = Rn;
  let Inst{4-0}   = sat_imm;
  let Inst{21}    = sh{5};
  let Inst{14-12} = sh{4-2};
  let Inst{7-6}   = sh{1-0};
}

def t2SSAT: T2SatI<
              (outs rGPR:$Rd),
              (ins imm1_32:$sat_imm, rGPR:$Rn, t2_shift_imm:$sh),
              NoItinerary, "ssat", "\t$Rd, $sat_imm, $Rn$sh", []> {
  let Inst{31-27} = 0b11110;
  let Inst{25-22} = 0b1100;
  let Inst{20} = 0;
  let Inst{15} = 0;
  let Inst{5}  = 0;
}

def t2SSAT16: T2SatI<
                (outs rGPR:$Rd), (ins imm1_16:$sat_imm, rGPR:$Rn), NoItinerary,
                "ssat16", "\t$Rd, $sat_imm, $Rn", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{31-27} = 0b11110;
  let Inst{25-22} = 0b1100;
  let Inst{20} = 0;
  let Inst{15} = 0;
  let Inst{21} = 1;        // sh = '1'
  let Inst{14-12} = 0b000; // imm3 = '000'
  let Inst{7-6} = 0b00;    // imm2 = '00'
  let Inst{5-4} = 0b00;
}

def t2USAT: T2SatI<
               (outs rGPR:$Rd),
               (ins imm0_31:$sat_imm, rGPR:$Rn, t2_shift_imm:$sh),
                NoItinerary, "usat", "\t$Rd, $sat_imm, $Rn$sh", []> {
  let Inst{31-27} = 0b11110;
  let Inst{25-22} = 0b1110;
  let Inst{20} = 0;
  let Inst{15} = 0;
}

def t2USAT16: T2SatI<(outs rGPR:$Rd), (ins imm0_15:$sat_imm, rGPR:$Rn),
                     NoItinerary,
                     "usat16", "\t$Rd, $sat_imm, $Rn", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{31-22} = 0b1111001110;
  let Inst{20} = 0;
  let Inst{15} = 0;
  let Inst{21} = 1;        // sh = '1'
  let Inst{14-12} = 0b000; // imm3 = '000'
  let Inst{7-6} = 0b00;    // imm2 = '00'
  let Inst{5-4} = 0b00;
}

def : T2Pat<(int_arm_ssat GPR:$a, imm:$pos), (t2SSAT imm:$pos, GPR:$a, 0)>;
def : T2Pat<(int_arm_usat GPR:$a, imm:$pos), (t2USAT imm:$pos, GPR:$a, 0)>;

//===----------------------------------------------------------------------===//
//  Shift and rotate Instructions.
//

defm t2LSL  : T2I_sh_ir<0b00, "lsl", imm0_31,
                        BinOpFrag<(shl  node:$LHS, node:$RHS)>>;
defm t2LSR  : T2I_sh_ir<0b01, "lsr", imm_sr,
                        BinOpFrag<(srl  node:$LHS, node:$RHS)>>;
defm t2ASR  : T2I_sh_ir<0b10, "asr", imm_sr,
                        BinOpFrag<(sra  node:$LHS, node:$RHS)>>;
defm t2ROR  : T2I_sh_ir<0b11, "ror", imm0_31,
                        BinOpFrag<(rotr node:$LHS, node:$RHS)>>;

// (rotr x, (and y, 0x...1f)) ==> (ROR x, y)
def : T2Pat<(rotr rGPR:$lhs, (and rGPR:$rhs, lo5AllOne)),
            (t2RORrr rGPR:$lhs, rGPR:$rhs)>;

let Uses = [CPSR] in {
def t2RRX : T2sTwoReg<(outs rGPR:$Rd), (ins rGPR:$Rm), IIC_iMOVsi,
                   "rrx", "\t$Rd, $Rm",
                   [(set rGPR:$Rd, (ARMrrx rGPR:$Rm))]>, Sched<[WriteALU]> {
  let Inst{31-27} = 0b11101;
  let Inst{26-25} = 0b01;
  let Inst{24-21} = 0b0010;
  let Inst{19-16} = 0b1111; // Rn
  let Inst{14-12} = 0b000;
  let Inst{7-4} = 0b0011;
}
}

let isCodeGenOnly = 1, Defs = [CPSR] in {
def t2MOVsrl_flag : T2TwoRegShiftImm<
                        (outs rGPR:$Rd), (ins rGPR:$Rm), IIC_iMOVsi,
                        "lsrs", ".w\t$Rd, $Rm, #1",
                        [(set rGPR:$Rd, (ARMsrl_flag rGPR:$Rm))]>,
                        Sched<[WriteALU]> {
  let Inst{31-27} = 0b11101;
  let Inst{26-25} = 0b01;
  let Inst{24-21} = 0b0010;
  let Inst{20} = 1; // The S bit.
  let Inst{19-16} = 0b1111; // Rn
  let Inst{5-4} = 0b01; // Shift type.
  // Shift amount = Inst{14-12:7-6} = 1.
  let Inst{14-12} = 0b000;
  let Inst{7-6} = 0b01;
}
def t2MOVsra_flag : T2TwoRegShiftImm<
                        (outs rGPR:$Rd), (ins rGPR:$Rm), IIC_iMOVsi,
                        "asrs", ".w\t$Rd, $Rm, #1",
                        [(set rGPR:$Rd, (ARMsra_flag rGPR:$Rm))]>,
                        Sched<[WriteALU]> {
  let Inst{31-27} = 0b11101;
  let Inst{26-25} = 0b01;
  let Inst{24-21} = 0b0010;
  let Inst{20} = 1; // The S bit.
  let Inst{19-16} = 0b1111; // Rn
  let Inst{5-4} = 0b10; // Shift type.
  // Shift amount = Inst{14-12:7-6} = 1.
  let Inst{14-12} = 0b000;
  let Inst{7-6} = 0b01;
}
}

//===----------------------------------------------------------------------===//
//  Bitwise Instructions.
//

defm t2AND  : T2I_bin_w_irs<0b0000, "and",
                            IIC_iBITi, IIC_iBITr, IIC_iBITsi,
                            BinOpFrag<(and node:$LHS, node:$RHS)>, 1>;
defm t2ORR  : T2I_bin_w_irs<0b0010, "orr",
                            IIC_iBITi, IIC_iBITr, IIC_iBITsi,
                            BinOpFrag<(or  node:$LHS, node:$RHS)>, 1>;
defm t2EOR  : T2I_bin_w_irs<0b0100, "eor",
                            IIC_iBITi, IIC_iBITr, IIC_iBITsi,
                            BinOpFrag<(xor node:$LHS, node:$RHS)>, 1>;

defm t2BIC  : T2I_bin_w_irs<0b0001, "bic",
                            IIC_iBITi, IIC_iBITr, IIC_iBITsi,
                            BinOpFrag<(and node:$LHS, (not node:$RHS))>>;

class T2BitFI<dag oops, dag iops, InstrItinClass itin,
              string opc, string asm, list<dag> pattern>
    : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rd;
  bits<5> msb;
  bits<5> lsb;

  let Inst{11-8}  = Rd;
  let Inst{4-0}   = msb{4-0};
  let Inst{14-12} = lsb{4-2};
  let Inst{7-6}   = lsb{1-0};
}

class T2TwoRegBitFI<dag oops, dag iops, InstrItinClass itin,
              string opc, string asm, list<dag> pattern>
    : T2BitFI<oops, iops, itin, opc, asm, pattern> {
  bits<4> Rn;

  let Inst{19-16} = Rn;
}

let Constraints = "$src = $Rd" in
def t2BFC : T2BitFI<(outs rGPR:$Rd), (ins rGPR:$src, bf_inv_mask_imm:$imm),
                IIC_iUNAsi, "bfc", "\t$Rd, $imm",
                [(set rGPR:$Rd, (and rGPR:$src, bf_inv_mask_imm:$imm))]> {
  let Inst{31-27} = 0b11110;
  let Inst{26} = 0; // should be 0.
  let Inst{25} = 1;
  let Inst{24-20} = 0b10110;
  let Inst{19-16} = 0b1111; // Rn
  let Inst{15} = 0;
  let Inst{5} = 0; // should be 0.

  bits<10> imm;
  let msb{4-0} = imm{9-5};
  let lsb{4-0} = imm{4-0};
}

def t2SBFX: T2TwoRegBitFI<
                (outs rGPR:$Rd), (ins rGPR:$Rn, imm0_31:$lsb, imm1_32:$msb),
                 IIC_iUNAsi, "sbfx", "\t$Rd, $Rn, $lsb, $msb", []> {
  let Inst{31-27} = 0b11110;
  let Inst{25} = 1;
  let Inst{24-20} = 0b10100;
  let Inst{15} = 0;
}

def t2UBFX: T2TwoRegBitFI<
                (outs rGPR:$Rd), (ins rGPR:$Rn, imm0_31:$lsb, imm1_32:$msb),
                 IIC_iUNAsi, "ubfx", "\t$Rd, $Rn, $lsb, $msb", []> {
  let Inst{31-27} = 0b11110;
  let Inst{25} = 1;
  let Inst{24-20} = 0b11100;
  let Inst{15} = 0;
}

// A8.6.18  BFI - Bitfield insert (Encoding T1)
let Constraints = "$src = $Rd" in {
  def t2BFI : T2TwoRegBitFI<(outs rGPR:$Rd),
                  (ins rGPR:$src, rGPR:$Rn, bf_inv_mask_imm:$imm),
                  IIC_iBITi, "bfi", "\t$Rd, $Rn, $imm",
                  [(set rGPR:$Rd, (ARMbfi rGPR:$src, rGPR:$Rn,
                                   bf_inv_mask_imm:$imm))]> {
    let Inst{31-27} = 0b11110;
    let Inst{26} = 0; // should be 0.
    let Inst{25} = 1;
    let Inst{24-20} = 0b10110;
    let Inst{15} = 0;
    let Inst{5} = 0; // should be 0.

    bits<10> imm;
    let msb{4-0} = imm{9-5};
    let lsb{4-0} = imm{4-0};
  }
}

defm t2ORN  : T2I_bin_irs<0b0011, "orn",
                          IIC_iBITi, IIC_iBITr, IIC_iBITsi,
                          BinOpFrag<(or node:$LHS, (not node:$RHS))>, 0, "">;

/// T2I_un_irs - Defines a set of (op reg, {so_imm|r|so_reg}) patterns for a
/// unary operation that produces a value. These are predicable and can be
/// changed to modify CPSR.
multiclass T2I_un_irs<bits<4> opcod, string opc,
                     InstrItinClass iii, InstrItinClass iir, InstrItinClass iis,
                      PatFrag opnode,
                      bit Cheap = 0, bit ReMat = 0, bit MoveImm = 0> {
   // shifted imm
   def i : T2sOneRegImm<(outs rGPR:$Rd), (ins t2_so_imm:$imm), iii,
                opc, "\t$Rd, $imm",
                [(set rGPR:$Rd, (opnode t2_so_imm:$imm))]>, Sched<[WriteALU]> {
     let isAsCheapAsAMove = Cheap;
     let isReMaterializable = ReMat;
     let isMoveImm = MoveImm;
     let Inst{31-27} = 0b11110;
     let Inst{25} = 0;
     let Inst{24-21} = opcod;
     let Inst{19-16} = 0b1111; // Rn
     let Inst{15} = 0;
   }
   // register
   def r : T2sTwoReg<(outs rGPR:$Rd), (ins rGPR:$Rm), iir,
                opc, ".w\t$Rd, $Rm",
                [(set rGPR:$Rd, (opnode rGPR:$Rm))]>, Sched<[WriteALU]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = opcod;
     let Inst{19-16} = 0b1111; // Rn
     let Inst{14-12} = 0b000; // imm3
     let Inst{7-6} = 0b00; // imm2
     let Inst{5-4} = 0b00; // type
   }
   // shifted register
   def s : T2sOneRegShiftedReg<(outs rGPR:$Rd), (ins t2_so_reg:$ShiftedRm), iis,
                opc, ".w\t$Rd, $ShiftedRm",
                [(set rGPR:$Rd, (opnode t2_so_reg:$ShiftedRm))]>,
                Sched<[WriteALU]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = opcod;
     let Inst{19-16} = 0b1111; // Rn
   }
}

// Prefer over of t2EORri ra, rb, -1 because mvn has 16-bit version
let AddedComplexity = 1 in
defm t2MVN  : T2I_un_irs <0b0011, "mvn",
                          IIC_iMVNi, IIC_iMVNr, IIC_iMVNsi,
                          UnOpFrag<(not node:$Src)>, 1, 1, 1>;

let AddedComplexity = 1 in
def : T2Pat<(and     rGPR:$src, t2_so_imm_not:$imm),
            (t2BICri rGPR:$src, t2_so_imm_not:$imm)>;

// top16Zero - answer true if the upper 16 bits of $src are 0, false otherwise
def top16Zero: PatLeaf<(i32 rGPR:$src), [{
  return CurDAG->MaskedValueIsZero(SDValue(N,0), APInt::getHighBitsSet(32, 16));
  }]>;

// so_imm_notSext is needed instead of so_imm_not, as the value of imm
// will match the extended, not the original bitWidth for $src.
def : T2Pat<(and top16Zero:$src, t2_so_imm_notSext:$imm),
            (t2BICri rGPR:$src, t2_so_imm_notSext:$imm)>;


// FIXME: Disable this pattern on Darwin to workaround an assembler bug.
def : T2Pat<(or      rGPR:$src, t2_so_imm_not:$imm),
            (t2ORNri rGPR:$src, t2_so_imm_not:$imm)>,
            Requires<[IsThumb2]>;

def : T2Pat<(t2_so_imm_not:$src),
            (t2MVNi t2_so_imm_not:$src)>;

//===----------------------------------------------------------------------===//
//  Multiply Instructions.
//
let isCommutable = 1 in
def t2MUL: T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL32,
                "mul", "\t$Rd, $Rn, $Rm",
                [(set rGPR:$Rd, (mul rGPR:$Rn, rGPR:$Rm))]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0110;
  let Inst{22-20} = 0b000;
  let Inst{15-12} = 0b1111; // Ra = 0b1111 (no accumulate)
  let Inst{7-4} = 0b0000; // Multiply
}

def t2MLA: T2FourReg<
                (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC32,
                "mla", "\t$Rd, $Rn, $Rm, $Ra",
                [(set rGPR:$Rd, (add (mul rGPR:$Rn, rGPR:$Rm), rGPR:$Ra))]>,
           Requires<[IsThumb2, UseMulOps]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0110;
  let Inst{22-20} = 0b000;
  let Inst{7-4} = 0b0000; // Multiply
}

def t2MLS: T2FourReg<
                (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC32,
                "mls", "\t$Rd, $Rn, $Rm, $Ra",
                [(set rGPR:$Rd, (sub rGPR:$Ra, (mul rGPR:$Rn, rGPR:$Rm)))]>,
           Requires<[IsThumb2, UseMulOps]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0110;
  let Inst{22-20} = 0b000;
  let Inst{7-4} = 0b0001; // Multiply and Subtract
}

// Extra precision multiplies with low / high results
let neverHasSideEffects = 1 in {
let isCommutable = 1 in {
def t2SMULL : T2MulLong<0b000, 0b0000,
                  (outs rGPR:$RdLo, rGPR:$RdHi),
                  (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL64,
                   "smull", "\t$RdLo, $RdHi, $Rn, $Rm", []>;

def t2UMULL : T2MulLong<0b010, 0b0000,
                  (outs rGPR:$RdLo, rGPR:$RdHi),
                  (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL64,
                   "umull", "\t$RdLo, $RdHi, $Rn, $Rm", []>;
} // isCommutable

// Multiply + accumulate
def t2SMLAL : T2MlaLong<0b100, 0b0000,
                  (outs rGPR:$RdLo, rGPR:$RdHi),
                  (ins rGPR:$Rn, rGPR:$Rm, rGPR:$RLo, rGPR:$RHi), IIC_iMAC64,
                  "smlal", "\t$RdLo, $RdHi, $Rn, $Rm", []>,
                  RegConstraint<"$RLo = $RdLo, $RHi = $RdHi">;

def t2UMLAL : T2MlaLong<0b110, 0b0000,
                  (outs rGPR:$RdLo, rGPR:$RdHi),
                  (ins rGPR:$Rn, rGPR:$Rm, rGPR:$RLo, rGPR:$RHi), IIC_iMAC64,
                  "umlal", "\t$RdLo, $RdHi, $Rn, $Rm", []>,
                  RegConstraint<"$RLo = $RdLo, $RHi = $RdHi">;

def t2UMAAL : T2MulLong<0b110, 0b0110,
                  (outs rGPR:$RdLo, rGPR:$RdHi),
                  (ins rGPR:$Rn, rGPR:$Rm), IIC_iMAC64,
                  "umaal", "\t$RdLo, $RdHi, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]>;
} // neverHasSideEffects

// Rounding variants of the below included for disassembly only

// Most significant word multiply
def t2SMMUL : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL32,
                  "smmul", "\t$Rd, $Rn, $Rm",
                  [(set rGPR:$Rd, (mulhs rGPR:$Rn, rGPR:$Rm))]>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0110;
  let Inst{22-20} = 0b101;
  let Inst{15-12} = 0b1111; // Ra = 0b1111 (no accumulate)
  let Inst{7-4} = 0b0000; // No Rounding (Inst{4} = 0)
}

def t2SMMULR : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL32,
                  "smmulr", "\t$Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0110;
  let Inst{22-20} = 0b101;
  let Inst{15-12} = 0b1111; // Ra = 0b1111 (no accumulate)
  let Inst{7-4} = 0b0001; // Rounding (Inst{4} = 1)
}

def t2SMMLA : T2FourReg<
        (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC32,
                "smmla", "\t$Rd, $Rn, $Rm, $Ra",
                [(set rGPR:$Rd, (add (mulhs rGPR:$Rm, rGPR:$Rn), rGPR:$Ra))]>,
              Requires<[IsThumb2, HasThumb2DSP, UseMulOps]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0110;
  let Inst{22-20} = 0b101;
  let Inst{7-4} = 0b0000; // No Rounding (Inst{4} = 0)
}

def t2SMMLAR: T2FourReg<
        (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC32,
                  "smmlar", "\t$Rd, $Rn, $Rm, $Ra", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0110;
  let Inst{22-20} = 0b101;
  let Inst{7-4} = 0b0001; // Rounding (Inst{4} = 1)
}

def t2SMMLS: T2FourReg<
        (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC32,
                "smmls", "\t$Rd, $Rn, $Rm, $Ra",
                [(set rGPR:$Rd, (sub rGPR:$Ra, (mulhs rGPR:$Rn, rGPR:$Rm)))]>,
             Requires<[IsThumb2, HasThumb2DSP, UseMulOps]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0110;
  let Inst{22-20} = 0b110;
  let Inst{7-4} = 0b0000; // No Rounding (Inst{4} = 0)
}

def t2SMMLSR:T2FourReg<
        (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC32,
                "smmlsr", "\t$Rd, $Rn, $Rm, $Ra", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-23} = 0b0110;
  let Inst{22-20} = 0b110;
  let Inst{7-4} = 0b0001; // Rounding (Inst{4} = 1)
}

multiclass T2I_smul<string opc, PatFrag opnode> {
  def BB : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL16,
              !strconcat(opc, "bb"), "\t$Rd, $Rn, $Rm",
              [(set rGPR:$Rd, (opnode (sext_inreg rGPR:$Rn, i16),
                                      (sext_inreg rGPR:$Rm, i16)))]>,
          Requires<[IsThumb2, HasThumb2DSP]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b001;
    let Inst{15-12} = 0b1111; // Ra = 0b1111 (no accumulate)
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b00;
  }

  def BT : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL16,
              !strconcat(opc, "bt"), "\t$Rd, $Rn, $Rm",
              [(set rGPR:$Rd, (opnode (sext_inreg rGPR:$Rn, i16),
                                      (sra rGPR:$Rm, (i32 16))))]>,
          Requires<[IsThumb2, HasThumb2DSP]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b001;
    let Inst{15-12} = 0b1111; // Ra = 0b1111 (no accumulate)
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b01;
  }

  def TB : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL16,
              !strconcat(opc, "tb"), "\t$Rd, $Rn, $Rm",
              [(set rGPR:$Rd, (opnode (sra rGPR:$Rn, (i32 16)),
                                      (sext_inreg rGPR:$Rm, i16)))]>,
          Requires<[IsThumb2, HasThumb2DSP]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b001;
    let Inst{15-12} = 0b1111; // Ra = 0b1111 (no accumulate)
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b10;
  }

  def TT : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL16,
              !strconcat(opc, "tt"), "\t$Rd, $Rn, $Rm",
              [(set rGPR:$Rd, (opnode (sra rGPR:$Rn, (i32 16)),
                                      (sra rGPR:$Rm, (i32 16))))]>,
          Requires<[IsThumb2, HasThumb2DSP]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b001;
    let Inst{15-12} = 0b1111; // Ra = 0b1111 (no accumulate)
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b11;
  }

  def WB : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL16,
              !strconcat(opc, "wb"), "\t$Rd, $Rn, $Rm",
              [(set rGPR:$Rd, (sra (opnode rGPR:$Rn,
                                    (sext_inreg rGPR:$Rm, i16)), (i32 16)))]>,
          Requires<[IsThumb2, HasThumb2DSP]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b011;
    let Inst{15-12} = 0b1111; // Ra = 0b1111 (no accumulate)
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b00;
  }

  def WT : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iMUL16,
              !strconcat(opc, "wt"), "\t$Rd, $Rn, $Rm",
              [(set rGPR:$Rd, (sra (opnode rGPR:$Rn,
                                    (sra rGPR:$Rm, (i32 16))), (i32 16)))]>,
          Requires<[IsThumb2, HasThumb2DSP]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b011;
    let Inst{15-12} = 0b1111; // Ra = 0b1111 (no accumulate)
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b01;
  }
}


multiclass T2I_smla<string opc, PatFrag opnode> {
  def BB : T2FourReg<
        (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC16,
              !strconcat(opc, "bb"), "\t$Rd, $Rn, $Rm, $Ra",
              [(set rGPR:$Rd, (add rGPR:$Ra,
                               (opnode (sext_inreg rGPR:$Rn, i16),
                                       (sext_inreg rGPR:$Rm, i16))))]>,
           Requires<[IsThumb2, HasThumb2DSP, UseMulOps]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b001;
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b00;
  }

  def BT : T2FourReg<
       (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC16,
             !strconcat(opc, "bt"), "\t$Rd, $Rn, $Rm, $Ra",
             [(set rGPR:$Rd, (add rGPR:$Ra, (opnode (sext_inreg rGPR:$Rn, i16),
                                                 (sra rGPR:$Rm, (i32 16)))))]>,
           Requires<[IsThumb2, HasThumb2DSP, UseMulOps]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b001;
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b01;
  }

  def TB : T2FourReg<
        (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC16,
              !strconcat(opc, "tb"), "\t$Rd, $Rn, $Rm, $Ra",
              [(set rGPR:$Rd, (add rGPR:$Ra, (opnode (sra rGPR:$Rn, (i32 16)),
                                               (sext_inreg rGPR:$Rm, i16))))]>,
           Requires<[IsThumb2, HasThumb2DSP, UseMulOps]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b001;
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b10;
  }

  def TT : T2FourReg<
        (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC16,
              !strconcat(opc, "tt"), "\t$Rd, $Rn, $Rm, $Ra",
             [(set rGPR:$Rd, (add rGPR:$Ra, (opnode (sra rGPR:$Rn, (i32 16)),
                                                 (sra rGPR:$Rm, (i32 16)))))]>,
           Requires<[IsThumb2, HasThumb2DSP, UseMulOps]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b001;
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b11;
  }

  def WB : T2FourReg<
        (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC16,
              !strconcat(opc, "wb"), "\t$Rd, $Rn, $Rm, $Ra",
              [(set rGPR:$Rd, (add rGPR:$Ra, (sra (opnode rGPR:$Rn,
                                    (sext_inreg rGPR:$Rm, i16)), (i32 16))))]>,
           Requires<[IsThumb2, HasThumb2DSP, UseMulOps]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b011;
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b00;
  }

  def WT : T2FourReg<
        (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC16,
              !strconcat(opc, "wt"), "\t$Rd, $Rn, $Rm, $Ra",
              [(set rGPR:$Rd, (add rGPR:$Ra, (sra (opnode rGPR:$Rn,
                                      (sra rGPR:$Rm, (i32 16))), (i32 16))))]>,
           Requires<[IsThumb2, HasThumb2DSP, UseMulOps]> {
    let Inst{31-27} = 0b11111;
    let Inst{26-23} = 0b0110;
    let Inst{22-20} = 0b011;
    let Inst{7-6} = 0b00;
    let Inst{5-4} = 0b01;
  }
}

defm t2SMUL : T2I_smul<"smul", BinOpFrag<(mul node:$LHS, node:$RHS)>>;
defm t2SMLA : T2I_smla<"smla", BinOpFrag<(mul node:$LHS, node:$RHS)>>;

// Halfword multiple accumulate long: SMLAL<x><y>
def t2SMLALBB : T2FourReg_mac<1, 0b100, 0b1000, (outs rGPR:$Ra,rGPR:$Rd),
         (ins rGPR:$Rn,rGPR:$Rm), IIC_iMAC64, "smlalbb", "\t$Ra, $Rd, $Rn, $Rm",
           [/* For disassembly only; pattern left blank */]>,
          Requires<[IsThumb2, HasThumb2DSP]>;
def t2SMLALBT : T2FourReg_mac<1, 0b100, 0b1001, (outs rGPR:$Ra,rGPR:$Rd),
         (ins rGPR:$Rn,rGPR:$Rm), IIC_iMAC64, "smlalbt", "\t$Ra, $Rd, $Rn, $Rm",
           [/* For disassembly only; pattern left blank */]>,
          Requires<[IsThumb2, HasThumb2DSP]>;
def t2SMLALTB : T2FourReg_mac<1, 0b100, 0b1010, (outs rGPR:$Ra,rGPR:$Rd),
         (ins rGPR:$Rn,rGPR:$Rm), IIC_iMAC64, "smlaltb", "\t$Ra, $Rd, $Rn, $Rm",
           [/* For disassembly only; pattern left blank */]>,
          Requires<[IsThumb2, HasThumb2DSP]>;
def t2SMLALTT : T2FourReg_mac<1, 0b100, 0b1011, (outs rGPR:$Ra,rGPR:$Rd),
         (ins rGPR:$Rn,rGPR:$Rm), IIC_iMAC64, "smlaltt", "\t$Ra, $Rd, $Rn, $Rm",
           [/* For disassembly only; pattern left blank */]>,
          Requires<[IsThumb2, HasThumb2DSP]>;

// Dual halfword multiple: SMUAD, SMUSD, SMLAD, SMLSD, SMLALD, SMLSLD
def t2SMUAD: T2ThreeReg_mac<
            0, 0b010, 0b0000, (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm),
            IIC_iMAC32, "smuad", "\t$Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{15-12} = 0b1111;
}
def t2SMUADX:T2ThreeReg_mac<
            0, 0b010, 0b0001, (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm),
            IIC_iMAC32, "smuadx", "\t$Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{15-12} = 0b1111;
}
def t2SMUSD: T2ThreeReg_mac<
            0, 0b100, 0b0000, (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm),
            IIC_iMAC32, "smusd", "\t$Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{15-12} = 0b1111;
}
def t2SMUSDX:T2ThreeReg_mac<
            0, 0b100, 0b0001, (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm),
            IIC_iMAC32, "smusdx", "\t$Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]> {
  let Inst{15-12} = 0b1111;
}
def t2SMLAD   : T2FourReg_mac<
            0, 0b010, 0b0000, (outs rGPR:$Rd),
            (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC32, "smlad",
            "\t$Rd, $Rn, $Rm, $Ra", []>,
          Requires<[IsThumb2, HasThumb2DSP]>;
def t2SMLADX  : T2FourReg_mac<
            0, 0b010, 0b0001, (outs rGPR:$Rd),
            (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC32, "smladx",
            "\t$Rd, $Rn, $Rm, $Ra", []>,
          Requires<[IsThumb2, HasThumb2DSP]>;
def t2SMLSD   : T2FourReg_mac<0, 0b100, 0b0000, (outs rGPR:$Rd),
            (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC32, "smlsd",
            "\t$Rd, $Rn, $Rm, $Ra", []>,
          Requires<[IsThumb2, HasThumb2DSP]>;
def t2SMLSDX  : T2FourReg_mac<0, 0b100, 0b0001, (outs rGPR:$Rd),
            (ins rGPR:$Rn, rGPR:$Rm, rGPR:$Ra), IIC_iMAC32, "smlsdx",
            "\t$Rd, $Rn, $Rm, $Ra", []>,
          Requires<[IsThumb2, HasThumb2DSP]>;
def t2SMLALD  : T2FourReg_mac<1, 0b100, 0b1100, (outs rGPR:$Ra,rGPR:$Rd),
                        (ins rGPR:$Rn, rGPR:$Rm), IIC_iMAC64, "smlald",
                        "\t$Ra, $Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]>;
def t2SMLALDX : T2FourReg_mac<1, 0b100, 0b1101, (outs rGPR:$Ra,rGPR:$Rd),
                        (ins rGPR:$Rn,rGPR:$Rm), IIC_iMAC64, "smlaldx",
                        "\t$Ra, $Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]>;
def t2SMLSLD  : T2FourReg_mac<1, 0b101, 0b1100, (outs rGPR:$Ra,rGPR:$Rd),
                        (ins rGPR:$Rn,rGPR:$Rm), IIC_iMAC64, "smlsld",
                        "\t$Ra, $Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]>;
def t2SMLSLDX : T2FourReg_mac<1, 0b101, 0b1101, (outs rGPR:$Ra,rGPR:$Rd),
                        (ins rGPR:$Rm,rGPR:$Rn), IIC_iMAC64, "smlsldx",
                        "\t$Ra, $Rd, $Rn, $Rm", []>,
          Requires<[IsThumb2, HasThumb2DSP]>;

//===----------------------------------------------------------------------===//
//  Division Instructions.
//  Signed and unsigned division on v7-M
//
def t2SDIV : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iDIV,
                 "sdiv", "\t$Rd, $Rn, $Rm",
                 [(set rGPR:$Rd, (sdiv rGPR:$Rn, rGPR:$Rm))]>,
                 Requires<[HasDivide, IsThumb2]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-21} = 0b011100;
  let Inst{20} = 0b1;
  let Inst{15-12} = 0b1111;
  let Inst{7-4} = 0b1111;
}

def t2UDIV : T2ThreeReg<(outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm), IIC_iDIV,
                 "udiv", "\t$Rd, $Rn, $Rm",
                 [(set rGPR:$Rd, (udiv rGPR:$Rn, rGPR:$Rm))]>,
                 Requires<[HasDivide, IsThumb2]> {
  let Inst{31-27} = 0b11111;
  let Inst{26-21} = 0b011101;
  let Inst{20} = 0b1;
  let Inst{15-12} = 0b1111;
  let Inst{7-4} = 0b1111;
}

//===----------------------------------------------------------------------===//
//  Misc. Arithmetic Instructions.
//

class T2I_misc<bits<2> op1, bits<2> op2, dag oops, dag iops,
      InstrItinClass itin, string opc, string asm, list<dag> pattern>
  : T2ThreeReg<oops, iops, itin, opc, asm, pattern> {
  let Inst{31-27} = 0b11111;
  let Inst{26-22} = 0b01010;
  let Inst{21-20} = op1;
  let Inst{15-12} = 0b1111;
  let Inst{7-6} = 0b10;
  let Inst{5-4} = op2;
  let Rn{3-0} = Rm;
}

def t2CLZ : T2I_misc<0b11, 0b00, (outs rGPR:$Rd), (ins rGPR:$Rm), IIC_iUNAr,
                    "clz", "\t$Rd, $Rm", [(set rGPR:$Rd, (ctlz rGPR:$Rm))]>,
                    Sched<[WriteALU]>;

def t2RBIT : T2I_misc<0b01, 0b10, (outs rGPR:$Rd), (ins rGPR:$Rm), IIC_iUNAr,
                      "rbit", "\t$Rd, $Rm",
                      [(set rGPR:$Rd, (ARMrbit rGPR:$Rm))]>,
                      Sched<[WriteALU]>;

def t2REV : T2I_misc<0b01, 0b00, (outs rGPR:$Rd), (ins rGPR:$Rm), IIC_iUNAr,
                 "rev", ".w\t$Rd, $Rm", [(set rGPR:$Rd, (bswap rGPR:$Rm))]>,
                 Sched<[WriteALU]>;

def t2REV16 : T2I_misc<0b01, 0b01, (outs rGPR:$Rd), (ins rGPR:$Rm), IIC_iUNAr,
                       "rev16", ".w\t$Rd, $Rm",
                [(set rGPR:$Rd, (rotr (bswap rGPR:$Rm), (i32 16)))]>,
                Sched<[WriteALU]>;

def t2REVSH : T2I_misc<0b01, 0b11, (outs rGPR:$Rd), (ins rGPR:$Rm), IIC_iUNAr,
                       "revsh", ".w\t$Rd, $Rm",
                 [(set rGPR:$Rd, (sra (bswap rGPR:$Rm), (i32 16)))]>,
                 Sched<[WriteALU]>;

def : T2Pat<(or (sra (shl rGPR:$Rm, (i32 24)), (i32 16)),
                (and (srl rGPR:$Rm, (i32 8)), 0xFF)),
            (t2REVSH rGPR:$Rm)>;

def t2PKHBT : T2ThreeReg<
            (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, pkh_lsl_amt:$sh),
                  IIC_iBITsi, "pkhbt", "\t$Rd, $Rn, $Rm$sh",
                  [(set rGPR:$Rd, (or (and rGPR:$Rn, 0xFFFF),
                                      (and (shl rGPR:$Rm, pkh_lsl_amt:$sh),
                                           0xFFFF0000)))]>,
                  Requires<[HasT2ExtractPack, IsThumb2]>,
                  Sched<[WriteALUsi, ReadALU]> {
  let Inst{31-27} = 0b11101;
  let Inst{26-25} = 0b01;
  let Inst{24-20} = 0b01100;
  let Inst{5} = 0; // BT form
  let Inst{4} = 0;

  bits<5> sh;
  let Inst{14-12} = sh{4-2};
  let Inst{7-6}   = sh{1-0};
}

// Alternate cases for PKHBT where identities eliminate some nodes.
def : T2Pat<(or (and rGPR:$src1, 0xFFFF), (and rGPR:$src2, 0xFFFF0000)),
            (t2PKHBT rGPR:$src1, rGPR:$src2, 0)>,
            Requires<[HasT2ExtractPack, IsThumb2]>;
def : T2Pat<(or (and rGPR:$src1, 0xFFFF), (shl rGPR:$src2, imm16_31:$sh)),
            (t2PKHBT rGPR:$src1, rGPR:$src2, imm16_31:$sh)>,
            Requires<[HasT2ExtractPack, IsThumb2]>;

// Note: Shifts of 1-15 bits will be transformed to srl instead of sra and
// will match the pattern below.
def t2PKHTB : T2ThreeReg<
                  (outs rGPR:$Rd), (ins rGPR:$Rn, rGPR:$Rm, pkh_asr_amt:$sh),
                  IIC_iBITsi, "pkhtb", "\t$Rd, $Rn, $Rm$sh",
                  [(set rGPR:$Rd, (or (and rGPR:$Rn, 0xFFFF0000),
                                       (and (sra rGPR:$Rm, pkh_asr_amt:$sh),
                                            0xFFFF)))]>,
                  Requires<[HasT2ExtractPack, IsThumb2]>,
                  Sched<[WriteALUsi, ReadALU]> {
  let Inst{31-27} = 0b11101;
  let Inst{26-25} = 0b01;
  let Inst{24-20} = 0b01100;
  let Inst{5} = 1; // TB form
  let Inst{4} = 0;

  bits<5> sh;
  let Inst{14-12} = sh{4-2};
  let Inst{7-6}   = sh{1-0};
}

// Alternate cases for PKHTB where identities eliminate some nodes.  Note that
// a shift amount of 0 is *not legal* here, it is PKHBT instead.
// We also can not replace a srl (17..31) by an arithmetic shift we would use in
// pkhtb src1, src2, asr (17..31).
def : T2Pat<(or (and rGPR:$src1, 0xFFFF0000), (srl rGPR:$src2, imm16:$sh)),
            (t2PKHTB rGPR:$src1, rGPR:$src2, imm16:$sh)>,
            Requires<[HasT2ExtractPack, IsThumb2]>;
def : T2Pat<(or (and rGPR:$src1, 0xFFFF0000), (sra rGPR:$src2, imm16_31:$sh)),
            (t2PKHTB rGPR:$src1, rGPR:$src2, imm16_31:$sh)>,
            Requires<[HasT2ExtractPack, IsThumb2]>;
def : T2Pat<(or (and rGPR:$src1, 0xFFFF0000),
                (and (srl rGPR:$src2, imm1_15:$sh), 0xFFFF)),
            (t2PKHTB rGPR:$src1, rGPR:$src2, imm1_15:$sh)>,
            Requires<[HasT2ExtractPack, IsThumb2]>;

//===----------------------------------------------------------------------===//
//  Comparison Instructions...
//
defm t2CMP  : T2I_cmp_irs<0b1101, "cmp",
                          IIC_iCMPi, IIC_iCMPr, IIC_iCMPsi,
                          BinOpFrag<(ARMcmp node:$LHS, node:$RHS)>>;

def : T2Pat<(ARMcmpZ  GPRnopc:$lhs, t2_so_imm:$imm),
            (t2CMPri  GPRnopc:$lhs, t2_so_imm:$imm)>;
def : T2Pat<(ARMcmpZ  GPRnopc:$lhs, rGPR:$rhs),
            (t2CMPrr  GPRnopc:$lhs, rGPR:$rhs)>;
def : T2Pat<(ARMcmpZ  GPRnopc:$lhs, t2_so_reg:$rhs),
            (t2CMPrs  GPRnopc:$lhs, t2_so_reg:$rhs)>;

let isCompare = 1, Defs = [CPSR] in {
   // shifted imm
   def t2CMNri : T2OneRegCmpImm<
                (outs), (ins GPRnopc:$Rn, t2_so_imm:$imm), IIC_iCMPi,
                "cmn", ".w\t$Rn, $imm",
                [(ARMcmn GPRnopc:$Rn, (ineg t2_so_imm:$imm))]>,
                Sched<[WriteCMP, ReadALU]> {
     let Inst{31-27} = 0b11110;
     let Inst{25} = 0;
     let Inst{24-21} = 0b1000;
     let Inst{20} = 1; // The S bit.
     let Inst{15} = 0;
     let Inst{11-8} = 0b1111; // Rd
   }
   // register
   def t2CMNzrr : T2TwoRegCmp<
                (outs), (ins GPRnopc:$Rn, rGPR:$Rm), IIC_iCMPr,
                "cmn", ".w\t$Rn, $Rm",
                [(BinOpFrag<(ARMcmpZ node:$LHS,(ineg node:$RHS))>
                  GPRnopc:$Rn, rGPR:$Rm)]>, Sched<[WriteCMP, ReadALU, ReadALU]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = 0b1000;
     let Inst{20} = 1; // The S bit.
     let Inst{14-12} = 0b000; // imm3
     let Inst{11-8} = 0b1111; // Rd
     let Inst{7-6} = 0b00; // imm2
     let Inst{5-4} = 0b00; // type
   }
   // shifted register
   def t2CMNzrs : T2OneRegCmpShiftedReg<
                (outs), (ins GPRnopc:$Rn, t2_so_reg:$ShiftedRm), IIC_iCMPsi,
                "cmn", ".w\t$Rn, $ShiftedRm",
                [(BinOpFrag<(ARMcmpZ node:$LHS,(ineg node:$RHS))>
                  GPRnopc:$Rn, t2_so_reg:$ShiftedRm)]>,
                  Sched<[WriteCMPsi, ReadALU, ReadALU]> {
     let Inst{31-27} = 0b11101;
     let Inst{26-25} = 0b01;
     let Inst{24-21} = 0b1000;
     let Inst{20} = 1; // The S bit.
     let Inst{11-8} = 0b1111; // Rd
   }
}

// Assembler aliases w/o the ".w" suffix.
// No alias here for 'rr' version as not all instantiations of this multiclass
// want one (CMP in particular, does not).
def : t2InstAlias<"cmn${p} $Rn, $imm",
   (t2CMNri GPRnopc:$Rn, t2_so_imm:$imm, pred:$p)>;
def : t2InstAlias<"cmn${p} $Rn, $shift",
   (t2CMNzrs GPRnopc:$Rn, t2_so_reg:$shift, pred:$p)>;

def : T2Pat<(ARMcmp  GPR:$src, t2_so_imm_neg:$imm),
            (t2CMNri GPR:$src, t2_so_imm_neg:$imm)>;

def : T2Pat<(ARMcmpZ GPRnopc:$src, t2_so_imm_neg:$imm),
            (t2CMNri GPRnopc:$src, t2_so_imm_neg:$imm)>;

defm t2TST  : T2I_cmp_irs<0b0000, "tst",
                          IIC_iTSTi, IIC_iTSTr, IIC_iTSTsi,
                         BinOpFrag<(ARMcmpZ (and_su node:$LHS, node:$RHS), 0)>>;
defm t2TEQ  : T2I_cmp_irs<0b0100, "teq",
                          IIC_iTSTi, IIC_iTSTr, IIC_iTSTsi,
                         BinOpFrag<(ARMcmpZ (xor_su node:$LHS, node:$RHS), 0)>>;

// Conditional moves
let neverHasSideEffects = 1 in {

let isCommutable = 1, isSelect = 1 in
def t2MOVCCr : t2PseudoInst<(outs rGPR:$Rd),
                            (ins rGPR:$false, rGPR:$Rm, cmovpred:$p),
                            4, IIC_iCMOVr,
                            [(set rGPR:$Rd, (ARMcmov rGPR:$false, rGPR:$Rm,
                                                     cmovpred:$p))]>,
               RegConstraint<"$false = $Rd">, Sched<[WriteALU]>;

let isMoveImm = 1 in
def t2MOVCCi
    : t2PseudoInst<(outs rGPR:$Rd),
                   (ins rGPR:$false, t2_so_imm:$imm, cmovpred:$p),
                   4, IIC_iCMOVi,
                   [(set rGPR:$Rd, (ARMcmov rGPR:$false,t2_so_imm:$imm,
                                            cmovpred:$p))]>,
      RegConstraint<"$false = $Rd">, Sched<[WriteALU]>;

let isCodeGenOnly = 1 in {
let isMoveImm = 1 in
def t2MOVCCi16
    : t2PseudoInst<(outs rGPR:$Rd),
                   (ins  rGPR:$false, imm0_65535_expr:$imm, cmovpred:$p),
                   4, IIC_iCMOVi,
                   [(set rGPR:$Rd, (ARMcmov rGPR:$false, imm0_65535:$imm,
                                            cmovpred:$p))]>,
      RegConstraint<"$false = $Rd">, Sched<[WriteALU]>;

let isMoveImm = 1 in
def t2MVNCCi
    : t2PseudoInst<(outs rGPR:$Rd),
                   (ins rGPR:$false, t2_so_imm:$imm, cmovpred:$p),
                   4, IIC_iCMOVi,
                   [(set rGPR:$Rd,
                         (ARMcmov rGPR:$false, t2_so_imm_not:$imm,
                                  cmovpred:$p))]>,
      RegConstraint<"$false = $Rd">, Sched<[WriteALU]>;

class MOVCCShPseudo<SDPatternOperator opnode, Operand ty>
    : t2PseudoInst<(outs rGPR:$Rd),
                   (ins rGPR:$false, rGPR:$Rm, i32imm:$imm, cmovpred:$p),
                   4, IIC_iCMOVsi,
                   [(set rGPR:$Rd, (ARMcmov rGPR:$false,
                                            (opnode rGPR:$Rm, (i32 ty:$imm)),
                                            cmovpred:$p))]>,
      RegConstraint<"$false = $Rd">, Sched<[WriteALU]>;

def t2MOVCClsl : MOVCCShPseudo<shl,  imm0_31>;
def t2MOVCClsr : MOVCCShPseudo<srl,  imm_sr>;
def t2MOVCCasr : MOVCCShPseudo<sra,  imm_sr>;
def t2MOVCCror : MOVCCShPseudo<rotr, imm0_31>;

let isMoveImm = 1 in
def t2MOVCCi32imm
    : t2PseudoInst<(outs rGPR:$dst),
                   (ins rGPR:$false, i32imm:$src, cmovpred:$p),
                   8, IIC_iCMOVix2,
                   [(set rGPR:$dst, (ARMcmov rGPR:$false, imm:$src,
                                             cmovpred:$p))]>,
      RegConstraint<"$false = $dst">;
} // isCodeGenOnly = 1

} // neverHasSideEffects

//===----------------------------------------------------------------------===//
// Atomic operations intrinsics
//

// memory barriers protect the atomic sequences
let hasSideEffects = 1 in {
def t2DMB : T2I<(outs), (ins memb_opt:$opt), NoItinerary,
                "dmb", "\t$opt", [(int_arm_dmb (i32 imm0_15:$opt))]>,
                Requires<[HasDB]> {
  bits<4> opt;
  let Inst{31-4} = 0xf3bf8f5;
  let Inst{3-0} = opt;
}
}

def t2DSB : T2I<(outs), (ins memb_opt:$opt), NoItinerary,
                "dsb", "\t$opt", [(int_arm_dsb (i32 imm0_15:$opt))]>,
                Requires<[HasDB]> {
  bits<4> opt;
  let Inst{31-4} = 0xf3bf8f4;
  let Inst{3-0} = opt;
}

def t2ISB : T2I<(outs), (ins instsyncb_opt:$opt), NoItinerary,
                "isb", "\t$opt", []>, Requires<[HasDB]> {
  bits<4> opt;
  let Inst{31-4} = 0xf3bf8f6;
  let Inst{3-0} = opt;
}

class T2I_ldrex<bits<4> opcod, dag oops, dag iops, AddrMode am, int sz,
                InstrItinClass itin, string opc, string asm, string cstr,
                list<dag> pattern, bits<4> rt2 = 0b1111>
  : Thumb2I<oops, iops, am, sz, itin, opc, asm, cstr, pattern> {
  let Inst{31-27} = 0b11101;
  let Inst{26-20} = 0b0001101;
  let Inst{11-8} = rt2;
  let Inst{7-4} = opcod;
  let Inst{3-0} = 0b1111;

  bits<4> addr;
  bits<4> Rt;
  let Inst{19-16} = addr;
  let Inst{15-12} = Rt;
}
class T2I_strex<bits<4> opcod, dag oops, dag iops, AddrMode am, int sz,
                InstrItinClass itin, string opc, string asm, string cstr,
                list<dag> pattern, bits<4> rt2 = 0b1111>
  : Thumb2I<oops, iops, am, sz, itin, opc, asm, cstr, pattern> {
  let Inst{31-27} = 0b11101;
  let Inst{26-20} = 0b0001100;
  let Inst{11-8} = rt2;
  let Inst{7-4} = opcod;

  bits<4> Rd;
  bits<4> addr;
  bits<4> Rt;
  let Inst{3-0}  = Rd;
  let Inst{19-16} = addr;
  let Inst{15-12} = Rt;
}

let mayLoad = 1 in {
def t2LDREXB : T2I_ldrex<0b0100, (outs rGPR:$Rt), (ins addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "ldrexb", "\t$Rt, $addr", "",
                         [(set rGPR:$Rt, (ldrex_1 addr_offset_none:$addr))]>;
def t2LDREXH : T2I_ldrex<0b0101, (outs rGPR:$Rt), (ins addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "ldrexh", "\t$Rt, $addr", "",
                         [(set rGPR:$Rt, (ldrex_2 addr_offset_none:$addr))]>;
def t2LDREX  : Thumb2I<(outs rGPR:$Rt), (ins t2addrmode_imm0_1020s4:$addr),
                       AddrModeNone, 4, NoItinerary,
                       "ldrex", "\t$Rt, $addr", "",
                     [(set rGPR:$Rt, (ldrex_4 t2addrmode_imm0_1020s4:$addr))]> {
  bits<4> Rt;
  bits<12> addr;
  let Inst{31-27} = 0b11101;
  let Inst{26-20} = 0b0000101;
  let Inst{19-16} = addr{11-8};
  let Inst{15-12} = Rt;
  let Inst{11-8} = 0b1111;
  let Inst{7-0} = addr{7-0};
}
let hasExtraDefRegAllocReq = 1 in
def t2LDREXD : T2I_ldrex<0b0111, (outs rGPR:$Rt, rGPR:$Rt2),
                         (ins addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "ldrexd", "\t$Rt, $Rt2, $addr", "",
                         [], {?, ?, ?, ?}> {
  bits<4> Rt2;
  let Inst{11-8} = Rt2;
}
def t2LDAEXB : T2I_ldrex<0b1100, (outs rGPR:$Rt), (ins addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "ldaexb", "\t$Rt, $addr", "",
                         []>, Requires<[IsThumb, HasV8]>;
def t2LDAEXH : T2I_ldrex<0b1101, (outs rGPR:$Rt), (ins addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "ldaexh", "\t$Rt, $addr", "",
                         []>, Requires<[IsThumb, HasV8]>;
def t2LDAEX  : Thumb2I<(outs rGPR:$Rt), (ins addr_offset_none:$addr),
                       AddrModeNone, 4, NoItinerary,
                       "ldaex", "\t$Rt, $addr", "",
                     []>, Requires<[IsThumb, HasV8]> {
  bits<4> Rt;
  bits<4> addr;
  let Inst{31-27} = 0b11101;
  let Inst{26-20} = 0b0001101;
  let Inst{19-16} = addr;
  let Inst{15-12} = Rt;
  let Inst{11-8} = 0b1111;
  let Inst{7-0} = 0b11101111;
}
let hasExtraDefRegAllocReq = 1 in
def t2LDAEXD : T2I_ldrex<0b1111, (outs rGPR:$Rt, rGPR:$Rt2),
                         (ins addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "ldaexd", "\t$Rt, $Rt2, $addr", "",
                         [], {?, ?, ?, ?}>, Requires<[IsThumb, HasV8]> {
  bits<4> Rt2;
  let Inst{11-8} = Rt2;

  let Inst{7} = 1;
}
}

let mayStore = 1, Constraints = "@earlyclobber $Rd" in {
def t2STREXB : T2I_strex<0b0100, (outs rGPR:$Rd),
                         (ins rGPR:$Rt, addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "strexb", "\t$Rd, $Rt, $addr", "",
                         [(set rGPR:$Rd, (strex_1 rGPR:$Rt,
                                                  addr_offset_none:$addr))]>;
def t2STREXH : T2I_strex<0b0101, (outs rGPR:$Rd),
                         (ins rGPR:$Rt, addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "strexh", "\t$Rd, $Rt, $addr", "",
                         [(set rGPR:$Rd, (strex_2 rGPR:$Rt,
                                                  addr_offset_none:$addr))]>;

def t2STREX  : Thumb2I<(outs rGPR:$Rd), (ins rGPR:$Rt,
                             t2addrmode_imm0_1020s4:$addr),
                  AddrModeNone, 4, NoItinerary,
                  "strex", "\t$Rd, $Rt, $addr", "",
                  [(set rGPR:$Rd, (strex_4 rGPR:$Rt,
                                           t2addrmode_imm0_1020s4:$addr))]> {
  bits<4> Rd;
  bits<4> Rt;
  bits<12> addr;
  let Inst{31-27} = 0b11101;
  let Inst{26-20} = 0b0000100;
  let Inst{19-16} = addr{11-8};
  let Inst{15-12} = Rt;
  let Inst{11-8}  = Rd;
  let Inst{7-0} = addr{7-0};
}
let hasExtraSrcRegAllocReq = 1 in
def t2STREXD : T2I_strex<0b0111, (outs rGPR:$Rd),
                         (ins rGPR:$Rt, rGPR:$Rt2, addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "strexd", "\t$Rd, $Rt, $Rt2, $addr", "", [],
                         {?, ?, ?, ?}> {
  bits<4> Rt2;
  let Inst{11-8} = Rt2;
}
def t2STLEXB : T2I_strex<0b1100, (outs rGPR:$Rd),
                         (ins rGPR:$Rt, addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "stlexb", "\t$Rd, $Rt, $addr", "",
                         []>, Requires<[IsThumb, HasV8]>;

def t2STLEXH : T2I_strex<0b1101, (outs rGPR:$Rd),
                         (ins rGPR:$Rt, addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "stlexh", "\t$Rd, $Rt, $addr", "",
                         []>, Requires<[IsThumb, HasV8]>;

def t2STLEX  : Thumb2I<(outs rGPR:$Rd), (ins rGPR:$Rt,
                             addr_offset_none:$addr),
                  AddrModeNone, 4, NoItinerary,
                  "stlex", "\t$Rd, $Rt, $addr", "",
                  []>, Requires<[IsThumb, HasV8]> {
  bits<4> Rd;
  bits<4> Rt;
  bits<4> addr;
  let Inst{31-27} = 0b11101;
  let Inst{26-20} = 0b0001100;
  let Inst{19-16} = addr;
  let Inst{15-12} = Rt;
  let Inst{11-4}  = 0b11111110;
  let Inst{3-0}   = Rd;
}
let hasExtraSrcRegAllocReq = 1 in
def t2STLEXD : T2I_strex<0b1111, (outs rGPR:$Rd),
                         (ins rGPR:$Rt, rGPR:$Rt2, addr_offset_none:$addr),
                         AddrModeNone, 4, NoItinerary,
                         "stlexd", "\t$Rd, $Rt, $Rt2, $addr", "", [],
                         {?, ?, ?, ?}>, Requires<[IsThumb, HasV8]> {
  bits<4> Rt2;
  let Inst{11-8} = Rt2;
}
}

def t2CLREX : T2I<(outs), (ins), NoItinerary, "clrex", "", [(int_arm_clrex)]>,
            Requires<[IsThumb2, HasV7]>  {
  let Inst{31-16} = 0xf3bf;
  let Inst{15-14} = 0b10;
  let Inst{13} = 0;
  let Inst{12} = 0;
  let Inst{11-8} = 0b1111;
  let Inst{7-4} = 0b0010;
  let Inst{3-0} = 0b1111;
}

def : T2Pat<(and (ldrex_1 addr_offset_none:$addr), 0xff),
            (t2LDREXB addr_offset_none:$addr)>;
def : T2Pat<(and (ldrex_2 addr_offset_none:$addr), 0xffff),
            (t2LDREXH addr_offset_none:$addr)>;
def : T2Pat<(strex_1 (and GPR:$Rt, 0xff), addr_offset_none:$addr),
            (t2STREXB GPR:$Rt, addr_offset_none:$addr)>;
def : T2Pat<(strex_2 (and GPR:$Rt, 0xffff), addr_offset_none:$addr),
            (t2STREXH GPR:$Rt, addr_offset_none:$addr)>;

//===----------------------------------------------------------------------===//
// SJLJ Exception handling intrinsics
//   eh_sjlj_setjmp() is an instruction sequence to store the return
//   address and save #0 in R0 for the non-longjmp case.
//   Since by its nature we may be coming from some other function to get
//   here, and we're using the stack frame for the containing function to
//   save/restore registers, we can't keep anything live in regs across
//   the eh_sjlj_setjmp(), else it will almost certainly have been tromped upon
//   when we get here from a longjmp(). We force everything out of registers
//   except for our own input by listing the relevant registers in Defs. By
//   doing so, we also cause the prologue/epilogue code to actively preserve
//   all of the callee-saved resgisters, which is exactly what we want.
//   $val is a scratch register for our use.
let Defs =
  [ R0,  R1,  R2,  R3,  R4,  R5,  R6,  R7,  R8,  R9,  R10, R11, R12, LR, CPSR,
    Q0, Q1, Q2, Q3, Q8, Q9, Q10, Q11, Q12, Q13, Q14, Q15],
  hasSideEffects = 1, isBarrier = 1, isCodeGenOnly = 1,
  usesCustomInserter = 1 in {
  def t2Int_eh_sjlj_setjmp : Thumb2XI<(outs), (ins tGPR:$src, tGPR:$val),
                               AddrModeNone, 0, NoItinerary, "", "",
                          [(set R0, (ARMeh_sjlj_setjmp tGPR:$src, tGPR:$val))]>,
                             Requires<[IsThumb2, HasVFP2]>;
}

let Defs =
  [ R0,  R1,  R2,  R3,  R4,  R5,  R6,  R7,  R8,  R9,  R10, R11, R12, LR, CPSR ],
  hasSideEffects = 1, isBarrier = 1, isCodeGenOnly = 1,
  usesCustomInserter = 1 in {
  def t2Int_eh_sjlj_setjmp_nofp : Thumb2XI<(outs), (ins tGPR:$src, tGPR:$val),
                               AddrModeNone, 0, NoItinerary, "", "",
                          [(set R0, (ARMeh_sjlj_setjmp tGPR:$src, tGPR:$val))]>,
                                  Requires<[IsThumb2, NoVFP]>;
}


//===----------------------------------------------------------------------===//
// Control-Flow Instructions
//

// FIXME: remove when we have a way to marking a MI with these properties.
// FIXME: Should pc be an implicit operand like PICADD, etc?
let isReturn = 1, isTerminator = 1, isBarrier = 1, mayLoad = 1,
    hasExtraDefRegAllocReq = 1, isCodeGenOnly = 1 in
def t2LDMIA_RET: t2PseudoExpand<(outs GPR:$wb), (ins GPR:$Rn, pred:$p,
                                                   reglist:$regs, variable_ops),
                              4, IIC_iLoad_mBr, [],
            (t2LDMIA_UPD GPR:$wb, GPR:$Rn, pred:$p, reglist:$regs)>,
                         RegConstraint<"$Rn = $wb">;

let isBranch = 1, isTerminator = 1, isBarrier = 1 in {
let isPredicable = 1 in
def t2B   : T2I<(outs), (ins uncondbrtarget:$target), IIC_Br,
                 "b", ".w\t$target",
                 [(br bb:$target)]>, Sched<[WriteBr]> {
  let Inst{31-27} = 0b11110;
  let Inst{15-14} = 0b10;
  let Inst{12} = 1;

  bits<24> target;
  let Inst{26} = target{23};
  let Inst{13} = target{22};
  let Inst{11} = target{21};
  let Inst{25-16} = target{20-11};
  let Inst{10-0} = target{10-0};
  let DecoderMethod = "DecodeT2BInstruction";
  let AsmMatchConverter = "cvtThumbBranches"; 
} 

let isNotDuplicable = 1, isIndirectBranch = 1 in {
def t2BR_JT : t2PseudoInst<(outs),
          (ins GPR:$target, GPR:$index, i32imm:$jt, i32imm:$id),
           0, IIC_Br,
          [(ARMbr2jt GPR:$target, GPR:$index, tjumptable:$jt, imm:$id)]>,
          Sched<[WriteBr]>;

// FIXME: Add a non-pc based case that can be predicated.
def t2TBB_JT : t2PseudoInst<(outs),
        (ins GPR:$index, i32imm:$jt, i32imm:$id), 0, IIC_Br, []>,
        Sched<[WriteBr]>;

def t2TBH_JT : t2PseudoInst<(outs),
        (ins GPR:$index, i32imm:$jt, i32imm:$id), 0, IIC_Br, []>,
        Sched<[WriteBr]>;

def t2TBB : T2I<(outs), (ins addrmode_tbb:$addr), IIC_Br,
                    "tbb", "\t$addr", []>, Sched<[WriteBrTbl]> {
  bits<4> Rn;
  bits<4> Rm;
  let Inst{31-20} = 0b111010001101;
  let Inst{19-16} = Rn;
  let Inst{15-5} = 0b11110000000;
  let Inst{4} = 0; // B form
  let Inst{3-0} = Rm;

  let DecoderMethod = "DecodeThumbTableBranch";
}

def t2TBH : T2I<(outs), (ins addrmode_tbh:$addr), IIC_Br,
                   "tbh", "\t$addr", []>, Sched<[WriteBrTbl]> {
  bits<4> Rn;
  bits<4> Rm;
  let Inst{31-20} = 0b111010001101;
  let Inst{19-16} = Rn;
  let Inst{15-5} = 0b11110000000;
  let Inst{4} = 1; // H form
  let Inst{3-0} = Rm;

  let DecoderMethod = "DecodeThumbTableBranch";
}
} // isNotDuplicable, isIndirectBranch

} // isBranch, isTerminator, isBarrier

// FIXME: should be able to write a pattern for ARMBrcond, but can't use
// a two-value operand where a dag node expects ", "two operands. :(
let isBranch = 1, isTerminator = 1 in
def t2Bcc : T2I<(outs), (ins brtarget:$target), IIC_Br,
                "b", ".w\t$target",
                [/*(ARMbrcond bb:$target, imm:$cc)*/]>, Sched<[WriteBr]> {
  let Inst{31-27} = 0b11110;
  let Inst{15-14} = 0b10;
  let Inst{12} = 0;

  bits<4> p;
  let Inst{25-22} = p;

  bits<21> target;
  let Inst{26} = target{20};
  let Inst{11} = target{19};
  let Inst{13} = target{18};
  let Inst{21-16} = target{17-12};
  let Inst{10-0} = target{11-1};

  let DecoderMethod = "DecodeThumb2BCCInstruction";
  let AsmMatchConverter = "cvtThumbBranches";
}

// Tail calls. The IOS version of thumb tail calls uses a t2 branch, so
// it goes here.
let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1 in {
  // IOS version.
  let Uses = [SP] in
  def tTAILJMPd: tPseudoExpand<(outs),
                   (ins uncondbrtarget:$dst, pred:$p),
                   4, IIC_Br, [],
                   (t2B uncondbrtarget:$dst, pred:$p)>,
                 Requires<[IsThumb2, IsIOS]>, Sched<[WriteBr]>;
}

// IT block
let Defs = [ITSTATE] in
def t2IT : Thumb2XI<(outs), (ins it_pred:$cc, it_mask:$mask),
                    AddrModeNone, 2,  IIC_iALUx,
                    "it$mask\t$cc", "", []> {
  // 16-bit instruction.
  let Inst{31-16} = 0x0000;
  let Inst{15-8} = 0b10111111;

  bits<4> cc;
  bits<4> mask;
  let Inst{7-4} = cc;
  let Inst{3-0} = mask;

  let DecoderMethod = "DecodeIT";
}

// Branch and Exchange Jazelle -- for disassembly only
// Rm = Inst{19-16}
def t2BXJ : T2I<(outs), (ins rGPR:$func), NoItinerary, "bxj", "\t$func", []>,
    Sched<[WriteBr]> {
  bits<4> func;
  let Inst{31-27} = 0b11110;
  let Inst{26} = 0;
  let Inst{25-20} = 0b111100;
  let Inst{19-16} = func;
  let Inst{15-0} = 0b1000111100000000;
}

// Compare and branch on zero / non-zero
let isBranch = 1, isTerminator = 1 in {
  def tCBZ  : T1I<(outs), (ins tGPR:$Rn, t_cbtarget:$target), IIC_Br,
                  "cbz\t$Rn, $target", []>,
              T1Misc<{0,0,?,1,?,?,?}>,
              Requires<[IsThumb2]>, Sched<[WriteBr]> {
    // A8.6.27
    bits<6> target;
    bits<3> Rn;
    let Inst{9}   = target{5};
    let Inst{7-3} = target{4-0};
    let Inst{2-0} = Rn;
  }

  def tCBNZ : T1I<(outs), (ins tGPR:$Rn, t_cbtarget:$target), IIC_Br,
                  "cbnz\t$Rn, $target", []>,
              T1Misc<{1,0,?,1,?,?,?}>,
              Requires<[IsThumb2]>, Sched<[WriteBr]> {
    // A8.6.27
    bits<6> target;
    bits<3> Rn;
    let Inst{9}   = target{5};
    let Inst{7-3} = target{4-0};
    let Inst{2-0} = Rn;
  }
}


// Change Processor State is a system instruction.
// FIXME: Since the asm parser has currently no clean way to handle optional
// operands, create 3 versions of the same instruction. Once there's a clean
// framework to represent optional operands, change this behavior.
class t2CPS<dag iops, string asm_op> : T2XI<(outs), iops, NoItinerary,
            !strconcat("cps", asm_op), []> {
  bits<2> imod;
  bits<3> iflags;
  bits<5> mode;
  bit M;

  let Inst{31-11} = 0b111100111010111110000;
  let Inst{10-9}  = imod;
  let Inst{8}     = M;
  let Inst{7-5}   = iflags;
  let Inst{4-0}   = mode;
  let DecoderMethod = "DecodeT2CPSInstruction";
}

let M = 1 in
  def t2CPS3p : t2CPS<(ins imod_op:$imod, iflags_op:$iflags, i32imm:$mode),
                      "$imod\t$iflags, $mode">;
let mode = 0, M = 0 in
  def t2CPS2p : t2CPS<(ins imod_op:$imod, iflags_op:$iflags),
                      "$imod.w\t$iflags">;
let imod = 0, iflags = 0, M = 1 in
  def t2CPS1p : t2CPS<(ins imm0_31:$mode), "\t$mode">;

def : t2InstAlias<"cps$imod.w $iflags, $mode",
                   (t2CPS3p imod_op:$imod, iflags_op:$iflags, i32imm:$mode), 0>;
def : t2InstAlias<"cps.w $mode", (t2CPS1p imm0_31:$mode), 0>;

// A6.3.4 Branches and miscellaneous control
// Table A6-14 Change Processor State, and hint instructions
def t2HINT : T2I<(outs), (ins imm0_4:$imm), NoItinerary, "hint", "\t$imm",[]> {
  bits<3> imm;
  let Inst{31-3} = 0b11110011101011111000000000000;
  let Inst{2-0} = imm;
}

def : t2InstAlias<"hint$p.w $imm", (t2HINT imm0_4:$imm, pred:$p)>;
def : t2InstAlias<"nop$p.w", (t2HINT 0, pred:$p)>;
def : t2InstAlias<"yield$p.w", (t2HINT 1, pred:$p)>;
def : t2InstAlias<"wfe$p.w", (t2HINT 2, pred:$p)>;
def : t2InstAlias<"wfi$p.w", (t2HINT 3, pred:$p)>;
def : t2InstAlias<"sev$p.w", (t2HINT 4, pred:$p)>;

def t2DBG : T2I<(outs), (ins imm0_15:$opt), NoItinerary, "dbg", "\t$opt", []> {
  bits<4> opt;
  let Inst{31-20} = 0b111100111010;
  let Inst{19-16} = 0b1111;
  let Inst{15-8} = 0b10000000;
  let Inst{7-4} = 0b1111;
  let Inst{3-0} = opt;
}

// Secure Monitor Call is a system instruction.
// Option = Inst{19-16}
def t2SMC : T2I<(outs), (ins imm0_15:$opt), NoItinerary, "smc", "\t$opt", 
                []>, Requires<[IsThumb2, HasTrustZone]> {
  let Inst{31-27} = 0b11110;
  let Inst{26-20} = 0b1111111;
  let Inst{15-12} = 0b1000;

  bits<4> opt;
  let Inst{19-16} = opt;
}

class T2DCPS<bits<2> opt, string opc>
  : T2I<(outs), (ins), NoItinerary, opc, "", []>, Requires<[IsThumb2, HasV8]> {
  let Inst{31-27} = 0b11110;
  let Inst{26-20} = 0b1111000;
  let Inst{19-16} = 0b1111;
  let Inst{15-12} = 0b1000;
  let Inst{11-2} = 0b0000000000;
  let Inst{1-0} = opt;
}

def t2DCPS1 : T2DCPS<0b01, "dcps1">;
def t2DCPS2 : T2DCPS<0b10, "dcps2">;
def t2DCPS3 : T2DCPS<0b11, "dcps3">;

class T2SRS<bits<2> Op, bit W, dag oops, dag iops, InstrItinClass itin,
            string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  bits<5> mode;
  let Inst{31-25} = 0b1110100;
  let Inst{24-23} = Op;
  let Inst{22} = 0;
  let Inst{21} = W;
  let Inst{20-16} = 0b01101;
  let Inst{15-5} = 0b11000000000;
  let Inst{4-0} = mode{4-0};
}

// Store Return State is a system instruction.
def t2SRSDB_UPD : T2SRS<0b00, 1, (outs), (ins imm0_31:$mode), NoItinerary,
                        "srsdb", "\tsp!, $mode", []>;
def t2SRSDB  : T2SRS<0b00, 0, (outs), (ins imm0_31:$mode), NoItinerary,
                     "srsdb","\tsp, $mode", []>;
def t2SRSIA_UPD : T2SRS<0b11, 1, (outs), (ins imm0_31:$mode), NoItinerary,
                        "srsia","\tsp!, $mode", []>;
def t2SRSIA  : T2SRS<0b11, 0, (outs), (ins imm0_31:$mode), NoItinerary,
                     "srsia","\tsp, $mode", []>;


def : t2InstAlias<"srsdb${p} $mode", (t2SRSDB imm0_31:$mode, pred:$p)>;
def : t2InstAlias<"srsdb${p} $mode!", (t2SRSDB_UPD imm0_31:$mode, pred:$p)>;

def : t2InstAlias<"srsia${p} $mode", (t2SRSIA imm0_31:$mode, pred:$p)>;
def : t2InstAlias<"srsia${p} $mode!", (t2SRSIA_UPD imm0_31:$mode, pred:$p)>;

// Return From Exception is a system instruction.
class T2RFE<bits<12> op31_20, dag oops, dag iops, InstrItinClass itin,
          string opc, string asm, list<dag> pattern>
  : T2I<oops, iops, itin, opc, asm, pattern> {
  let Inst{31-20} = op31_20{11-0};

  bits<4> Rn;
  let Inst{19-16} = Rn;
  let Inst{15-0} = 0xc000;
}

def t2RFEDBW : T2RFE<0b111010000011,
                   (outs), (ins GPR:$Rn), NoItinerary, "rfedb", "\t$Rn!",
                   [/* For disassembly only; pattern left blank */]>;
def t2RFEDB  : T2RFE<0b111010000001,
                   (outs), (ins GPR:$Rn), NoItinerary, "rfedb", "\t$Rn",
                   [/* For disassembly only; pattern left blank */]>;
def t2RFEIAW : T2RFE<0b111010011011,
                   (outs), (ins GPR:$Rn), NoItinerary, "rfeia", "\t$Rn!",
                   [/* For disassembly only; pattern left blank */]>;
def t2RFEIA  : T2RFE<0b111010011001,
                   (outs), (ins GPR:$Rn), NoItinerary, "rfeia", "\t$Rn",
                   [/* For disassembly only; pattern left blank */]>;

// B9.3.19 SUBS PC, LR, #imm (Thumb2) system instruction.
let Defs = [PC], Uses = [LR] in
def t2SUBS_PC_LR : T2I <(outs), (ins imm0_255:$imm), NoItinerary,
                   "subs", "\tpc, lr, $imm", []>, Requires<[IsThumb2]> {
  let Inst{31-8} = 0b111100111101111010001111;

  bits<8> imm;
  let Inst{7-0} = imm;
}

//===----------------------------------------------------------------------===//
// Non-Instruction Patterns
//

// 32-bit immediate using movw + movt.
// This is a single pseudo instruction to make it re-materializable.
// FIXME: Remove this when we can do generalized remat.
let isReMaterializable = 1, isMoveImm = 1 in
def t2MOVi32imm : PseudoInst<(outs rGPR:$dst), (ins i32imm:$src), IIC_iMOVix2,
                            [(set rGPR:$dst, (i32 imm:$src))]>,
                            Requires<[IsThumb, HasV6T2]>;

// Pseudo instruction that combines movw + movt + add pc (if pic).
// It also makes it possible to rematerialize the instructions.
// FIXME: Remove this when we can do generalized remat and when machine licm
// can properly the instructions.
let isReMaterializable = 1 in {
def t2MOV_ga_pcrel : PseudoInst<(outs rGPR:$dst), (ins i32imm:$addr),
                                IIC_iMOVix2addpc,
                          [(set rGPR:$dst, (ARMWrapperPIC tglobaladdr:$addr))]>,
                          Requires<[IsThumb2, UseMovt]>;

def t2MOV_ga_dyn : PseudoInst<(outs rGPR:$dst), (ins i32imm:$addr),
                              IIC_iMOVix2,
                          [(set rGPR:$dst, (ARMWrapperDYN tglobaladdr:$addr))]>,
                          Requires<[IsThumb2, UseMovt]>;
}

// ConstantPool, GlobalAddress, and JumpTable
def : T2Pat<(ARMWrapper  tglobaladdr :$dst), (t2LEApcrel tglobaladdr :$dst)>,
           Requires<[IsThumb2, DontUseMovt]>;
def : T2Pat<(ARMWrapper  tconstpool  :$dst), (t2LEApcrel tconstpool  :$dst)>;
def : T2Pat<(ARMWrapper  tglobaladdr :$dst), (t2MOVi32imm tglobaladdr :$dst)>,
           Requires<[IsThumb2, UseMovt]>;

def : T2Pat<(ARMWrapperJT tjumptable:$dst, imm:$id),
            (t2LEApcrelJT tjumptable:$dst, imm:$id)>;

// Pseudo instruction that combines ldr from constpool and add pc. This should
// be expanded into two instructions late to allow if-conversion and
// scheduling.
let canFoldAsLoad = 1, isReMaterializable = 1 in
def t2LDRpci_pic : PseudoInst<(outs rGPR:$dst), (ins i32imm:$addr, pclabel:$cp),
                   IIC_iLoadiALU,
              [(set rGPR:$dst, (ARMpic_add (load (ARMWrapper tconstpool:$addr)),
                                           imm:$cp))]>,
               Requires<[IsThumb2]>;

// Pseudo isntruction that combines movs + predicated rsbmi
// to implement integer ABS
let usesCustomInserter = 1, Defs = [CPSR] in {
def t2ABS : PseudoInst<(outs rGPR:$dst), (ins rGPR:$src),
                       NoItinerary, []>, Requires<[IsThumb2]>;
}

//===----------------------------------------------------------------------===//
// Coprocessor load/store -- for disassembly only
//
class T2CI<bits<4> op31_28, dag oops, dag iops, string opc, string asm>
  : T2I<oops, iops, NoItinerary, opc, asm, []> {
  let Inst{31-28} = op31_28;
  let Inst{27-25} = 0b110;
}

multiclass t2LdStCop<bits<4> op31_28, bit load, bit Dbit, string asm> {
  def _OFFSET : T2CI<op31_28,
                     (outs), (ins p_imm:$cop, c_imm:$CRd, addrmode5:$addr),
                     asm, "\t$cop, $CRd, $addr"> {
    bits<13> addr;
    bits<4> cop;
    bits<4> CRd;
    let Inst{24} = 1; // P = 1
    let Inst{23} = addr{8};
    let Inst{22} = Dbit;
    let Inst{21} = 0; // W = 0
    let Inst{20} = load;
    let Inst{19-16} = addr{12-9};
    let Inst{15-12} = CRd;
    let Inst{11-8} = cop;
    let Inst{7-0} = addr{7-0};
    let DecoderMethod = "DecodeCopMemInstruction";
  }
  def _PRE : T2CI<op31_28,
                  (outs), (ins p_imm:$cop, c_imm:$CRd, addrmode5_pre:$addr),
                  asm, "\t$cop, $CRd, $addr!"> {
    bits<13> addr;
    bits<4> cop;
    bits<4> CRd;
    let Inst{24} = 1; // P = 1
    let Inst{23} = addr{8};
    let Inst{22} = Dbit;
    let Inst{21} = 1; // W = 1
    let Inst{20} = load;
    let Inst{19-16} = addr{12-9};
    let Inst{15-12} = CRd;
    let Inst{11-8} = cop;
    let Inst{7-0} = addr{7-0};
    let DecoderMethod = "DecodeCopMemInstruction";
  }
  def _POST: T2CI<op31_28,
                  (outs), (ins p_imm:$cop, c_imm:$CRd, addr_offset_none:$addr,
                               postidx_imm8s4:$offset),
                 asm, "\t$cop, $CRd, $addr, $offset"> {
    bits<9> offset;
    bits<4> addr;
    bits<4> cop;
    bits<4> CRd;
    let Inst{24} = 0; // P = 0
    let Inst{23} = offset{8};
    let Inst{22} = Dbit;
    let Inst{21} = 1; // W = 1
    let Inst{20} = load;
    let Inst{19-16} = addr;
    let Inst{15-12} = CRd;
    let Inst{11-8} = cop;
    let Inst{7-0} = offset{7-0};
    let DecoderMethod = "DecodeCopMemInstruction";
  }
  def _OPTION : T2CI<op31_28, (outs),
                     (ins p_imm:$cop, c_imm:$CRd, addr_offset_none:$addr,
                          coproc_option_imm:$option),
      asm, "\t$cop, $CRd, $addr, $option"> {
    bits<8> option;
    bits<4> addr;
    bits<4> cop;
    bits<4> CRd;
    let Inst{24} = 0; // P = 0
    let Inst{23} = 1; // U = 1
    let Inst{22} = Dbit;
    let Inst{21} = 0; // W = 0
    let Inst{20} = load;
    let Inst{19-16} = addr;
    let Inst{15-12} = CRd;
    let Inst{11-8} = cop;
    let Inst{7-0} = option;
    let DecoderMethod = "DecodeCopMemInstruction";
  }
}

defm t2LDC   : t2LdStCop<0b1110, 1, 0, "ldc">;
defm t2LDCL  : t2LdStCop<0b1110, 1, 1, "ldcl">;
defm t2STC   : t2LdStCop<0b1110, 0, 0, "stc">;
defm t2STCL  : t2LdStCop<0b1110, 0, 1, "stcl">;
defm t2LDC2  : t2LdStCop<0b1111, 1, 0, "ldc2">;
defm t2LDC2L : t2LdStCop<0b1111, 1, 1, "ldc2l">;
defm t2STC2  : t2LdStCop<0b1111, 0, 0, "stc2">;
defm t2STC2L : t2LdStCop<0b1111, 0, 1, "stc2l">;


//===----------------------------------------------------------------------===//
// Move between special register and ARM core register -- for disassembly only
//
// Move to ARM core register from Special Register

// A/R class MRS.
//
// A/R class can only move from CPSR or SPSR.
def t2MRS_AR : T2I<(outs GPR:$Rd), (ins), NoItinerary, "mrs", "\t$Rd, apsr",
                  []>, Requires<[IsThumb2,IsARClass]> {
  bits<4> Rd;
  let Inst{31-12} = 0b11110011111011111000;
  let Inst{11-8} = Rd;
  let Inst{7-0} = 0b0000;
}

def : t2InstAlias<"mrs${p} $Rd, cpsr", (t2MRS_AR GPR:$Rd, pred:$p)>;

def t2MRSsys_AR: T2I<(outs GPR:$Rd), (ins), NoItinerary, "mrs", "\t$Rd, spsr",
                   []>, Requires<[IsThumb2,IsARClass]> {
  bits<4> Rd;
  let Inst{31-12} = 0b11110011111111111000;
  let Inst{11-8} = Rd;
  let Inst{7-0} = 0b0000;
}

// M class MRS.
//
// This MRS has a mask field in bits 7-0 and can take more values than
// the A/R class (a full msr_mask).
def t2MRS_M : T2I<(outs rGPR:$Rd), (ins msr_mask:$mask), NoItinerary,
                  "mrs", "\t$Rd, $mask", []>,
              Requires<[IsThumb,IsMClass]> {
  bits<4> Rd;
  bits<8> mask;
  let Inst{31-12} = 0b11110011111011111000;
  let Inst{11-8} = Rd;
  let Inst{19-16} = 0b1111;
  let Inst{7-0} = mask;
}


// Move from ARM core register to Special Register
//
// A/R class MSR.
//
// No need to have both system and application versions, the encodings are the
// same and the assembly parser has no way to distinguish between them. The mask
// operand contains the special register (R Bit) in bit 4 and bits 3-0 contains
// the mask with the fields to be accessed in the special register.
def t2MSR_AR : T2I<(outs), (ins msr_mask:$mask, rGPR:$Rn),
                   NoItinerary, "msr", "\t$mask, $Rn", []>,
               Requires<[IsThumb2,IsARClass]> {
  bits<5> mask;
  bits<4> Rn;
  let Inst{31-21} = 0b11110011100;
  let Inst{20}    = mask{4}; // R Bit
  let Inst{19-16} = Rn;
  let Inst{15-12} = 0b1000;
  let Inst{11-8}  = mask{3-0};
  let Inst{7-0}   = 0;
}

// M class MSR.
//
// Move from ARM core register to Special Register
def t2MSR_M : T2I<(outs), (ins msr_mask:$SYSm, rGPR:$Rn),
                  NoItinerary, "msr", "\t$SYSm, $Rn", []>,
              Requires<[IsThumb,IsMClass]> {
  bits<12> SYSm;
  bits<4> Rn;
  let Inst{31-21} = 0b11110011100;
  let Inst{20}    = 0b0;
  let Inst{19-16} = Rn;
  let Inst{15-12} = 0b1000;
  let Inst{11-0}  = SYSm;
}


//===----------------------------------------------------------------------===//
// Move between coprocessor and ARM core register
//

class t2MovRCopro<bits<4> Op, string opc, bit direction, dag oops, dag iops,
                  list<dag> pattern>
  : T2Cop<Op, oops, iops, opc, "\t$cop, $opc1, $Rt, $CRn, $CRm, $opc2",
          pattern> {
  let Inst{27-24} = 0b1110;
  let Inst{20} = direction;
  let Inst{4} = 1;

  bits<4> Rt;
  bits<4> cop;
  bits<3> opc1;
  bits<3> opc2;
  bits<4> CRm;
  bits<4> CRn;

  let Inst{15-12} = Rt;
  let Inst{11-8}  = cop;
  let Inst{23-21} = opc1;
  let Inst{7-5}   = opc2;
  let Inst{3-0}   = CRm;
  let Inst{19-16} = CRn;
}

class t2MovRRCopro<bits<4> Op, string opc, bit direction,
                   list<dag> pattern = []>
  : T2Cop<Op, (outs),
          (ins p_imm:$cop, imm0_15:$opc1, GPR:$Rt, GPR:$Rt2, c_imm:$CRm),
          opc, "\t$cop, $opc1, $Rt, $Rt2, $CRm", pattern> {
  let Inst{27-24} = 0b1100;
  let Inst{23-21} = 0b010;
  let Inst{20} = direction;

  bits<4> Rt;
  bits<4> Rt2;
  bits<4> cop;
  bits<4> opc1;
  bits<4> CRm;

  let Inst{15-12} = Rt;
  let Inst{19-16} = Rt2;
  let Inst{11-8}  = cop;
  let Inst{7-4}   = opc1;
  let Inst{3-0}   = CRm;
}

/* from ARM core register to coprocessor */
def t2MCR : t2MovRCopro<0b1110, "mcr", 0,
           (outs),
           (ins p_imm:$cop, imm0_7:$opc1, GPR:$Rt, c_imm:$CRn,
                c_imm:$CRm, imm0_7:$opc2),
           [(int_arm_mcr imm:$cop, imm:$opc1, GPR:$Rt, imm:$CRn,
                         imm:$CRm, imm:$opc2)]>,
           ComplexDeprecationPredicate<"MCR">;
def : t2InstAlias<"mcr${p} $cop, $opc1, $Rt, $CRn, $CRm",
                  (t2MCR p_imm:$cop, imm0_7:$opc1, GPR:$Rt, c_imm:$CRn,
                         c_imm:$CRm, 0, pred:$p)>;
def t2MCR2 : t2MovRCopro<0b1111, "mcr2", 0,
             (outs), (ins p_imm:$cop, imm0_7:$opc1, GPR:$Rt, c_imm:$CRn,
                          c_imm:$CRm, imm0_7:$opc2),
             [(int_arm_mcr2 imm:$cop, imm:$opc1, GPR:$Rt, imm:$CRn,
                            imm:$CRm, imm:$opc2)]>;
def : t2InstAlias<"mcr2${p} $cop, $opc1, $Rt, $CRn, $CRm",
                  (t2MCR2 p_imm:$cop, imm0_7:$opc1, GPR:$Rt, c_imm:$CRn,
                          c_imm:$CRm, 0, pred:$p)>;

/* from coprocessor to ARM core register */
def t2MRC : t2MovRCopro<0b1110, "mrc", 1,
             (outs GPRwithAPSR:$Rt), (ins p_imm:$cop, imm0_7:$opc1, c_imm:$CRn,
                                  c_imm:$CRm, imm0_7:$opc2), []>;
def : t2InstAlias<"mrc${p} $cop, $opc1, $Rt, $CRn, $CRm",
                  (t2MRC GPRwithAPSR:$Rt, p_imm:$cop, imm0_7:$opc1, c_imm:$CRn,
                         c_imm:$CRm, 0, pred:$p)>;

def t2MRC2 : t2MovRCopro<0b1111, "mrc2", 1,
             (outs GPRwithAPSR:$Rt), (ins p_imm:$cop, imm0_7:$opc1, c_imm:$CRn,
                                  c_imm:$CRm, imm0_7:$opc2), []>;
def : t2InstAlias<"mrc2${p} $cop, $opc1, $Rt, $CRn, $CRm",
                  (t2MRC2 GPRwithAPSR:$Rt, p_imm:$cop, imm0_7:$opc1, c_imm:$CRn,
                          c_imm:$CRm, 0, pred:$p)>;

def : T2v6Pat<(int_arm_mrc  imm:$cop, imm:$opc1, imm:$CRn, imm:$CRm, imm:$opc2),
              (t2MRC imm:$cop, imm:$opc1, imm:$CRn, imm:$CRm, imm:$opc2)>;

def : T2v6Pat<(int_arm_mrc2 imm:$cop, imm:$opc1, imm:$CRn, imm:$CRm, imm:$opc2),
              (t2MRC2 imm:$cop, imm:$opc1, imm:$CRn, imm:$CRm, imm:$opc2)>;


/* from ARM core register to coprocessor */
def t2MCRR : t2MovRRCopro<0b1110, "mcrr", 0,
                        [(int_arm_mcrr imm:$cop, imm:$opc1, GPR:$Rt, GPR:$Rt2,
                                       imm:$CRm)]>;
def t2MCRR2 : t2MovRRCopro<0b1111, "mcrr2", 0,
                           [(int_arm_mcrr2 imm:$cop, imm:$opc1, GPR:$Rt,
                                           GPR:$Rt2, imm:$CRm)]>;
/* from coprocessor to ARM core register */
def t2MRRC : t2MovRRCopro<0b1110, "mrrc", 1>;

def t2MRRC2 : t2MovRRCopro<0b1111, "mrrc2", 1>;

//===----------------------------------------------------------------------===//
// Other Coprocessor Instructions.
//

def t2CDP : T2Cop<0b1110, (outs), (ins p_imm:$cop, imm0_15:$opc1,
                 c_imm:$CRd, c_imm:$CRn, c_imm:$CRm, imm0_7:$opc2),
                 "cdp", "\t$cop, $opc1, $CRd, $CRn, $CRm, $opc2",
                 [(int_arm_cdp imm:$cop, imm:$opc1, imm:$CRd, imm:$CRn,
                               imm:$CRm, imm:$opc2)]> {
  let Inst{27-24} = 0b1110;

  bits<4> opc1;
  bits<4> CRn;
  bits<4> CRd;
  bits<4> cop;
  bits<3> opc2;
  bits<4> CRm;

  let Inst{3-0}   = CRm;
  let Inst{4}     = 0;
  let Inst{7-5}   = opc2;
  let Inst{11-8}  = cop;
  let Inst{15-12} = CRd;
  let Inst{19-16} = CRn;
  let Inst{23-20} = opc1;
}

def t2CDP2 : T2Cop<0b1111, (outs), (ins p_imm:$cop, imm0_15:$opc1,
                   c_imm:$CRd, c_imm:$CRn, c_imm:$CRm, imm0_7:$opc2),
                   "cdp2", "\t$cop, $opc1, $CRd, $CRn, $CRm, $opc2",
                   [(int_arm_cdp2 imm:$cop, imm:$opc1, imm:$CRd, imm:$CRn,
                                  imm:$CRm, imm:$opc2)]> {
  let Inst{27-24} = 0b1110;

  bits<4> opc1;
  bits<4> CRn;
  bits<4> CRd;
  bits<4> cop;
  bits<3> opc2;
  bits<4> CRm;

  let Inst{3-0}   = CRm;
  let Inst{4}     = 0;
  let Inst{7-5}   = opc2;
  let Inst{11-8}  = cop;
  let Inst{15-12} = CRd;
  let Inst{19-16} = CRn;
  let Inst{23-20} = opc1;
}



//===----------------------------------------------------------------------===//
// Non-Instruction Patterns
//

// SXT/UXT with no rotate
let AddedComplexity = 16 in {
def : T2Pat<(and rGPR:$Rm, 0x000000FF), (t2UXTB rGPR:$Rm, 0)>,
           Requires<[IsThumb2]>;
def : T2Pat<(and rGPR:$Rm, 0x0000FFFF), (t2UXTH rGPR:$Rm, 0)>,
           Requires<[IsThumb2]>;
def : T2Pat<(and rGPR:$Rm, 0x00FF00FF), (t2UXTB16 rGPR:$Rm, 0)>,
           Requires<[HasT2ExtractPack, IsThumb2]>;
def : T2Pat<(add rGPR:$Rn, (and rGPR:$Rm, 0x00FF)),
            (t2UXTAB rGPR:$Rn, rGPR:$Rm, 0)>,
           Requires<[HasT2ExtractPack, IsThumb2]>;
def : T2Pat<(add rGPR:$Rn, (and rGPR:$Rm, 0xFFFF)),
            (t2UXTAH rGPR:$Rn, rGPR:$Rm, 0)>,
           Requires<[HasT2ExtractPack, IsThumb2]>;
}

def : T2Pat<(sext_inreg rGPR:$Src, i8),  (t2SXTB rGPR:$Src, 0)>,
           Requires<[IsThumb2]>;
def : T2Pat<(sext_inreg rGPR:$Src, i16), (t2SXTH rGPR:$Src, 0)>,
           Requires<[IsThumb2]>;
def : T2Pat<(add rGPR:$Rn, (sext_inreg rGPR:$Rm, i8)),
            (t2SXTAB rGPR:$Rn, rGPR:$Rm, 0)>,
           Requires<[HasT2ExtractPack, IsThumb2]>;
def : T2Pat<(add rGPR:$Rn, (sext_inreg rGPR:$Rm, i16)),
            (t2SXTAH rGPR:$Rn, rGPR:$Rm, 0)>,
           Requires<[HasT2ExtractPack, IsThumb2]>;

// Atomic load/store patterns
def : T2Pat<(atomic_load_8   t2addrmode_imm12:$addr),
            (t2LDRBi12  t2addrmode_imm12:$addr)>;
def : T2Pat<(atomic_load_8   t2addrmode_negimm8:$addr),
            (t2LDRBi8   t2addrmode_negimm8:$addr)>;
def : T2Pat<(atomic_load_8   t2addrmode_so_reg:$addr),
            (t2LDRBs    t2addrmode_so_reg:$addr)>;
def : T2Pat<(atomic_load_16  t2addrmode_imm12:$addr),
            (t2LDRHi12  t2addrmode_imm12:$addr)>;
def : T2Pat<(atomic_load_16  t2addrmode_negimm8:$addr),
            (t2LDRHi8   t2addrmode_negimm8:$addr)>;
def : T2Pat<(atomic_load_16  t2addrmode_so_reg:$addr),
            (t2LDRHs    t2addrmode_so_reg:$addr)>;
def : T2Pat<(atomic_load_32  t2addrmode_imm12:$addr),
            (t2LDRi12   t2addrmode_imm12:$addr)>;
def : T2Pat<(atomic_load_32  t2addrmode_negimm8:$addr),
            (t2LDRi8    t2addrmode_negimm8:$addr)>;
def : T2Pat<(atomic_load_32  t2addrmode_so_reg:$addr),
            (t2LDRs     t2addrmode_so_reg:$addr)>;
def : T2Pat<(atomic_store_8  t2addrmode_imm12:$addr, GPR:$val),
            (t2STRBi12  GPR:$val, t2addrmode_imm12:$addr)>;
def : T2Pat<(atomic_store_8  t2addrmode_negimm8:$addr, GPR:$val),
            (t2STRBi8   GPR:$val, t2addrmode_negimm8:$addr)>;
def : T2Pat<(atomic_store_8  t2addrmode_so_reg:$addr, GPR:$val),
            (t2STRBs    GPR:$val, t2addrmode_so_reg:$addr)>;
def : T2Pat<(atomic_store_16 t2addrmode_imm12:$addr, GPR:$val),
            (t2STRHi12  GPR:$val, t2addrmode_imm12:$addr)>;
def : T2Pat<(atomic_store_16 t2addrmode_negimm8:$addr, GPR:$val),
            (t2STRHi8   GPR:$val, t2addrmode_negimm8:$addr)>;
def : T2Pat<(atomic_store_16 t2addrmode_so_reg:$addr, GPR:$val),
            (t2STRHs    GPR:$val, t2addrmode_so_reg:$addr)>;
def : T2Pat<(atomic_store_32 t2addrmode_imm12:$addr, GPR:$val),
            (t2STRi12   GPR:$val, t2addrmode_imm12:$addr)>;
def : T2Pat<(atomic_store_32 t2addrmode_negimm8:$addr, GPR:$val),
            (t2STRi8    GPR:$val, t2addrmode_negimm8:$addr)>;
def : T2Pat<(atomic_store_32 t2addrmode_so_reg:$addr, GPR:$val),
            (t2STRs     GPR:$val, t2addrmode_so_reg:$addr)>;


//===----------------------------------------------------------------------===//
// Assembler aliases
//

// Aliases for ADC without the ".w" optional width specifier.
def : t2InstAlias<"adc${s}${p} $Rd, $Rn, $Rm",
                  (t2ADCrr rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"adc${s}${p} $Rd, $Rn, $ShiftedRm",
                  (t2ADCrs rGPR:$Rd, rGPR:$Rn, t2_so_reg:$ShiftedRm,
                           pred:$p, cc_out:$s)>;

// Aliases for SBC without the ".w" optional width specifier.
def : t2InstAlias<"sbc${s}${p} $Rd, $Rn, $Rm",
                  (t2SBCrr rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"sbc${s}${p} $Rd, $Rn, $ShiftedRm",
                  (t2SBCrs rGPR:$Rd, rGPR:$Rn, t2_so_reg:$ShiftedRm,
                           pred:$p, cc_out:$s)>;

// Aliases for ADD without the ".w" optional width specifier.
def : t2InstAlias<"add${s}${p} $Rd, $Rn, $imm",
        (t2ADDri GPRnopc:$Rd, GPRnopc:$Rn, t2_so_imm:$imm, pred:$p, 
         cc_out:$s)>;
def : t2InstAlias<"add${p} $Rd, $Rn, $imm",
           (t2ADDri12 GPRnopc:$Rd, GPR:$Rn, imm0_4095:$imm, pred:$p)>;
def : t2InstAlias<"add${s}${p} $Rd, $Rn, $Rm",
              (t2ADDrr GPRnopc:$Rd, GPRnopc:$Rn, rGPR:$Rm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"add${s}${p} $Rd, $Rn, $ShiftedRm",
                  (t2ADDrs GPRnopc:$Rd, GPRnopc:$Rn, t2_so_reg:$ShiftedRm,
                           pred:$p, cc_out:$s)>;
// ... and with the destination and source register combined.
def : t2InstAlias<"add${s}${p} $Rdn, $imm",
      (t2ADDri GPRnopc:$Rdn, GPRnopc:$Rdn, t2_so_imm:$imm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"add${p} $Rdn, $imm",
           (t2ADDri12 GPRnopc:$Rdn, GPRnopc:$Rdn, imm0_4095:$imm, pred:$p)>;
def : t2InstAlias<"add${s}${p} $Rdn, $Rm",
            (t2ADDrr GPRnopc:$Rdn, GPRnopc:$Rdn, rGPR:$Rm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"add${s}${p} $Rdn, $ShiftedRm",
                  (t2ADDrs GPRnopc:$Rdn, GPRnopc:$Rdn, t2_so_reg:$ShiftedRm,
                           pred:$p, cc_out:$s)>;

// add w/ negative immediates is just a sub.
def : t2InstAlias<"add${s}${p} $Rd, $Rn, $imm",
        (t2SUBri GPRnopc:$Rd, GPRnopc:$Rn, t2_so_imm_neg:$imm, pred:$p,
                 cc_out:$s)>;
def : t2InstAlias<"add${p} $Rd, $Rn, $imm",
           (t2SUBri12 GPRnopc:$Rd, GPR:$Rn, imm0_4095_neg:$imm, pred:$p)>;
def : t2InstAlias<"add${s}${p} $Rdn, $imm",
      (t2SUBri GPRnopc:$Rdn, GPRnopc:$Rdn, t2_so_imm_neg:$imm, pred:$p,
               cc_out:$s)>;
def : t2InstAlias<"add${p} $Rdn, $imm",
           (t2SUBri12 GPRnopc:$Rdn, GPRnopc:$Rdn, imm0_4095_neg:$imm, pred:$p)>;

def : t2InstAlias<"add${s}${p}.w $Rd, $Rn, $imm",
        (t2SUBri GPRnopc:$Rd, GPRnopc:$Rn, t2_so_imm_neg:$imm, pred:$p,
                 cc_out:$s)>;
def : t2InstAlias<"addw${p} $Rd, $Rn, $imm",
           (t2SUBri12 GPRnopc:$Rd, GPR:$Rn, imm0_4095_neg:$imm, pred:$p)>;
def : t2InstAlias<"add${s}${p}.w $Rdn, $imm",
      (t2SUBri GPRnopc:$Rdn, GPRnopc:$Rdn, t2_so_imm_neg:$imm, pred:$p,
               cc_out:$s)>;
def : t2InstAlias<"addw${p} $Rdn, $imm",
           (t2SUBri12 GPRnopc:$Rdn, GPRnopc:$Rdn, imm0_4095_neg:$imm, pred:$p)>;


// Aliases for SUB without the ".w" optional width specifier.
def : t2InstAlias<"sub${s}${p} $Rd, $Rn, $imm",
        (t2SUBri GPRnopc:$Rd, GPRnopc:$Rn, t2_so_imm:$imm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"sub${p} $Rd, $Rn, $imm",
           (t2SUBri12 GPRnopc:$Rd, GPR:$Rn, imm0_4095:$imm, pred:$p)>;
def : t2InstAlias<"sub${s}${p} $Rd, $Rn, $Rm",
              (t2SUBrr GPRnopc:$Rd, GPRnopc:$Rn, rGPR:$Rm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"sub${s}${p} $Rd, $Rn, $ShiftedRm",
                  (t2SUBrs GPRnopc:$Rd, GPRnopc:$Rn, t2_so_reg:$ShiftedRm,
                           pred:$p, cc_out:$s)>;
// ... and with the destination and source register combined.
def : t2InstAlias<"sub${s}${p} $Rdn, $imm",
      (t2SUBri GPRnopc:$Rdn, GPRnopc:$Rdn, t2_so_imm:$imm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"sub${p} $Rdn, $imm",
           (t2SUBri12 GPRnopc:$Rdn, GPRnopc:$Rdn, imm0_4095:$imm, pred:$p)>;
def : t2InstAlias<"sub${s}${p}.w $Rdn, $Rm",
            (t2SUBrr GPRnopc:$Rdn, GPRnopc:$Rdn, rGPR:$Rm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"sub${s}${p} $Rdn, $Rm",
            (t2SUBrr GPRnopc:$Rdn, GPRnopc:$Rdn, rGPR:$Rm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"sub${s}${p} $Rdn, $ShiftedRm",
                  (t2SUBrs GPRnopc:$Rdn, GPRnopc:$Rdn, t2_so_reg:$ShiftedRm,
                           pred:$p, cc_out:$s)>;

// Alias for compares without the ".w" optional width specifier.
def : t2InstAlias<"cmn${p} $Rn, $Rm",
                  (t2CMNzrr GPRnopc:$Rn, rGPR:$Rm, pred:$p)>;
def : t2InstAlias<"teq${p} $Rn, $Rm",
                  (t2TEQrr GPRnopc:$Rn, rGPR:$Rm, pred:$p)>;
def : t2InstAlias<"tst${p} $Rn, $Rm",
                  (t2TSTrr GPRnopc:$Rn, rGPR:$Rm, pred:$p)>;

// Memory barriers
def : InstAlias<"dmb${p}", (t2DMB 0xf, pred:$p)>, Requires<[IsThumb2, HasDB]>;
def : InstAlias<"dsb${p}", (t2DSB 0xf, pred:$p)>, Requires<[IsThumb2, HasDB]>;
def : InstAlias<"isb${p}", (t2ISB 0xf, pred:$p)>, Requires<[IsThumb2, HasDB]>;

// Alias for LDR, LDRB, LDRH, LDRSB, and LDRSH without the ".w" optional
// width specifier.
def : t2InstAlias<"ldr${p} $Rt, $addr",
                  (t2LDRi12 GPR:$Rt, t2addrmode_imm12:$addr, pred:$p)>;
def : t2InstAlias<"ldrb${p} $Rt, $addr",
                  (t2LDRBi12 rGPR:$Rt, t2addrmode_imm12:$addr, pred:$p)>;
def : t2InstAlias<"ldrh${p} $Rt, $addr",
                  (t2LDRHi12 rGPR:$Rt, t2addrmode_imm12:$addr, pred:$p)>;
def : t2InstAlias<"ldrsb${p} $Rt, $addr",
                  (t2LDRSBi12 rGPR:$Rt, t2addrmode_imm12:$addr, pred:$p)>;
def : t2InstAlias<"ldrsh${p} $Rt, $addr",
                  (t2LDRSHi12 rGPR:$Rt, t2addrmode_imm12:$addr, pred:$p)>;

def : t2InstAlias<"ldr${p} $Rt, $addr",
                  (t2LDRs GPR:$Rt, t2addrmode_so_reg:$addr, pred:$p)>;
def : t2InstAlias<"ldrb${p} $Rt, $addr",
                  (t2LDRBs rGPR:$Rt, t2addrmode_so_reg:$addr, pred:$p)>;
def : t2InstAlias<"ldrh${p} $Rt, $addr",
                  (t2LDRHs rGPR:$Rt, t2addrmode_so_reg:$addr, pred:$p)>;
def : t2InstAlias<"ldrsb${p} $Rt, $addr",
                  (t2LDRSBs rGPR:$Rt, t2addrmode_so_reg:$addr, pred:$p)>;
def : t2InstAlias<"ldrsh${p} $Rt, $addr",
                  (t2LDRSHs rGPR:$Rt, t2addrmode_so_reg:$addr, pred:$p)>;

def : t2InstAlias<"ldr${p} $Rt, $addr",
                  (t2LDRpci rGPR:$Rt, t2ldrlabel:$addr, pred:$p)>;
def : t2InstAlias<"ldrb${p} $Rt, $addr",
                  (t2LDRBpci rGPR:$Rt, t2ldrlabel:$addr, pred:$p)>;
def : t2InstAlias<"ldrh${p} $Rt, $addr",
                  (t2LDRHpci rGPR:$Rt, t2ldrlabel:$addr, pred:$p)>;
def : t2InstAlias<"ldrsb${p} $Rt, $addr",
                  (t2LDRSBpci rGPR:$Rt, t2ldrlabel:$addr, pred:$p)>;
def : t2InstAlias<"ldrsh${p} $Rt, $addr",
                  (t2LDRSHpci rGPR:$Rt, t2ldrlabel:$addr, pred:$p)>;

// Alias for MVN with(out) the ".w" optional width specifier.
def : t2InstAlias<"mvn${s}${p}.w $Rd, $imm",
           (t2MVNi rGPR:$Rd, t2_so_imm:$imm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"mvn${s}${p} $Rd, $Rm",
           (t2MVNr rGPR:$Rd, rGPR:$Rm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"mvn${s}${p} $Rd, $ShiftedRm",
           (t2MVNs rGPR:$Rd, t2_so_reg:$ShiftedRm, pred:$p, cc_out:$s)>;

// PKHBT/PKHTB with default shift amount. PKHTB is equivalent to PKHBT when the
// shift amount is zero (i.e., unspecified).
def : InstAlias<"pkhbt${p} $Rd, $Rn, $Rm",
                (t2PKHBT rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, 0, pred:$p)>,
            Requires<[HasT2ExtractPack, IsThumb2]>;
def : InstAlias<"pkhtb${p} $Rd, $Rn, $Rm",
                (t2PKHBT rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, 0, pred:$p)>,
            Requires<[HasT2ExtractPack, IsThumb2]>;

// PUSH/POP aliases for STM/LDM
def : t2InstAlias<"push${p}.w $regs", (t2STMDB_UPD SP, pred:$p, reglist:$regs)>;
def : t2InstAlias<"push${p} $regs", (t2STMDB_UPD SP, pred:$p, reglist:$regs)>;
def : t2InstAlias<"pop${p}.w $regs", (t2LDMIA_UPD SP, pred:$p, reglist:$regs)>;
def : t2InstAlias<"pop${p} $regs", (t2LDMIA_UPD SP, pred:$p, reglist:$regs)>;

// STMIA/STMIA_UPD aliases w/o the optional .w suffix
def : t2InstAlias<"stm${p} $Rn, $regs",
                  (t2STMIA GPR:$Rn, pred:$p, reglist:$regs)>;
def : t2InstAlias<"stm${p} $Rn!, $regs",
                  (t2STMIA_UPD GPR:$Rn, pred:$p, reglist:$regs)>;

// LDMIA/LDMIA_UPD aliases w/o the optional .w suffix
def : t2InstAlias<"ldm${p} $Rn, $regs",
                  (t2LDMIA GPR:$Rn, pred:$p, reglist:$regs)>;
def : t2InstAlias<"ldm${p} $Rn!, $regs",
                  (t2LDMIA_UPD GPR:$Rn, pred:$p, reglist:$regs)>;

// STMDB/STMDB_UPD aliases w/ the optional .w suffix
def : t2InstAlias<"stmdb${p}.w $Rn, $regs",
                  (t2STMDB GPR:$Rn, pred:$p, reglist:$regs)>;
def : t2InstAlias<"stmdb${p}.w $Rn!, $regs",
                  (t2STMDB_UPD GPR:$Rn, pred:$p, reglist:$regs)>;

// LDMDB/LDMDB_UPD aliases w/ the optional .w suffix
def : t2InstAlias<"ldmdb${p}.w $Rn, $regs",
                  (t2LDMDB GPR:$Rn, pred:$p, reglist:$regs)>;
def : t2InstAlias<"ldmdb${p}.w $Rn!, $regs",
                  (t2LDMDB_UPD GPR:$Rn, pred:$p, reglist:$regs)>;

// Alias for REV/REV16/REVSH without the ".w" optional width specifier.
def : t2InstAlias<"rev${p} $Rd, $Rm", (t2REV rGPR:$Rd, rGPR:$Rm, pred:$p)>;
def : t2InstAlias<"rev16${p} $Rd, $Rm", (t2REV16 rGPR:$Rd, rGPR:$Rm, pred:$p)>;
def : t2InstAlias<"revsh${p} $Rd, $Rm", (t2REVSH rGPR:$Rd, rGPR:$Rm, pred:$p)>;


// Alias for RSB without the ".w" optional width specifier, and with optional
// implied destination register.
def : t2InstAlias<"rsb${s}${p} $Rd, $Rn, $imm",
           (t2RSBri rGPR:$Rd, rGPR:$Rn, t2_so_imm:$imm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"rsb${s}${p} $Rdn, $imm",
           (t2RSBri rGPR:$Rdn, rGPR:$Rdn, t2_so_imm:$imm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"rsb${s}${p} $Rdn, $Rm",
           (t2RSBrr rGPR:$Rdn, rGPR:$Rdn, rGPR:$Rm, pred:$p, cc_out:$s)>;
def : t2InstAlias<"rsb${s}${p} $Rdn, $ShiftedRm",
           (t2RSBrs rGPR:$Rdn, rGPR:$Rdn, t2_so_reg:$ShiftedRm, pred:$p,
                    cc_out:$s)>;

// SSAT/USAT optional shift operand.
def : t2InstAlias<"ssat${p} $Rd, $sat_imm, $Rn",
                  (t2SSAT rGPR:$Rd, imm1_32:$sat_imm, rGPR:$Rn, 0, pred:$p)>;
def : t2InstAlias<"usat${p} $Rd, $sat_imm, $Rn",
                  (t2USAT rGPR:$Rd, imm0_31:$sat_imm, rGPR:$Rn, 0, pred:$p)>;

// STM w/o the .w suffix.
def : t2InstAlias<"stm${p} $Rn, $regs",
                  (t2STMIA GPR:$Rn, pred:$p, reglist:$regs)>;

// Alias for STR, STRB, and STRH without the ".w" optional
// width specifier.
def : t2InstAlias<"str${p} $Rt, $addr",
                  (t2STRi12 GPR:$Rt, t2addrmode_imm12:$addr, pred:$p)>;
def : t2InstAlias<"strb${p} $Rt, $addr",
                  (t2STRBi12 rGPR:$Rt, t2addrmode_imm12:$addr, pred:$p)>;
def : t2InstAlias<"strh${p} $Rt, $addr",
                  (t2STRHi12 rGPR:$Rt, t2addrmode_imm12:$addr, pred:$p)>;

def : t2InstAlias<"str${p} $Rt, $addr",
                  (t2STRs GPR:$Rt, t2addrmode_so_reg:$addr, pred:$p)>;
def : t2InstAlias<"strb${p} $Rt, $addr",
                  (t2STRBs rGPR:$Rt, t2addrmode_so_reg:$addr, pred:$p)>;
def : t2InstAlias<"strh${p} $Rt, $addr",
                  (t2STRHs rGPR:$Rt, t2addrmode_so_reg:$addr, pred:$p)>;

// Extend instruction optional rotate operand.
def : t2InstAlias<"sxtab${p} $Rd, $Rn, $Rm",
                (t2SXTAB rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"sxtah${p} $Rd, $Rn, $Rm",
                (t2SXTAH rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"sxtab16${p} $Rd, $Rn, $Rm",
                (t2SXTAB16 rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, 0, pred:$p)>;

def : t2InstAlias<"sxtb${p} $Rd, $Rm",
                (t2SXTB rGPR:$Rd, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"sxtb16${p} $Rd, $Rm",
                (t2SXTB16 rGPR:$Rd, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"sxth${p} $Rd, $Rm",
                (t2SXTH rGPR:$Rd, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"sxtb${p}.w $Rd, $Rm",
                (t2SXTB rGPR:$Rd, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"sxth${p}.w $Rd, $Rm",
                (t2SXTH rGPR:$Rd, rGPR:$Rm, 0, pred:$p)>;

def : t2InstAlias<"uxtab${p} $Rd, $Rn, $Rm",
                (t2UXTAB rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"uxtah${p} $Rd, $Rn, $Rm",
                (t2UXTAH rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"uxtab16${p} $Rd, $Rn, $Rm",
                (t2UXTAB16 rGPR:$Rd, rGPR:$Rn, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"uxtb${p} $Rd, $Rm",
                (t2UXTB rGPR:$Rd, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"uxtb16${p} $Rd, $Rm",
                (t2UXTB16 rGPR:$Rd, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"uxth${p} $Rd, $Rm",
                (t2UXTH rGPR:$Rd, rGPR:$Rm, 0, pred:$p)>;

def : t2InstAlias<"uxtb${p}.w $Rd, $Rm",
                (t2UXTB rGPR:$Rd, rGPR:$Rm, 0, pred:$p)>;
def : t2InstAlias<"uxth${p}.w $Rd, $Rm",
                (t2UXTH rGPR:$Rd, rGPR:$Rm, 0, pred:$p)>;

// Extend instruction w/o the ".w" optional width specifier.
def : t2InstAlias<"uxtb${p} $Rd, $Rm$rot",
                  (t2UXTB rGPR:$Rd, rGPR:$Rm, rot_imm:$rot, pred:$p)>;
def : t2InstAlias<"uxtb16${p} $Rd, $Rm$rot",
                  (t2UXTB16 rGPR:$Rd, rGPR:$Rm, rot_imm:$rot, pred:$p)>;
def : t2InstAlias<"uxth${p} $Rd, $Rm$rot",
                  (t2UXTH rGPR:$Rd, rGPR:$Rm, rot_imm:$rot, pred:$p)>;

def : t2InstAlias<"sxtb${p} $Rd, $Rm$rot",
                  (t2SXTB rGPR:$Rd, rGPR:$Rm, rot_imm:$rot, pred:$p)>;
def : t2InstAlias<"sxtb16${p} $Rd, $Rm$rot",
                  (t2SXTB16 rGPR:$Rd, rGPR:$Rm, rot_imm:$rot, pred:$p)>;
def : t2InstAlias<"sxth${p} $Rd, $Rm$rot",
                  (t2SXTH rGPR:$Rd, rGPR:$Rm, rot_imm:$rot, pred:$p)>;


// "mov Rd, t2_so_imm_not" can be handled via "mvn" in assembly, just like
// for isel.
def : t2InstAlias<"mov${p} $Rd, $imm",
                  (t2MVNi rGPR:$Rd, t2_so_imm_not:$imm, pred:$p, zero_reg)>;
def : t2InstAlias<"mvn${p} $Rd, $imm",
                  (t2MOVi rGPR:$Rd, t2_so_imm_not:$imm, pred:$p, zero_reg)>;
// Same for AND <--> BIC
def : t2InstAlias<"bic${s}${p} $Rd, $Rn, $imm",
                  (t2ANDri rGPR:$Rd, rGPR:$Rn, t2_so_imm_not:$imm,
                           pred:$p, cc_out:$s)>;
def : t2InstAlias<"bic${s}${p} $Rdn, $imm",
                  (t2ANDri rGPR:$Rdn, rGPR:$Rdn, t2_so_imm_not:$imm,
                           pred:$p, cc_out:$s)>;
def : t2InstAlias<"and${s}${p} $Rd, $Rn, $imm",
                  (t2BICri rGPR:$Rd, rGPR:$Rn, t2_so_imm_not:$imm,
                           pred:$p, cc_out:$s)>;
def : t2InstAlias<"and${s}${p} $Rdn, $imm",
                  (t2BICri rGPR:$Rdn, rGPR:$Rdn, t2_so_imm_not:$imm,
                           pred:$p, cc_out:$s)>;
// Likewise, "add Rd, t2_so_imm_neg" -> sub
def : t2InstAlias<"add${s}${p} $Rd, $Rn, $imm",
                  (t2SUBri GPRnopc:$Rd, GPRnopc:$Rn, t2_so_imm_neg:$imm,
                           pred:$p, cc_out:$s)>;
def : t2InstAlias<"add${s}${p} $Rd, $imm",
                  (t2SUBri GPRnopc:$Rd, GPRnopc:$Rd, t2_so_imm_neg:$imm,
                           pred:$p, cc_out:$s)>;
// Same for CMP <--> CMN via t2_so_imm_neg
def : t2InstAlias<"cmp${p} $Rd, $imm",
                  (t2CMNri rGPR:$Rd, t2_so_imm_neg:$imm, pred:$p)>;
def : t2InstAlias<"cmn${p} $Rd, $imm",
                  (t2CMPri rGPR:$Rd, t2_so_imm_neg:$imm, pred:$p)>;


// Wide 'mul' encoding can be specified with only two operands.
def : t2InstAlias<"mul${p} $Rn, $Rm",
                  (t2MUL rGPR:$Rn, rGPR:$Rm, rGPR:$Rn, pred:$p)>;

// "neg" is and alias for "rsb rd, rn, #0"
def : t2InstAlias<"neg${s}${p} $Rd, $Rm",
                  (t2RSBri rGPR:$Rd, rGPR:$Rm, 0, pred:$p, cc_out:$s)>;

// MOV so_reg assembler pseudos. InstAlias isn't expressive enough for
// these, unfortunately.
def t2MOVsi: t2AsmPseudo<"mov${p} $Rd, $shift",
                         (ins rGPR:$Rd, t2_so_reg:$shift, pred:$p)>;
def t2MOVSsi: t2AsmPseudo<"movs${p} $Rd, $shift",
                          (ins rGPR:$Rd, t2_so_reg:$shift, pred:$p)>;

def t2MOVsr: t2AsmPseudo<"mov${p} $Rd, $shift",
                         (ins rGPR:$Rd, so_reg_reg:$shift, pred:$p)>;
def t2MOVSsr: t2AsmPseudo<"movs${p} $Rd, $shift",
                          (ins rGPR:$Rd, so_reg_reg:$shift, pred:$p)>;

// ADR w/o the .w suffix
def : t2InstAlias<"adr${p} $Rd, $addr",
                  (t2ADR rGPR:$Rd, t2adrlabel:$addr, pred:$p)>;

// LDR(literal) w/ alternate [pc, #imm] syntax.
def t2LDRpcrel   : t2AsmPseudo<"ldr${p} $Rt, $addr",
                         (ins GPR:$Rt, t2ldr_pcrel_imm12:$addr, pred:$p)>;
def t2LDRBpcrel  : t2AsmPseudo<"ldrb${p} $Rt, $addr",
                         (ins GPRnopc:$Rt, t2ldr_pcrel_imm12:$addr, pred:$p)>;
def t2LDRHpcrel  : t2AsmPseudo<"ldrh${p} $Rt, $addr",
                         (ins GPRnopc:$Rt, t2ldr_pcrel_imm12:$addr, pred:$p)>;
def t2LDRSBpcrel  : t2AsmPseudo<"ldrsb${p} $Rt, $addr",
                         (ins GPRnopc:$Rt, t2ldr_pcrel_imm12:$addr, pred:$p)>;
def t2LDRSHpcrel  : t2AsmPseudo<"ldrsh${p} $Rt, $addr",
                         (ins GPRnopc:$Rt, t2ldr_pcrel_imm12:$addr, pred:$p)>;
    // Version w/ the .w suffix.
def : t2InstAlias<"ldr${p}.w $Rt, $addr",
                  (t2LDRpcrel GPR:$Rt, t2ldr_pcrel_imm12:$addr, pred:$p), 0>;
def : t2InstAlias<"ldrb${p}.w $Rt, $addr",
                  (t2LDRBpcrel GPRnopc:$Rt, t2ldr_pcrel_imm12:$addr, pred:$p)>;
def : t2InstAlias<"ldrh${p}.w $Rt, $addr",
                  (t2LDRHpcrel GPRnopc:$Rt, t2ldr_pcrel_imm12:$addr, pred:$p)>;
def : t2InstAlias<"ldrsb${p}.w $Rt, $addr",
                  (t2LDRSBpcrel GPRnopc:$Rt, t2ldr_pcrel_imm12:$addr, pred:$p)>;
def : t2InstAlias<"ldrsh${p}.w $Rt, $addr",
                  (t2LDRSHpcrel GPRnopc:$Rt, t2ldr_pcrel_imm12:$addr, pred:$p)>;

def : t2InstAlias<"add${p} $Rd, pc, $imm",
                  (t2ADR rGPR:$Rd, imm0_4095:$imm, pred:$p)>;

// PLD/PLDW/PLI with alternate literal form.
def : t2InstAlias<"pld${p} $addr",
                  (t2PLDpci t2ldr_pcrel_imm12:$addr, pred:$p)>;
def : InstAlias<"pli${p} $addr",
                 (t2PLIpci  t2ldr_pcrel_imm12:$addr, pred:$p)>,
      Requires<[IsThumb2,HasV7]>;
