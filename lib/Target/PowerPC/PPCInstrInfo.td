//===-- PPCInstrInfo.td - The PowerPC Instruction Set ------*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file describes the subset of the 32-bit PowerPC instruction set, as used
// by the PowerPC instruction selector.
//
//===----------------------------------------------------------------------===//

include "PPCInstrFormats.td"

//===----------------------------------------------------------------------===//
// PowerPC specific type constraints.
//
def SDT_PPCstfiwx : SDTypeProfile<0, 2, [ // stfiwx
  SDTCisVT<0, f64>, SDTCisPtrTy<1>
]>;
def SDT_PPClfiwx : SDTypeProfile<1, 1, [ // lfiw[az]x
  SDTCisVT<0, f64>, SDTCisPtrTy<1>
]>;

def SDT_PPCCallSeqStart : SDCallSeqStart<[ SDTCisVT<0, i32> ]>;
def SDT_PPCCallSeqEnd   : SDCallSeqEnd<[ SDTCisVT<0, i32>,
                                         SDTCisVT<1, i32> ]>;
def SDT_PPCvperm   : SDTypeProfile<1, 3, [
  SDTCisVT<3, v16i8>, SDTCisSameAs<0, 1>, SDTCisSameAs<0, 2>
]>;

def SDT_PPCvcmp : SDTypeProfile<1, 3, [
  SDTCisSameAs<0, 1>, SDTCisSameAs<1, 2>, SDTCisVT<3, i32>
]>;

def SDT_PPCcondbr : SDTypeProfile<0, 3, [
  SDTCisVT<0, i32>, SDTCisVT<2, OtherVT>
]>;

def SDT_PPClbrx : SDTypeProfile<1, 2, [
  SDTCisInt<0>, SDTCisPtrTy<1>, SDTCisVT<2, OtherVT>
]>;
def SDT_PPCstbrx : SDTypeProfile<0, 3, [
  SDTCisInt<0>, SDTCisPtrTy<1>, SDTCisVT<2, OtherVT>
]>;

def SDT_PPClarx : SDTypeProfile<1, 1, [
  SDTCisInt<0>, SDTCisPtrTy<1>
]>;
def SDT_PPCstcx : SDTypeProfile<0, 2, [
  SDTCisInt<0>, SDTCisPtrTy<1>
]>;

def SDT_PPCTC_ret : SDTypeProfile<0, 2, [
  SDTCisPtrTy<0>, SDTCisVT<1, i32>
]>;


//===----------------------------------------------------------------------===//
// PowerPC specific DAG Nodes.
//

def PPCfre    : SDNode<"PPCISD::FRE",     SDTFPUnaryOp, []>;
def PPCfrsqrte: SDNode<"PPCISD::FRSQRTE", SDTFPUnaryOp, []>;

def PPCfcfid  : SDNode<"PPCISD::FCFID",   SDTFPUnaryOp, []>;
def PPCfcfidu : SDNode<"PPCISD::FCFIDU",  SDTFPUnaryOp, []>;
def PPCfcfids : SDNode<"PPCISD::FCFIDS",  SDTFPRoundOp, []>;
def PPCfcfidus: SDNode<"PPCISD::FCFIDUS", SDTFPRoundOp, []>;
def PPCfctidz : SDNode<"PPCISD::FCTIDZ", SDTFPUnaryOp, []>;
def PPCfctiwz : SDNode<"PPCISD::FCTIWZ", SDTFPUnaryOp, []>;
def PPCfctiduz: SDNode<"PPCISD::FCTIDUZ",SDTFPUnaryOp, []>;
def PPCfctiwuz: SDNode<"PPCISD::FCTIWUZ",SDTFPUnaryOp, []>;
def PPCstfiwx : SDNode<"PPCISD::STFIWX", SDT_PPCstfiwx,
                       [SDNPHasChain, SDNPMayStore]>;
def PPClfiwax : SDNode<"PPCISD::LFIWAX", SDT_PPClfiwx,
                       [SDNPHasChain, SDNPMayLoad]>;
def PPClfiwzx : SDNode<"PPCISD::LFIWZX", SDT_PPClfiwx,
                       [SDNPHasChain, SDNPMayLoad]>;

// Extract FPSCR (not modeled at the DAG level).
def PPCmffs   : SDNode<"PPCISD::MFFS",
                       SDTypeProfile<1, 0, [SDTCisVT<0, f64>]>, []>;

// Perform FADD in round-to-zero mode.
def PPCfaddrtz: SDNode<"PPCISD::FADDRTZ", SDTFPBinOp, []>;


def PPCfsel   : SDNode<"PPCISD::FSEL",  
   // Type constraint for fsel.
   SDTypeProfile<1, 3, [SDTCisSameAs<0, 2>, SDTCisSameAs<0, 3>, 
                        SDTCisFP<0>, SDTCisVT<1, f64>]>, []>;

def PPChi       : SDNode<"PPCISD::Hi", SDTIntBinOp, []>;
def PPClo       : SDNode<"PPCISD::Lo", SDTIntBinOp, []>;
def PPCtoc_entry: SDNode<"PPCISD::TOC_ENTRY", SDTIntBinOp, [SDNPMayLoad]>;
def PPCvmaddfp  : SDNode<"PPCISD::VMADDFP", SDTFPTernaryOp, []>;
def PPCvnmsubfp : SDNode<"PPCISD::VNMSUBFP", SDTFPTernaryOp, []>;

def PPCaddisGotTprelHA : SDNode<"PPCISD::ADDIS_GOT_TPREL_HA", SDTIntBinOp>;
def PPCldGotTprelL : SDNode<"PPCISD::LD_GOT_TPREL_L", SDTIntBinOp,
                            [SDNPMayLoad]>;
def PPCaddTls     : SDNode<"PPCISD::ADD_TLS", SDTIntBinOp, []>;
def PPCaddisTlsgdHA : SDNode<"PPCISD::ADDIS_TLSGD_HA", SDTIntBinOp>;
def PPCaddiTlsgdL   : SDNode<"PPCISD::ADDI_TLSGD_L", SDTIntBinOp>;
def PPCgetTlsAddr   : SDNode<"PPCISD::GET_TLS_ADDR", SDTIntBinOp>;
def PPCaddisTlsldHA : SDNode<"PPCISD::ADDIS_TLSLD_HA", SDTIntBinOp>;
def PPCaddiTlsldL   : SDNode<"PPCISD::ADDI_TLSLD_L", SDTIntBinOp>;
def PPCgetTlsldAddr : SDNode<"PPCISD::GET_TLSLD_ADDR", SDTIntBinOp>;
def PPCaddisDtprelHA : SDNode<"PPCISD::ADDIS_DTPREL_HA", SDTIntBinOp,
                              [SDNPHasChain]>;
def PPCaddiDtprelL   : SDNode<"PPCISD::ADDI_DTPREL_L", SDTIntBinOp>;

def PPCvperm    : SDNode<"PPCISD::VPERM", SDT_PPCvperm, []>;

// These nodes represent the 32-bit PPC shifts that operate on 6-bit shift
// amounts.  These nodes are generated by the multi-precision shift code.
def PPCsrl        : SDNode<"PPCISD::SRL"       , SDTIntShiftOp>;
def PPCsra        : SDNode<"PPCISD::SRA"       , SDTIntShiftOp>;
def PPCshl        : SDNode<"PPCISD::SHL"       , SDTIntShiftOp>;

// These are target-independent nodes, but have target-specific formats.
def callseq_start : SDNode<"ISD::CALLSEQ_START", SDT_PPCCallSeqStart,
                           [SDNPHasChain, SDNPOutGlue]>;
def callseq_end   : SDNode<"ISD::CALLSEQ_END",   SDT_PPCCallSeqEnd,
                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;

def SDT_PPCCall   : SDTypeProfile<0, -1, [SDTCisInt<0>]>;
def PPCcall  : SDNode<"PPCISD::CALL", SDT_PPCCall,
                      [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
                       SDNPVariadic]>;
def PPCcall_nop  : SDNode<"PPCISD::CALL_NOP", SDT_PPCCall,
                          [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
                           SDNPVariadic]>;
def PPCload   : SDNode<"PPCISD::LOAD", SDTypeProfile<1, 1, []>,
                       [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;
def PPCload_toc : SDNode<"PPCISD::LOAD_TOC", SDTypeProfile<0, 1, []>,
                          [SDNPHasChain, SDNPSideEffect,
                           SDNPInGlue, SDNPOutGlue]>;
def PPCtoc_restore : SDNode<"PPCISD::TOC_RESTORE", SDTypeProfile<0, 0, []>,
                            [SDNPHasChain, SDNPSideEffect,
                             SDNPInGlue, SDNPOutGlue]>;
def PPCmtctr      : SDNode<"PPCISD::MTCTR", SDT_PPCCall,
                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;
def PPCbctrl : SDNode<"PPCISD::BCTRL", SDTNone,
                      [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
                       SDNPVariadic]>;

def retflag       : SDNode<"PPCISD::RET_FLAG", SDTNone,
                           [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;

def PPCtc_return : SDNode<"PPCISD::TC_RETURN", SDT_PPCTC_ret,
                        [SDNPHasChain,  SDNPOptInGlue, SDNPVariadic]>;

def PPCeh_sjlj_setjmp  : SDNode<"PPCISD::EH_SJLJ_SETJMP",
                                SDTypeProfile<1, 1, [SDTCisInt<0>,
                                                     SDTCisPtrTy<1>]>,
                                [SDNPHasChain, SDNPSideEffect]>;
def PPCeh_sjlj_longjmp : SDNode<"PPCISD::EH_SJLJ_LONGJMP",
                                SDTypeProfile<0, 1, [SDTCisPtrTy<0>]>,
                                [SDNPHasChain, SDNPSideEffect]>;

def SDT_PPCsc     : SDTypeProfile<0, 1, [SDTCisInt<0>]>;
def PPCsc         : SDNode<"PPCISD::SC", SDT_PPCsc,
                           [SDNPHasChain, SDNPSideEffect]>;

def PPCvcmp       : SDNode<"PPCISD::VCMP" , SDT_PPCvcmp, []>;
def PPCvcmp_o     : SDNode<"PPCISD::VCMPo", SDT_PPCvcmp, [SDNPOutGlue]>;

def PPCcondbranch : SDNode<"PPCISD::COND_BRANCH", SDT_PPCcondbr,
                           [SDNPHasChain, SDNPOptInGlue]>;

def PPClbrx       : SDNode<"PPCISD::LBRX", SDT_PPClbrx,
                           [SDNPHasChain, SDNPMayLoad]>;
def PPCstbrx      : SDNode<"PPCISD::STBRX", SDT_PPCstbrx,
                           [SDNPHasChain, SDNPMayStore]>;

// Instructions to set/unset CR bit 6 for SVR4 vararg calls
def PPCcr6set   : SDNode<"PPCISD::CR6SET", SDTNone,
                         [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;
def PPCcr6unset : SDNode<"PPCISD::CR6UNSET", SDTNone,
                         [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;

// Instructions to support atomic operations
def PPClarx      : SDNode<"PPCISD::LARX", SDT_PPClarx,
                          [SDNPHasChain, SDNPMayLoad]>;
def PPCstcx      : SDNode<"PPCISD::STCX", SDT_PPCstcx,
                          [SDNPHasChain, SDNPMayStore]>;

// Instructions to support medium and large code model
def PPCaddisTocHA : SDNode<"PPCISD::ADDIS_TOC_HA", SDTIntBinOp, []>;
def PPCldTocL     : SDNode<"PPCISD::LD_TOC_L", SDTIntBinOp, [SDNPMayLoad]>;
def PPCaddiTocL   : SDNode<"PPCISD::ADDI_TOC_L", SDTIntBinOp, []>;


// Instructions to support dynamic alloca.
def SDTDynOp  : SDTypeProfile<1, 2, []>;
def PPCdynalloc   : SDNode<"PPCISD::DYNALLOC", SDTDynOp, [SDNPHasChain]>;

//===----------------------------------------------------------------------===//
// PowerPC specific transformation functions and pattern fragments.
//

def SHL32 : SDNodeXForm<imm, [{
  // Transformation function: 31 - imm
  return getI32Imm(31 - N->getZExtValue());
}]>;

def SRL32 : SDNodeXForm<imm, [{
  // Transformation function: 32 - imm
  return N->getZExtValue() ? getI32Imm(32 - N->getZExtValue()) : getI32Imm(0);
}]>;

def LO16 : SDNodeXForm<imm, [{
  // Transformation function: get the low 16 bits.
  return getI32Imm((unsigned short)N->getZExtValue());
}]>;

def HI16 : SDNodeXForm<imm, [{
  // Transformation function: shift the immediate value down into the low bits.
  return getI32Imm((unsigned)N->getZExtValue() >> 16);
}]>;

def HA16 : SDNodeXForm<imm, [{
  // Transformation function: shift the immediate value down into the low bits.
  signed int Val = N->getZExtValue();
  return getI32Imm((Val - (signed short)Val) >> 16);
}]>;
def MB : SDNodeXForm<imm, [{
  // Transformation function: get the start bit of a mask
  unsigned mb = 0, me;
  (void)isRunOfOnes((unsigned)N->getZExtValue(), mb, me);
  return getI32Imm(mb);
}]>;

def ME : SDNodeXForm<imm, [{
  // Transformation function: get the end bit of a mask
  unsigned mb, me = 0;
  (void)isRunOfOnes((unsigned)N->getZExtValue(), mb, me);
  return getI32Imm(me);
}]>;
def maskimm32 : PatLeaf<(imm), [{
  // maskImm predicate - True if immediate is a run of ones.
  unsigned mb, me;
  if (N->getValueType(0) == MVT::i32)
    return isRunOfOnes((unsigned)N->getZExtValue(), mb, me);
  else
    return false;
}]>;

def imm32SExt16  : Operand<i32>, ImmLeaf<i32, [{
  // imm32SExt16 predicate - True if the i32 immediate fits in a 16-bit
  // sign extended field.  Used by instructions like 'addi'.
  return (int32_t)Imm == (short)Imm;
}]>;
def imm64SExt16  : Operand<i64>, ImmLeaf<i64, [{
  // imm64SExt16 predicate - True if the i64 immediate fits in a 16-bit
  // sign extended field.  Used by instructions like 'addi'.
  return (int64_t)Imm == (short)Imm;
}]>;
def immZExt16  : PatLeaf<(imm), [{
  // immZExt16 predicate - True if the immediate fits in a 16-bit zero extended
  // field.  Used by instructions like 'ori'.
  return (uint64_t)N->getZExtValue() == (unsigned short)N->getZExtValue();
}], LO16>;

// imm16Shifted* - These match immediates where the low 16-bits are zero.  There
// are two forms: imm16ShiftedSExt and imm16ShiftedZExt.  These two forms are
// identical in 32-bit mode, but in 64-bit mode, they return true if the
// immediate fits into a sign/zero extended 32-bit immediate (with the low bits
// clear).
def imm16ShiftedZExt : PatLeaf<(imm), [{
  // imm16ShiftedZExt predicate - True if only bits in the top 16-bits of the
  // immediate are set.  Used by instructions like 'xoris'.
  return (N->getZExtValue() & ~uint64_t(0xFFFF0000)) == 0;
}], HI16>;

def imm16ShiftedSExt : PatLeaf<(imm), [{
  // imm16ShiftedSExt predicate - True if only bits in the top 16-bits of the
  // immediate are set.  Used by instructions like 'addis'.  Identical to 
  // imm16ShiftedZExt in 32-bit mode.
  if (N->getZExtValue() & 0xFFFF) return false;
  if (N->getValueType(0) == MVT::i32)
    return true;
  // For 64-bit, make sure it is sext right.
  return N->getZExtValue() == (uint64_t)(int)N->getZExtValue();
}], HI16>;

// Some r+i load/store instructions (such as LD, STD, LDU, etc.) that require
// restricted memrix (4-aligned) constants are alignment sensitive. If these
// offsets are hidden behind TOC entries than the values of the lower-order
// bits cannot be checked directly. As a result, we need to also incorporate
// an alignment check into the relevant patterns.

def aligned4load : PatFrag<(ops node:$ptr), (load node:$ptr), [{
  return cast<LoadSDNode>(N)->getAlignment() >= 4;
}]>;
def aligned4store : PatFrag<(ops node:$val, node:$ptr),
                            (store node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->getAlignment() >= 4;
}]>;
def aligned4sextloadi32 : PatFrag<(ops node:$ptr), (sextloadi32 node:$ptr), [{
  return cast<LoadSDNode>(N)->getAlignment() >= 4;
}]>;
def aligned4pre_store : PatFrag<
                          (ops node:$val, node:$base, node:$offset),
                          (pre_store node:$val, node:$base, node:$offset), [{
  return cast<StoreSDNode>(N)->getAlignment() >= 4;
}]>;

def unaligned4load : PatFrag<(ops node:$ptr), (load node:$ptr), [{
  return cast<LoadSDNode>(N)->getAlignment() < 4;
}]>;
def unaligned4store : PatFrag<(ops node:$val, node:$ptr),
                              (store node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->getAlignment() < 4;
}]>;
def unaligned4sextloadi32 : PatFrag<(ops node:$ptr), (sextloadi32 node:$ptr), [{
  return cast<LoadSDNode>(N)->getAlignment() < 4;
}]>;

//===----------------------------------------------------------------------===//
// PowerPC Flag Definitions.

class isPPC64 { bit PPC64 = 1; }
class isDOT   { bit RC = 1; }

class RegConstraint<string C> {
  string Constraints = C;
}
class NoEncode<string E> {
  string DisableEncoding = E;
}


//===----------------------------------------------------------------------===//
// PowerPC Operand Definitions.

// In the default PowerPC assembler syntax, registers are specified simply
// by number, so they cannot be distinguished from immediate values (without
// looking at the opcode).  This means that the default operand matching logic
// for the asm parser does not work, and we need to specify custom matchers.
// Since those can only be specified with RegisterOperand classes and not
// directly on the RegisterClass, all instructions patterns used by the asm
// parser need to use a RegisterOperand (instead of a RegisterClass) for
// all their register operands.
// For this purpose, we define one RegisterOperand for each RegisterClass,
// using the same name as the class, just in lower case.

def PPCRegGPRCAsmOperand : AsmOperandClass {
  let Name = "RegGPRC"; let PredicateMethod = "isRegNumber";
}
def gprc : RegisterOperand<GPRC> {
  let ParserMatchClass = PPCRegGPRCAsmOperand;
}
def PPCRegG8RCAsmOperand : AsmOperandClass {
  let Name = "RegG8RC"; let PredicateMethod = "isRegNumber";
}
def g8rc : RegisterOperand<G8RC> {
  let ParserMatchClass = PPCRegG8RCAsmOperand;
}
def PPCRegGPRCNoR0AsmOperand : AsmOperandClass {
  let Name = "RegGPRCNoR0"; let PredicateMethod = "isRegNumber";
}
def gprc_nor0 : RegisterOperand<GPRC_NOR0> {
  let ParserMatchClass = PPCRegGPRCNoR0AsmOperand;
}
def PPCRegG8RCNoX0AsmOperand : AsmOperandClass {
  let Name = "RegG8RCNoX0"; let PredicateMethod = "isRegNumber";
}
def g8rc_nox0 : RegisterOperand<G8RC_NOX0> {
  let ParserMatchClass = PPCRegG8RCNoX0AsmOperand;
}
def PPCRegF8RCAsmOperand : AsmOperandClass {
  let Name = "RegF8RC"; let PredicateMethod = "isRegNumber";
}
def f8rc : RegisterOperand<F8RC> {
  let ParserMatchClass = PPCRegF8RCAsmOperand;
}
def PPCRegF4RCAsmOperand : AsmOperandClass {
  let Name = "RegF4RC"; let PredicateMethod = "isRegNumber";
}
def f4rc : RegisterOperand<F4RC> {
  let ParserMatchClass = PPCRegF4RCAsmOperand;
}
def PPCRegVRRCAsmOperand : AsmOperandClass {
  let Name = "RegVRRC"; let PredicateMethod = "isRegNumber";
}
def vrrc : RegisterOperand<VRRC> {
  let ParserMatchClass = PPCRegVRRCAsmOperand;
}
def PPCRegCRBITRCAsmOperand : AsmOperandClass {
  let Name = "RegCRBITRC"; let PredicateMethod = "isCRBitNumber";
}
def crbitrc : RegisterOperand<CRBITRC> {
  let ParserMatchClass = PPCRegCRBITRCAsmOperand;
}
def PPCRegCRRCAsmOperand : AsmOperandClass {
  let Name = "RegCRRC"; let PredicateMethod = "isCCRegNumber";
}
def crrc : RegisterOperand<CRRC> {
  let ParserMatchClass = PPCRegCRRCAsmOperand;
}

def PPCS5ImmAsmOperand : AsmOperandClass {
  let Name = "S5Imm"; let PredicateMethod = "isS5Imm";
  let RenderMethod = "addImmOperands";
}
def s5imm   : Operand<i32> {
  let PrintMethod = "printS5ImmOperand";
  let ParserMatchClass = PPCS5ImmAsmOperand;
}
def PPCU5ImmAsmOperand : AsmOperandClass {
  let Name = "U5Imm"; let PredicateMethod = "isU5Imm";
  let RenderMethod = "addImmOperands";
}
def u5imm   : Operand<i32> {
  let PrintMethod = "printU5ImmOperand";
  let ParserMatchClass = PPCU5ImmAsmOperand;
}
def PPCU6ImmAsmOperand : AsmOperandClass {
  let Name = "U6Imm"; let PredicateMethod = "isU6Imm";
  let RenderMethod = "addImmOperands";
}
def u6imm   : Operand<i32> {
  let PrintMethod = "printU6ImmOperand";
  let ParserMatchClass = PPCU6ImmAsmOperand;
}
def PPCS16ImmAsmOperand : AsmOperandClass {
  let Name = "S16Imm"; let PredicateMethod = "isS16Imm";
  let RenderMethod = "addImmOperands";
}
def s16imm  : Operand<i32> {
  let PrintMethod = "printS16ImmOperand";
  let EncoderMethod = "getImm16Encoding";
  let ParserMatchClass = PPCS16ImmAsmOperand;
}
def PPCU16ImmAsmOperand : AsmOperandClass {
  let Name = "U16Imm"; let PredicateMethod = "isU16Imm";
  let RenderMethod = "addImmOperands";
}
def u16imm  : Operand<i32> {
  let PrintMethod = "printU16ImmOperand";
  let EncoderMethod = "getImm16Encoding";
  let ParserMatchClass = PPCU16ImmAsmOperand;
}
def PPCS17ImmAsmOperand : AsmOperandClass {
  let Name = "S17Imm"; let PredicateMethod = "isS17Imm";
  let RenderMethod = "addImmOperands";
}
def s17imm  : Operand<i32> {
  // This operand type is used for addis/lis to allow the assembler parser
  // to accept immediates in the range -65536..65535 for compatibility with
  // the GNU assembler.  The operand is treated as 16-bit otherwise.
  let PrintMethod = "printS16ImmOperand";
  let EncoderMethod = "getImm16Encoding";
  let ParserMatchClass = PPCS17ImmAsmOperand;
}
def PPCDirectBrAsmOperand : AsmOperandClass {
  let Name = "DirectBr"; let PredicateMethod = "isDirectBr";
  let RenderMethod = "addBranchTargetOperands";
}
def directbrtarget : Operand<OtherVT> {
  let PrintMethod = "printBranchOperand";
  let EncoderMethod = "getDirectBrEncoding";
  let ParserMatchClass = PPCDirectBrAsmOperand;
}
def absdirectbrtarget : Operand<OtherVT> {
  let PrintMethod = "printAbsBranchOperand";
  let EncoderMethod = "getAbsDirectBrEncoding";
  let ParserMatchClass = PPCDirectBrAsmOperand;
}
def PPCCondBrAsmOperand : AsmOperandClass {
  let Name = "CondBr"; let PredicateMethod = "isCondBr";
  let RenderMethod = "addBranchTargetOperands";
}
def condbrtarget : Operand<OtherVT> {
  let PrintMethod = "printBranchOperand";
  let EncoderMethod = "getCondBrEncoding";
  let ParserMatchClass = PPCCondBrAsmOperand;
}
def abscondbrtarget : Operand<OtherVT> {
  let PrintMethod = "printAbsBranchOperand";
  let EncoderMethod = "getAbsCondBrEncoding";
  let ParserMatchClass = PPCCondBrAsmOperand;
}
def calltarget : Operand<iPTR> {
  let PrintMethod = "printBranchOperand";
  let EncoderMethod = "getDirectBrEncoding";
  let ParserMatchClass = PPCDirectBrAsmOperand;
}
def abscalltarget : Operand<iPTR> {
  let PrintMethod = "printAbsBranchOperand";
  let EncoderMethod = "getAbsDirectBrEncoding";
  let ParserMatchClass = PPCDirectBrAsmOperand;
}
def PPCCRBitMaskOperand : AsmOperandClass {
 let Name = "CRBitMask"; let PredicateMethod = "isCRBitMask";
}
def crbitm: Operand<i8> {
  let PrintMethod = "printcrbitm";
  let EncoderMethod = "get_crbitm_encoding";
  let ParserMatchClass = PPCCRBitMaskOperand;
}
// Address operands
// A version of ptr_rc which excludes R0 (or X0 in 64-bit mode).
def PPCRegGxRCNoR0Operand : AsmOperandClass {
  let Name = "RegGxRCNoR0"; let PredicateMethod = "isRegNumber";
}
def ptr_rc_nor0 : Operand<iPTR>, PointerLikeRegClass<1> {
  let ParserMatchClass = PPCRegGxRCNoR0Operand;
}
// A version of ptr_rc usable with the asm parser.
def PPCRegGxRCOperand : AsmOperandClass {
  let Name = "RegGxRC"; let PredicateMethod = "isRegNumber";
}
def ptr_rc_idx : Operand<iPTR>, PointerLikeRegClass<0> {
  let ParserMatchClass = PPCRegGxRCOperand;
}

def PPCDispRIOperand : AsmOperandClass {
 let Name = "DispRI"; let PredicateMethod = "isS16Imm";
 let RenderMethod = "addImmOperands";
}
def dispRI : Operand<iPTR> {
  let ParserMatchClass = PPCDispRIOperand;
}
def PPCDispRIXOperand : AsmOperandClass {
 let Name = "DispRIX"; let PredicateMethod = "isS16ImmX4";
 let RenderMethod = "addImmOperands";
}
def dispRIX : Operand<iPTR> {
  let ParserMatchClass = PPCDispRIXOperand;
}

def memri : Operand<iPTR> {
  let PrintMethod = "printMemRegImm";
  let MIOperandInfo = (ops dispRI:$imm, ptr_rc_nor0:$reg);
  let EncoderMethod = "getMemRIEncoding";
}
def memrr : Operand<iPTR> {
  let PrintMethod = "printMemRegReg";
  let MIOperandInfo = (ops ptr_rc_nor0:$ptrreg, ptr_rc_idx:$offreg);
}
def memrix : Operand<iPTR> {   // memri where the imm is 4-aligned.
  let PrintMethod = "printMemRegImm";
  let MIOperandInfo = (ops dispRIX:$imm, ptr_rc_nor0:$reg);
  let EncoderMethod = "getMemRIXEncoding";
}

// A single-register address. This is used with the SjLj
// pseudo-instructions.
def memr : Operand<iPTR> {
  let MIOperandInfo = (ops ptr_rc:$ptrreg);
}

// PowerPC Predicate operand.
def pred : Operand<OtherVT> {
  let PrintMethod = "printPredicateOperand";
  let MIOperandInfo = (ops i32imm:$bibo, crrc:$reg);
}

// Define PowerPC specific addressing mode.
def iaddr  : ComplexPattern<iPTR, 2, "SelectAddrImm",    [], []>;
def xaddr  : ComplexPattern<iPTR, 2, "SelectAddrIdx",    [], []>;
def xoaddr : ComplexPattern<iPTR, 2, "SelectAddrIdxOnly",[], []>;
def ixaddr : ComplexPattern<iPTR, 2, "SelectAddrImmX4",  [], []>; // "std"

// The address in a single register. This is used with the SjLj
// pseudo-instructions.
def addr   : ComplexPattern<iPTR, 1, "SelectAddr",[], []>;

/// This is just the offset part of iaddr, used for preinc.
def iaddroff : ComplexPattern<iPTR, 1, "SelectAddrImmOffs", [], []>;

//===----------------------------------------------------------------------===//
// PowerPC Instruction Predicate Definitions.
def In32BitMode  : Predicate<"!PPCSubTarget.isPPC64()">;
def In64BitMode  : Predicate<"PPCSubTarget.isPPC64()">;
def IsBookE  : Predicate<"PPCSubTarget.isBookE()">;

//===----------------------------------------------------------------------===//
// PowerPC Multiclass Definitions.

multiclass XForm_6r<bits<6> opcode, bits<10> xo, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : XForm_6<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR0] in
    def o    : XForm_6<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass XForm_6rc<bits<6> opcode, bits<10> xo, dag OOL, dag IOL,
                     string asmbase, string asmstr, InstrItinClass itin,
                     list<dag> pattern> {
  let BaseName = asmbase in {
    let Defs = [CARRY] in
    def NAME : XForm_6<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CARRY, CR0] in
    def o    : XForm_6<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass XForm_10r<bits<6> opcode, bits<10> xo, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : XForm_10<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR0] in
    def o    : XForm_10<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass XForm_10rc<bits<6> opcode, bits<10> xo, dag OOL, dag IOL,
                      string asmbase, string asmstr, InstrItinClass itin,
                      list<dag> pattern> {
  let BaseName = asmbase in {
    let Defs = [CARRY] in
    def NAME : XForm_10<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CARRY, CR0] in
    def o    : XForm_10<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass XForm_11r<bits<6> opcode, bits<10> xo, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : XForm_11<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR0] in
    def o    : XForm_11<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass XOForm_1r<bits<6> opcode, bits<9> xo, bit oe, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : XOForm_1<opcode, xo, oe, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR0] in
    def o    : XOForm_1<opcode, xo, oe, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass XOForm_1rc<bits<6> opcode, bits<9> xo, bit oe, dag OOL, dag IOL,
                      string asmbase, string asmstr, InstrItinClass itin,
                      list<dag> pattern> {
  let BaseName = asmbase in {
    let Defs = [CARRY] in
    def NAME : XOForm_1<opcode, xo, oe, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CARRY, CR0] in
    def o    : XOForm_1<opcode, xo, oe, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass XOForm_3r<bits<6> opcode, bits<9> xo, bit oe, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : XOForm_3<opcode, xo, oe, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR0] in
    def o    : XOForm_3<opcode, xo, oe, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass XOForm_3rc<bits<6> opcode, bits<9> xo, bit oe, dag OOL, dag IOL,
                      string asmbase, string asmstr, InstrItinClass itin,
                      list<dag> pattern> {
  let BaseName = asmbase in {
    let Defs = [CARRY] in
    def NAME : XOForm_3<opcode, xo, oe, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CARRY, CR0] in
    def o    : XOForm_3<opcode, xo, oe, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass MForm_2r<bits<6> opcode, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : MForm_2<opcode, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR0] in
    def o    : MForm_2<opcode, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass MDForm_1r<bits<6> opcode, bits<3> xo, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : MDForm_1<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR0] in
    def o    : MDForm_1<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass MDSForm_1r<bits<6> opcode, bits<4> xo, dag OOL, dag IOL,
                     string asmbase, string asmstr, InstrItinClass itin,
                     list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : MDSForm_1<opcode, xo, OOL, IOL,
                        !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                        pattern>, RecFormRel;
    let Defs = [CR0] in
    def o    : MDSForm_1<opcode, xo, OOL, IOL,
                        !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                        []>, isDOT, RecFormRel;
  }
}

multiclass XSForm_1rc<bits<6> opcode, bits<9> xo, dag OOL, dag IOL,
                      string asmbase, string asmstr, InstrItinClass itin,
                      list<dag> pattern> {
  let BaseName = asmbase in {
    let Defs = [CARRY] in
    def NAME : XSForm_1<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CARRY, CR0] in
    def o    : XSForm_1<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass XForm_26r<bits<6> opcode, bits<10> xo, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : XForm_26<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR1] in
    def o    : XForm_26<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass AForm_1r<bits<6> opcode, bits<5> xo, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : AForm_1<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR1] in
    def o    : AForm_1<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass AForm_2r<bits<6> opcode, bits<5> xo, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : AForm_2<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR1] in
    def o    : AForm_2<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

multiclass AForm_3r<bits<6> opcode, bits<5> xo, dag OOL, dag IOL,
                    string asmbase, string asmstr, InstrItinClass itin,
                    list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : AForm_3<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(" ", asmstr)), itin,
                       pattern>, RecFormRel;
    let Defs = [CR1] in
    def o    : AForm_3<opcode, xo, OOL, IOL,
                       !strconcat(asmbase, !strconcat(". ", asmstr)), itin,
                       []>, isDOT, RecFormRel;
  }
}

//===----------------------------------------------------------------------===//
// PowerPC Instruction Definitions.

// Pseudo-instructions:

let hasCtrlDep = 1 in {
let Defs = [R1], Uses = [R1] in {
def ADJCALLSTACKDOWN : Pseudo<(outs), (ins u16imm:$amt), "#ADJCALLSTACKDOWN $amt",
                              [(callseq_start timm:$amt)]>;
def ADJCALLSTACKUP   : Pseudo<(outs), (ins u16imm:$amt1, u16imm:$amt2), "#ADJCALLSTACKUP $amt1 $amt2",
                              [(callseq_end timm:$amt1, timm:$amt2)]>;
}

def UPDATE_VRSAVE    : Pseudo<(outs gprc:$rD), (ins gprc:$rS),
                              "UPDATE_VRSAVE $rD, $rS", []>;
}

let Defs = [R1], Uses = [R1] in
def DYNALLOC : Pseudo<(outs gprc:$result), (ins gprc:$negsize, memri:$fpsi), "#DYNALLOC",
                       [(set i32:$result,
                             (PPCdynalloc i32:$negsize, iaddr:$fpsi))]>;
                         
// SELECT_CC_* - Used to implement the SELECT_CC DAG operation.  Expanded after
// instruction selection into a branch sequence.
let usesCustomInserter = 1,    // Expanded after instruction selection.
    PPC970_Single = 1 in {
  // Note that SELECT_CC_I4 and SELECT_CC_I8 use the no-r0 register classes
  // because either operand might become the first operand in an isel, and
  // that operand cannot be r0.
  def SELECT_CC_I4 : Pseudo<(outs gprc:$dst), (ins crrc:$cond,
                              gprc_nor0:$T, gprc_nor0:$F,
                              i32imm:$BROPC), "#SELECT_CC_I4",
                              []>;
  def SELECT_CC_I8 : Pseudo<(outs g8rc:$dst), (ins crrc:$cond,
                              g8rc_nox0:$T, g8rc_nox0:$F,
                              i32imm:$BROPC), "#SELECT_CC_I8",
                              []>;
  def SELECT_CC_F4  : Pseudo<(outs f4rc:$dst), (ins crrc:$cond, f4rc:$T, f4rc:$F,
                              i32imm:$BROPC), "#SELECT_CC_F4",
                              []>;
  def SELECT_CC_F8  : Pseudo<(outs f8rc:$dst), (ins crrc:$cond, f8rc:$T, f8rc:$F,
                              i32imm:$BROPC), "#SELECT_CC_F8",
                              []>;
  def SELECT_CC_VRRC: Pseudo<(outs vrrc:$dst), (ins crrc:$cond, vrrc:$T, vrrc:$F,
                              i32imm:$BROPC), "#SELECT_CC_VRRC",
                              []>;
}

// SPILL_CR - Indicate that we're dumping the CR register, so we'll need to
// scavenge a register for it.
let mayStore = 1 in
def SPILL_CR : Pseudo<(outs), (ins crrc:$cond, memri:$F),
                     "#SPILL_CR", []>;

// RESTORE_CR - Indicate that we're restoring the CR register (previously
// spilled), so we'll need to scavenge a register for it.
let mayLoad = 1 in
def RESTORE_CR : Pseudo<(outs crrc:$cond), (ins memri:$F),
                     "#RESTORE_CR", []>;

let isTerminator = 1, isBarrier = 1, PPC970_Unit = 7 in {
  let isReturn = 1, Uses = [LR, RM] in
    def BLR : XLForm_2_ext<19, 16, 20, 0, 0, (outs), (ins), "blr", BrB,
                           [(retflag)]>;
  let isBranch = 1, isIndirectBranch = 1, Uses = [CTR] in {
    def BCTR : XLForm_2_ext<19, 528, 20, 0, 0, (outs), (ins), "bctr", BrB, []>;

    let isCodeGenOnly = 1 in
    def BCCTR : XLForm_2_br<19, 528, 0, (outs), (ins pred:$cond),
                            "b${cond:cc}ctr${cond:pm} ${cond:reg}", BrB, []>;
  }
}

let Defs = [LR] in
  def MovePCtoLR : Pseudo<(outs), (ins), "#MovePCtoLR", []>,
                   PPC970_Unit_BRU;

let isBranch = 1, isTerminator = 1, hasCtrlDep = 1, PPC970_Unit = 7 in {
  let isBarrier = 1 in {
  def B   : IForm<18, 0, 0, (outs), (ins directbrtarget:$dst),
                  "b $dst", BrB,
                  [(br bb:$dst)]>;
  def BA  : IForm<18, 1, 0, (outs), (ins absdirectbrtarget:$dst),
                  "ba $dst", BrB, []>;
  }

  // BCC represents an arbitrary conditional branch on a predicate.
  // FIXME: should be able to write a pattern for PPCcondbranch, but can't use
  // a two-value operand where a dag node expects two operands. :(
  let isCodeGenOnly = 1 in {
    def BCC : BForm<16, 0, 0, (outs), (ins pred:$cond, condbrtarget:$dst),
                    "b${cond:cc}${cond:pm} ${cond:reg}, $dst"
                    /*[(PPCcondbranch crrc:$crS, imm:$opc, bb:$dst)]*/>;
    def BCCA : BForm<16, 1, 0, (outs), (ins pred:$cond, abscondbrtarget:$dst),
                     "b${cond:cc}a${cond:pm} ${cond:reg}, $dst">;

    let isReturn = 1, Uses = [LR, RM] in
    def BCLR : XLForm_2_br<19, 16, 0, (outs), (ins pred:$cond),
                           "b${cond:cc}lr${cond:pm} ${cond:reg}", BrB, []>;
  }

  let isReturn = 1, Defs = [CTR], Uses = [CTR, LR, RM] in {
   def BDZLR  : XLForm_2_ext<19, 16, 18, 0, 0, (outs), (ins),
                             "bdzlr", BrB, []>;
   def BDNZLR : XLForm_2_ext<19, 16, 16, 0, 0, (outs), (ins),
                             "bdnzlr", BrB, []>;
   def BDZLRp : XLForm_2_ext<19, 16, 27, 0, 0, (outs), (ins),
                             "bdzlr+", BrB, []>;
   def BDNZLRp: XLForm_2_ext<19, 16, 25, 0, 0, (outs), (ins),
                             "bdnzlr+", BrB, []>;
   def BDZLRm : XLForm_2_ext<19, 16, 26, 0, 0, (outs), (ins),
                             "bdzlr-", BrB, []>;
   def BDNZLRm: XLForm_2_ext<19, 16, 24, 0, 0, (outs), (ins),
                             "bdnzlr-", BrB, []>;
  }

  let Defs = [CTR], Uses = [CTR] in {
    def BDZ  : BForm_1<16, 18, 0, 0, (outs), (ins condbrtarget:$dst),
                       "bdz $dst">;
    def BDNZ : BForm_1<16, 16, 0, 0, (outs), (ins condbrtarget:$dst),
                       "bdnz $dst">;
    def BDZA  : BForm_1<16, 18, 1, 0, (outs), (ins abscondbrtarget:$dst),
                        "bdza $dst">;
    def BDNZA : BForm_1<16, 16, 1, 0, (outs), (ins abscondbrtarget:$dst),
                        "bdnza $dst">;
    def BDZp : BForm_1<16, 27, 0, 0, (outs), (ins condbrtarget:$dst),
                       "bdz+ $dst">;
    def BDNZp: BForm_1<16, 25, 0, 0, (outs), (ins condbrtarget:$dst),
                       "bdnz+ $dst">;
    def BDZAp : BForm_1<16, 27, 1, 0, (outs), (ins abscondbrtarget:$dst),
                        "bdza+ $dst">;
    def BDNZAp: BForm_1<16, 25, 1, 0, (outs), (ins abscondbrtarget:$dst),
                        "bdnza+ $dst">;
    def BDZm : BForm_1<16, 26, 0, 0, (outs), (ins condbrtarget:$dst),
                       "bdz- $dst">;
    def BDNZm: BForm_1<16, 24, 0, 0, (outs), (ins condbrtarget:$dst),
                       "bdnz- $dst">;
    def BDZAm : BForm_1<16, 26, 1, 0, (outs), (ins abscondbrtarget:$dst),
                        "bdza- $dst">;
    def BDNZAm: BForm_1<16, 24, 1, 0, (outs), (ins abscondbrtarget:$dst),
                        "bdnza- $dst">;
  }
}

// The unconditional BCL used by the SjLj setjmp code.
let isCall = 1, hasCtrlDep = 1, isCodeGenOnly = 1, PPC970_Unit = 7 in {
  let Defs = [LR], Uses = [RM] in {
    def BCLalways  : BForm_2<16, 20, 31, 0, 1, (outs), (ins condbrtarget:$dst),
                            "bcl 20, 31, $dst">;
  }
}

let isCall = 1, PPC970_Unit = 7, Defs = [LR] in {
  // Convenient aliases for call instructions
  let Uses = [RM] in {
    def BL  : IForm<18, 0, 1, (outs), (ins calltarget:$func),
                    "bl $func", BrB, []>;  // See Pat patterns below.
    def BLA : IForm<18, 1, 1, (outs), (ins abscalltarget:$func),
                    "bla $func", BrB, [(PPCcall (i32 imm:$func))]>;

    let isCodeGenOnly = 1 in {
      def BCCL : BForm<16, 0, 1, (outs), (ins pred:$cond, condbrtarget:$dst),
                       "b${cond:cc}l${cond:pm} ${cond:reg}, $dst">;
      def BCCLA : BForm<16, 1, 1, (outs), (ins pred:$cond, abscondbrtarget:$dst),
                        "b${cond:cc}la${cond:pm} ${cond:reg}, $dst">;
    }
  }
  let Uses = [CTR, RM] in {
    def BCTRL : XLForm_2_ext<19, 528, 20, 0, 1, (outs), (ins),
                             "bctrl", BrB, [(PPCbctrl)]>,
                Requires<[In32BitMode]>;

    let isCodeGenOnly = 1 in
    def BCCTRL : XLForm_2_br<19, 528, 1, (outs), (ins pred:$cond),
                             "b${cond:cc}ctrl${cond:pm} ${cond:reg}", BrB, []>;
  }
  let Uses = [LR, RM] in {
    def BLRL : XLForm_2_ext<19, 16, 20, 0, 1, (outs), (ins),
                            "blrl", BrB, []>;

    let isCodeGenOnly = 1 in
    def BCLRL : XLForm_2_br<19, 16, 1, (outs), (ins pred:$cond),
                            "b${cond:cc}lrl${cond:pm} ${cond:reg}", BrB, []>;
  }
  let Defs = [CTR], Uses = [CTR, RM] in {
    def BDZL  : BForm_1<16, 18, 0, 1, (outs), (ins condbrtarget:$dst),
                        "bdzl $dst">;
    def BDNZL : BForm_1<16, 16, 0, 1, (outs), (ins condbrtarget:$dst),
                        "bdnzl $dst">;
    def BDZLA  : BForm_1<16, 18, 1, 1, (outs), (ins abscondbrtarget:$dst),
                         "bdzla $dst">;
    def BDNZLA : BForm_1<16, 16, 1, 1, (outs), (ins abscondbrtarget:$dst),
                         "bdnzla $dst">;
    def BDZLp : BForm_1<16, 27, 0, 1, (outs), (ins condbrtarget:$dst),
                        "bdzl+ $dst">;
    def BDNZLp: BForm_1<16, 25, 0, 1, (outs), (ins condbrtarget:$dst),
                        "bdnzl+ $dst">;
    def BDZLAp : BForm_1<16, 27, 1, 1, (outs), (ins abscondbrtarget:$dst),
                         "bdzla+ $dst">;
    def BDNZLAp: BForm_1<16, 25, 1, 1, (outs), (ins abscondbrtarget:$dst),
                         "bdnzla+ $dst">;
    def BDZLm : BForm_1<16, 26, 0, 1, (outs), (ins condbrtarget:$dst),
                        "bdzl- $dst">;
    def BDNZLm: BForm_1<16, 24, 0, 1, (outs), (ins condbrtarget:$dst),
                        "bdnzl- $dst">;
    def BDZLAm : BForm_1<16, 26, 1, 1, (outs), (ins abscondbrtarget:$dst),
                         "bdzla- $dst">;
    def BDNZLAm: BForm_1<16, 24, 1, 1, (outs), (ins abscondbrtarget:$dst),
                         "bdnzla- $dst">;
  }
  let Defs = [CTR], Uses = [CTR, LR, RM] in {
    def BDZLRL  : XLForm_2_ext<19, 16, 18, 0, 1, (outs), (ins),
                               "bdzlrl", BrB, []>;
    def BDNZLRL : XLForm_2_ext<19, 16, 16, 0, 1, (outs), (ins),
                               "bdnzlrl", BrB, []>;
    def BDZLRLp : XLForm_2_ext<19, 16, 27, 0, 1, (outs), (ins),
                               "bdzlrl+", BrB, []>;
    def BDNZLRLp: XLForm_2_ext<19, 16, 25, 0, 1, (outs), (ins),
                               "bdnzlrl+", BrB, []>;
    def BDZLRLm : XLForm_2_ext<19, 16, 26, 0, 1, (outs), (ins),
                               "bdzlrl-", BrB, []>;
    def BDNZLRLm: XLForm_2_ext<19, 16, 24, 0, 1, (outs), (ins),
                               "bdnzlrl-", BrB, []>;
  }
}

let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1, Uses = [RM] in
def TCRETURNdi :Pseudo< (outs),
                        (ins calltarget:$dst, i32imm:$offset),
                 "#TC_RETURNd $dst $offset",
                 []>;


let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1, Uses = [RM] in
def TCRETURNai :Pseudo<(outs), (ins abscalltarget:$func, i32imm:$offset),
                 "#TC_RETURNa $func $offset",
                 [(PPCtc_return (i32 imm:$func), imm:$offset)]>;

let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1, Uses = [RM] in
def TCRETURNri : Pseudo<(outs), (ins CTRRC:$dst, i32imm:$offset),
                 "#TC_RETURNr $dst $offset",
                 []>;


let isCodeGenOnly = 1 in {

let isTerminator = 1, isBarrier = 1, PPC970_Unit = 7, isBranch = 1,
    isIndirectBranch = 1, isCall = 1, isReturn = 1, Uses = [CTR, RM]  in
def TAILBCTR : XLForm_2_ext<19, 528, 20, 0, 0, (outs), (ins), "bctr", BrB, []>,
     Requires<[In32BitMode]>;

let isBranch = 1, isTerminator = 1, hasCtrlDep = 1, PPC970_Unit = 7,
    isBarrier = 1, isCall = 1, isReturn = 1, Uses = [RM] in
def TAILB   : IForm<18, 0, 0, (outs), (ins calltarget:$dst),
                  "b $dst", BrB,
                  []>;

let isBranch = 1, isTerminator = 1, hasCtrlDep = 1, PPC970_Unit = 7,
    isBarrier = 1, isCall = 1, isReturn = 1, Uses = [RM] in
def TAILBA   : IForm<18, 0, 0, (outs), (ins abscalltarget:$dst),
                  "ba $dst", BrB,
                  []>;

}

let hasSideEffects = 1, isBarrier = 1, usesCustomInserter = 1 in {
  def EH_SjLj_SetJmp32  : Pseudo<(outs gprc:$dst), (ins memr:$buf),
                            "#EH_SJLJ_SETJMP32",
                            [(set i32:$dst, (PPCeh_sjlj_setjmp addr:$buf))]>,
                          Requires<[In32BitMode]>;
  let isTerminator = 1 in
  def EH_SjLj_LongJmp32 : Pseudo<(outs), (ins memr:$buf),
                            "#EH_SJLJ_LONGJMP32",
                            [(PPCeh_sjlj_longjmp addr:$buf)]>,
                          Requires<[In32BitMode]>;
}

let isBranch = 1, isTerminator = 1 in {
  def EH_SjLj_Setup : Pseudo<(outs), (ins directbrtarget:$dst),
                        "#EH_SjLj_Setup\t$dst", []>;
}

// System call.
let PPC970_Unit = 7 in {
  def SC     : SCForm<17, 1, (outs), (ins i32imm:$lev),
                      "sc $lev", BrB, [(PPCsc (i32 imm:$lev))]>;
}

// DCB* instructions.
def DCBA   : DCB_Form<758, 0, (outs), (ins memrr:$dst),
                      "dcba $dst", LdStDCBF, [(int_ppc_dcba xoaddr:$dst)]>,
                      PPC970_DGroup_Single;
def DCBF   : DCB_Form<86, 0, (outs), (ins memrr:$dst),
                      "dcbf $dst", LdStDCBF, [(int_ppc_dcbf xoaddr:$dst)]>,
                      PPC970_DGroup_Single;
def DCBI   : DCB_Form<470, 0, (outs), (ins memrr:$dst),
                      "dcbi $dst", LdStDCBF, [(int_ppc_dcbi xoaddr:$dst)]>,
                      PPC970_DGroup_Single;
def DCBST  : DCB_Form<54, 0, (outs), (ins memrr:$dst),
                      "dcbst $dst", LdStDCBF, [(int_ppc_dcbst xoaddr:$dst)]>,
                      PPC970_DGroup_Single;
def DCBT   : DCB_Form<278, 0, (outs), (ins memrr:$dst),
                      "dcbt $dst", LdStDCBF, [(int_ppc_dcbt xoaddr:$dst)]>,
                      PPC970_DGroup_Single;
def DCBTST : DCB_Form<246, 0, (outs), (ins memrr:$dst),
                      "dcbtst $dst", LdStDCBF, [(int_ppc_dcbtst xoaddr:$dst)]>,
                      PPC970_DGroup_Single;
def DCBZ   : DCB_Form<1014, 0, (outs), (ins memrr:$dst),
                      "dcbz $dst", LdStDCBF, [(int_ppc_dcbz xoaddr:$dst)]>,
                      PPC970_DGroup_Single;
def DCBZL  : DCB_Form<1014, 1, (outs), (ins memrr:$dst),
                      "dcbzl $dst", LdStDCBF, [(int_ppc_dcbzl xoaddr:$dst)]>,
                      PPC970_DGroup_Single;

def : Pat<(prefetch xoaddr:$dst, (i32 0), imm, (i32 1)),
          (DCBT xoaddr:$dst)>;

// Atomic operations
let usesCustomInserter = 1 in {
  let Defs = [CR0] in {
    def ATOMIC_LOAD_ADD_I8 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_ADD_I8",
      [(set i32:$dst, (atomic_load_add_8 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_SUB_I8 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_SUB_I8",
      [(set i32:$dst, (atomic_load_sub_8 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_AND_I8 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_AND_I8",
      [(set i32:$dst, (atomic_load_and_8 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_OR_I8 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_OR_I8",
      [(set i32:$dst, (atomic_load_or_8 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_XOR_I8 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "ATOMIC_LOAD_XOR_I8",
      [(set i32:$dst, (atomic_load_xor_8 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_NAND_I8 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_NAND_I8",
      [(set i32:$dst, (atomic_load_nand_8 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_ADD_I16 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_ADD_I16",
      [(set i32:$dst, (atomic_load_add_16 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_SUB_I16 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_SUB_I16",
      [(set i32:$dst, (atomic_load_sub_16 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_AND_I16 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_AND_I16",
      [(set i32:$dst, (atomic_load_and_16 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_OR_I16 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_OR_I16",
      [(set i32:$dst, (atomic_load_or_16 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_XOR_I16 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_XOR_I16",
      [(set i32:$dst, (atomic_load_xor_16 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_NAND_I16 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_NAND_I16",
      [(set i32:$dst, (atomic_load_nand_16 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_ADD_I32 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_ADD_I32",
      [(set i32:$dst, (atomic_load_add_32 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_SUB_I32 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_SUB_I32",
      [(set i32:$dst, (atomic_load_sub_32 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_AND_I32 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_AND_I32",
      [(set i32:$dst, (atomic_load_and_32 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_OR_I32 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_OR_I32",
      [(set i32:$dst, (atomic_load_or_32 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_XOR_I32 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_XOR_I32",
      [(set i32:$dst, (atomic_load_xor_32 xoaddr:$ptr, i32:$incr))]>;
    def ATOMIC_LOAD_NAND_I32 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$incr), "#ATOMIC_LOAD_NAND_I32",
      [(set i32:$dst, (atomic_load_nand_32 xoaddr:$ptr, i32:$incr))]>;

    def ATOMIC_CMP_SWAP_I8 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$old, gprc:$new), "#ATOMIC_CMP_SWAP_I8",
      [(set i32:$dst, (atomic_cmp_swap_8 xoaddr:$ptr, i32:$old, i32:$new))]>;
    def ATOMIC_CMP_SWAP_I16 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$old, gprc:$new), "#ATOMIC_CMP_SWAP_I16 $dst $ptr $old $new",
      [(set i32:$dst, (atomic_cmp_swap_16 xoaddr:$ptr, i32:$old, i32:$new))]>;
    def ATOMIC_CMP_SWAP_I32 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$old, gprc:$new), "#ATOMIC_CMP_SWAP_I32 $dst $ptr $old $new",
      [(set i32:$dst, (atomic_cmp_swap_32 xoaddr:$ptr, i32:$old, i32:$new))]>;

    def ATOMIC_SWAP_I8 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$new), "#ATOMIC_SWAP_i8",
      [(set i32:$dst, (atomic_swap_8 xoaddr:$ptr, i32:$new))]>;
    def ATOMIC_SWAP_I16 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$new), "#ATOMIC_SWAP_I16",
      [(set i32:$dst, (atomic_swap_16 xoaddr:$ptr, i32:$new))]>;
    def ATOMIC_SWAP_I32 : Pseudo<
      (outs gprc:$dst), (ins memrr:$ptr, gprc:$new), "#ATOMIC_SWAP_I32",
      [(set i32:$dst, (atomic_swap_32 xoaddr:$ptr, i32:$new))]>;
  }
}

// Instructions to support atomic operations
def LWARX : XForm_1<31,  20, (outs gprc:$rD), (ins memrr:$src),
                   "lwarx $rD, $src", LdStLWARX,
                   [(set i32:$rD, (PPClarx xoaddr:$src))]>;

let Defs = [CR0] in
def STWCX : XForm_1<31, 150, (outs), (ins gprc:$rS, memrr:$dst),
                   "stwcx. $rS, $dst", LdStSTWCX,
                   [(PPCstcx i32:$rS, xoaddr:$dst)]>,
                   isDOT;

let isTerminator = 1, isBarrier = 1, hasCtrlDep = 1 in
def TRAP  : XForm_24<31, 4, (outs), (ins), "trap", LdStLoad, [(trap)]>;

def TWI : DForm_base<3, (outs), (ins u5imm:$to, gprc:$rA, s16imm:$imm),
                     "twi $to, $rA, $imm", IntTrapW, []>;
def TW : XForm_1<31, 4, (outs), (ins u5imm:$to, gprc:$rA, gprc:$rB),
                 "tw $to, $rA, $rB", IntTrapW, []>;
def TDI : DForm_base<2, (outs), (ins u5imm:$to, g8rc:$rA, s16imm:$imm),
                     "tdi $to, $rA, $imm", IntTrapD, []>;
def TD : XForm_1<31, 68, (outs), (ins u5imm:$to, g8rc:$rA, g8rc:$rB),
                 "td $to, $rA, $rB", IntTrapD, []>;

//===----------------------------------------------------------------------===//
// PPC32 Load Instructions.
//

// Unindexed (r+i) Loads. 
let canFoldAsLoad = 1, PPC970_Unit = 2 in {
def LBZ : DForm_1<34, (outs gprc:$rD), (ins memri:$src),
                  "lbz $rD, $src", LdStLoad,
                  [(set i32:$rD, (zextloadi8 iaddr:$src))]>;
def LHA : DForm_1<42, (outs gprc:$rD), (ins memri:$src),
                  "lha $rD, $src", LdStLHA,
                  [(set i32:$rD, (sextloadi16 iaddr:$src))]>,
                  PPC970_DGroup_Cracked;
def LHZ : DForm_1<40, (outs gprc:$rD), (ins memri:$src),
                  "lhz $rD, $src", LdStLoad,
                  [(set i32:$rD, (zextloadi16 iaddr:$src))]>;
def LWZ : DForm_1<32, (outs gprc:$rD), (ins memri:$src),
                  "lwz $rD, $src", LdStLoad,
                  [(set i32:$rD, (load iaddr:$src))]>;

def LFS : DForm_1<48, (outs f4rc:$rD), (ins memri:$src),
                  "lfs $rD, $src", LdStLFD,
                  [(set f32:$rD, (load iaddr:$src))]>;
def LFD : DForm_1<50, (outs f8rc:$rD), (ins memri:$src),
                  "lfd $rD, $src", LdStLFD,
                  [(set f64:$rD, (load iaddr:$src))]>;


// Unindexed (r+i) Loads with Update (preinc).
let mayLoad = 1, neverHasSideEffects = 1 in {
def LBZU : DForm_1<35, (outs gprc:$rD, ptr_rc_nor0:$ea_result), (ins memri:$addr),
                   "lbzu $rD, $addr", LdStLoadUpd,
                   []>, RegConstraint<"$addr.reg = $ea_result">,
                   NoEncode<"$ea_result">;

def LHAU : DForm_1<43, (outs gprc:$rD, ptr_rc_nor0:$ea_result), (ins memri:$addr),
                   "lhau $rD, $addr", LdStLHAU,
                   []>, RegConstraint<"$addr.reg = $ea_result">,
                   NoEncode<"$ea_result">;

def LHZU : DForm_1<41, (outs gprc:$rD, ptr_rc_nor0:$ea_result), (ins memri:$addr),
                   "lhzu $rD, $addr", LdStLoadUpd,
                   []>, RegConstraint<"$addr.reg = $ea_result">,
                   NoEncode<"$ea_result">;

def LWZU : DForm_1<33, (outs gprc:$rD, ptr_rc_nor0:$ea_result), (ins memri:$addr),
                   "lwzu $rD, $addr", LdStLoadUpd,
                   []>, RegConstraint<"$addr.reg = $ea_result">,
                   NoEncode<"$ea_result">;

def LFSU : DForm_1<49, (outs f4rc:$rD, ptr_rc_nor0:$ea_result), (ins memri:$addr),
                  "lfsu $rD, $addr", LdStLFDU,
                  []>, RegConstraint<"$addr.reg = $ea_result">,
                   NoEncode<"$ea_result">;

def LFDU : DForm_1<51, (outs f8rc:$rD, ptr_rc_nor0:$ea_result), (ins memri:$addr),
                  "lfdu $rD, $addr", LdStLFDU,
                  []>, RegConstraint<"$addr.reg = $ea_result">,
                   NoEncode<"$ea_result">;


// Indexed (r+r) Loads with Update (preinc).
def LBZUX : XForm_1<31, 119, (outs gprc:$rD, ptr_rc_nor0:$ea_result),
                   (ins memrr:$addr),
                   "lbzux $rD, $addr", LdStLoadUpd,
                   []>, RegConstraint<"$addr.ptrreg = $ea_result">,
                   NoEncode<"$ea_result">;

def LHAUX : XForm_1<31, 375, (outs gprc:$rD, ptr_rc_nor0:$ea_result),
                   (ins memrr:$addr),
                   "lhaux $rD, $addr", LdStLHAU,
                   []>, RegConstraint<"$addr.ptrreg = $ea_result">,
                   NoEncode<"$ea_result">;

def LHZUX : XForm_1<31, 311, (outs gprc:$rD, ptr_rc_nor0:$ea_result),
                   (ins memrr:$addr),
                   "lhzux $rD, $addr", LdStLoadUpd,
                   []>, RegConstraint<"$addr.ptrreg = $ea_result">,
                   NoEncode<"$ea_result">;

def LWZUX : XForm_1<31, 55, (outs gprc:$rD, ptr_rc_nor0:$ea_result),
                   (ins memrr:$addr),
                   "lwzux $rD, $addr", LdStLoadUpd,
                   []>, RegConstraint<"$addr.ptrreg = $ea_result">,
                   NoEncode<"$ea_result">;

def LFSUX : XForm_1<31, 567, (outs f4rc:$rD, ptr_rc_nor0:$ea_result),
                   (ins memrr:$addr),
                   "lfsux $rD, $addr", LdStLFDU,
                   []>, RegConstraint<"$addr.ptrreg = $ea_result">,
                   NoEncode<"$ea_result">;

def LFDUX : XForm_1<31, 631, (outs f8rc:$rD, ptr_rc_nor0:$ea_result),
                   (ins memrr:$addr),
                   "lfdux $rD, $addr", LdStLFDU,
                   []>, RegConstraint<"$addr.ptrreg = $ea_result">,
                   NoEncode<"$ea_result">;
}
}

// Indexed (r+r) Loads.
//
let canFoldAsLoad = 1, PPC970_Unit = 2 in {
def LBZX : XForm_1<31,  87, (outs gprc:$rD), (ins memrr:$src),
                   "lbzx $rD, $src", LdStLoad,
                   [(set i32:$rD, (zextloadi8 xaddr:$src))]>;
def LHAX : XForm_1<31, 343, (outs gprc:$rD), (ins memrr:$src),
                   "lhax $rD, $src", LdStLHA,
                   [(set i32:$rD, (sextloadi16 xaddr:$src))]>,
                   PPC970_DGroup_Cracked;
def LHZX : XForm_1<31, 279, (outs gprc:$rD), (ins memrr:$src),
                   "lhzx $rD, $src", LdStLoad,
                   [(set i32:$rD, (zextloadi16 xaddr:$src))]>;
def LWZX : XForm_1<31,  23, (outs gprc:$rD), (ins memrr:$src),
                   "lwzx $rD, $src", LdStLoad,
                   [(set i32:$rD, (load xaddr:$src))]>;
                   
                   
def LHBRX : XForm_1<31, 790, (outs gprc:$rD), (ins memrr:$src),
                   "lhbrx $rD, $src", LdStLoad,
                   [(set i32:$rD, (PPClbrx xoaddr:$src, i16))]>;
def LWBRX : XForm_1<31,  534, (outs gprc:$rD), (ins memrr:$src),
                   "lwbrx $rD, $src", LdStLoad,
                   [(set i32:$rD, (PPClbrx xoaddr:$src, i32))]>;

def LFSX   : XForm_25<31, 535, (outs f4rc:$frD), (ins memrr:$src),
                      "lfsx $frD, $src", LdStLFD,
                      [(set f32:$frD, (load xaddr:$src))]>;
def LFDX   : XForm_25<31, 599, (outs f8rc:$frD), (ins memrr:$src),
                      "lfdx $frD, $src", LdStLFD,
                      [(set f64:$frD, (load xaddr:$src))]>;

def LFIWAX : XForm_25<31, 855, (outs f8rc:$frD), (ins memrr:$src),
                      "lfiwax $frD, $src", LdStLFD,
                      [(set f64:$frD, (PPClfiwax xoaddr:$src))]>;
def LFIWZX : XForm_25<31, 887, (outs f8rc:$frD), (ins memrr:$src),
                      "lfiwzx $frD, $src", LdStLFD,
                      [(set f64:$frD, (PPClfiwzx xoaddr:$src))]>;
}

// Load Multiple
def LMW : DForm_1<46, (outs gprc:$rD), (ins memri:$src),
                  "lmw $rD, $src", LdStLMW, []>;

//===----------------------------------------------------------------------===//
// PPC32 Store Instructions.
//

// Unindexed (r+i) Stores.
let PPC970_Unit = 2 in {
def STB  : DForm_1<38, (outs), (ins gprc:$rS, memri:$src),
                   "stb $rS, $src", LdStStore,
                   [(truncstorei8 i32:$rS, iaddr:$src)]>;
def STH  : DForm_1<44, (outs), (ins gprc:$rS, memri:$src),
                   "sth $rS, $src", LdStStore,
                   [(truncstorei16 i32:$rS, iaddr:$src)]>;
def STW  : DForm_1<36, (outs), (ins gprc:$rS, memri:$src),
                   "stw $rS, $src", LdStStore,
                   [(store i32:$rS, iaddr:$src)]>;
def STFS : DForm_1<52, (outs), (ins f4rc:$rS, memri:$dst),
                   "stfs $rS, $dst", LdStSTFD,
                   [(store f32:$rS, iaddr:$dst)]>;
def STFD : DForm_1<54, (outs), (ins f8rc:$rS, memri:$dst),
                   "stfd $rS, $dst", LdStSTFD,
                   [(store f64:$rS, iaddr:$dst)]>;
}

// Unindexed (r+i) Stores with Update (preinc).
let PPC970_Unit = 2, mayStore = 1 in {
def STBU  : DForm_1<39, (outs ptr_rc_nor0:$ea_res), (ins gprc:$rS, memri:$dst),
                    "stbu $rS, $dst", LdStStoreUpd, []>,
                    RegConstraint<"$dst.reg = $ea_res">, NoEncode<"$ea_res">;
def STHU  : DForm_1<45, (outs ptr_rc_nor0:$ea_res), (ins gprc:$rS, memri:$dst),
                    "sthu $rS, $dst", LdStStoreUpd, []>,
                    RegConstraint<"$dst.reg = $ea_res">, NoEncode<"$ea_res">;
def STWU  : DForm_1<37, (outs ptr_rc_nor0:$ea_res), (ins gprc:$rS, memri:$dst),
                    "stwu $rS, $dst", LdStStoreUpd, []>,
                    RegConstraint<"$dst.reg = $ea_res">, NoEncode<"$ea_res">;
def STFSU : DForm_1<53, (outs ptr_rc_nor0:$ea_res), (ins f4rc:$rS, memri:$dst),
                    "stfsu $rS, $dst", LdStSTFDU, []>,
                    RegConstraint<"$dst.reg = $ea_res">, NoEncode<"$ea_res">;
def STFDU : DForm_1<55, (outs ptr_rc_nor0:$ea_res), (ins f8rc:$rS, memri:$dst),
                    "stfdu $rS, $dst", LdStSTFDU, []>,
                    RegConstraint<"$dst.reg = $ea_res">, NoEncode<"$ea_res">;
}

// Patterns to match the pre-inc stores.  We can't put the patterns on
// the instruction definitions directly as ISel wants the address base
// and offset to be separate operands, not a single complex operand.
def : Pat<(pre_truncsti8 i32:$rS, iPTR:$ptrreg, iaddroff:$ptroff),
          (STBU $rS, iaddroff:$ptroff, $ptrreg)>;
def : Pat<(pre_truncsti16 i32:$rS, iPTR:$ptrreg, iaddroff:$ptroff),
          (STHU $rS, iaddroff:$ptroff, $ptrreg)>;
def : Pat<(pre_store i32:$rS, iPTR:$ptrreg, iaddroff:$ptroff),
          (STWU $rS, iaddroff:$ptroff, $ptrreg)>;
def : Pat<(pre_store f32:$rS, iPTR:$ptrreg, iaddroff:$ptroff),
          (STFSU $rS, iaddroff:$ptroff, $ptrreg)>;
def : Pat<(pre_store f64:$rS, iPTR:$ptrreg, iaddroff:$ptroff),
          (STFDU $rS, iaddroff:$ptroff, $ptrreg)>;

// Indexed (r+r) Stores.
let PPC970_Unit = 2 in {
def STBX  : XForm_8<31, 215, (outs), (ins gprc:$rS, memrr:$dst),
                   "stbx $rS, $dst", LdStStore,
                   [(truncstorei8 i32:$rS, xaddr:$dst)]>,
                   PPC970_DGroup_Cracked;
def STHX  : XForm_8<31, 407, (outs), (ins gprc:$rS, memrr:$dst),
                   "sthx $rS, $dst", LdStStore,
                   [(truncstorei16 i32:$rS, xaddr:$dst)]>,
                   PPC970_DGroup_Cracked;
def STWX  : XForm_8<31, 151, (outs), (ins gprc:$rS, memrr:$dst),
                   "stwx $rS, $dst", LdStStore,
                   [(store i32:$rS, xaddr:$dst)]>,
                   PPC970_DGroup_Cracked;
 
def STHBRX: XForm_8<31, 918, (outs), (ins gprc:$rS, memrr:$dst),
                   "sthbrx $rS, $dst", LdStStore,
                   [(PPCstbrx i32:$rS, xoaddr:$dst, i16)]>,
                   PPC970_DGroup_Cracked;
def STWBRX: XForm_8<31, 662, (outs), (ins gprc:$rS, memrr:$dst),
                   "stwbrx $rS, $dst", LdStStore,
                   [(PPCstbrx i32:$rS, xoaddr:$dst, i32)]>,
                   PPC970_DGroup_Cracked;

def STFIWX: XForm_28<31, 983, (outs), (ins f8rc:$frS, memrr:$dst),
                     "stfiwx $frS, $dst", LdStSTFD,
                     [(PPCstfiwx f64:$frS, xoaddr:$dst)]>;
                     
def STFSX : XForm_28<31, 663, (outs), (ins f4rc:$frS, memrr:$dst),
                     "stfsx $frS, $dst", LdStSTFD,
                     [(store f32:$frS, xaddr:$dst)]>;
def STFDX : XForm_28<31, 727, (outs), (ins f8rc:$frS, memrr:$dst),
                     "stfdx $frS, $dst", LdStSTFD,
                     [(store f64:$frS, xaddr:$dst)]>;
}

// Indexed (r+r) Stores with Update (preinc).
let PPC970_Unit = 2, mayStore = 1 in {
def STBUX : XForm_8<31, 247, (outs ptr_rc_nor0:$ea_res), (ins gprc:$rS, memrr:$dst),
                    "stbux $rS, $dst", LdStStoreUpd, []>,
                    RegConstraint<"$dst.ptrreg = $ea_res">, NoEncode<"$ea_res">,
                    PPC970_DGroup_Cracked;
def STHUX : XForm_8<31, 439, (outs ptr_rc_nor0:$ea_res), (ins gprc:$rS, memrr:$dst),
                    "sthux $rS, $dst", LdStStoreUpd, []>,
                    RegConstraint<"$dst.ptrreg = $ea_res">, NoEncode<"$ea_res">,
                    PPC970_DGroup_Cracked;
def STWUX : XForm_8<31, 183, (outs ptr_rc_nor0:$ea_res), (ins gprc:$rS, memrr:$dst),
                    "stwux $rS, $dst", LdStStoreUpd, []>,
                    RegConstraint<"$dst.ptrreg = $ea_res">, NoEncode<"$ea_res">,
                    PPC970_DGroup_Cracked;
def STFSUX: XForm_8<31, 695, (outs ptr_rc_nor0:$ea_res), (ins f4rc:$rS, memrr:$dst),
                    "stfsux $rS, $dst", LdStSTFDU, []>,
                    RegConstraint<"$dst.ptrreg = $ea_res">, NoEncode<"$ea_res">,
                    PPC970_DGroup_Cracked;
def STFDUX: XForm_8<31, 759, (outs ptr_rc_nor0:$ea_res), (ins f8rc:$rS, memrr:$dst),
                    "stfdux $rS, $dst", LdStSTFDU, []>,
                    RegConstraint<"$dst.ptrreg = $ea_res">, NoEncode<"$ea_res">,
                    PPC970_DGroup_Cracked;
}

// Patterns to match the pre-inc stores.  We can't put the patterns on
// the instruction definitions directly as ISel wants the address base
// and offset to be separate operands, not a single complex operand.
def : Pat<(pre_truncsti8 i32:$rS, iPTR:$ptrreg, iPTR:$ptroff),
          (STBUX $rS, $ptrreg, $ptroff)>;
def : Pat<(pre_truncsti16 i32:$rS, iPTR:$ptrreg, iPTR:$ptroff),
          (STHUX $rS, $ptrreg, $ptroff)>;
def : Pat<(pre_store i32:$rS, iPTR:$ptrreg, iPTR:$ptroff),
          (STWUX $rS, $ptrreg, $ptroff)>;
def : Pat<(pre_store f32:$rS, iPTR:$ptrreg, iPTR:$ptroff),
          (STFSUX $rS, $ptrreg, $ptroff)>;
def : Pat<(pre_store f64:$rS, iPTR:$ptrreg, iPTR:$ptroff),
          (STFDUX $rS, $ptrreg, $ptroff)>;

// Store Multiple
def STMW : DForm_1<47, (outs), (ins gprc:$rS, memri:$dst),
                   "stmw $rS, $dst", LdStLMW, []>;

def SYNC : XForm_24_sync<31, 598, (outs), (ins i32imm:$L),
                        "sync $L", LdStSync, []>;
def : Pat<(int_ppc_sync), (SYNC 0)>;

//===----------------------------------------------------------------------===//
// PPC32 Arithmetic Instructions.
//

let PPC970_Unit = 1 in {  // FXU Operations.
def ADDI   : DForm_2<14, (outs gprc:$rD), (ins gprc_nor0:$rA, s16imm:$imm),
                     "addi $rD, $rA, $imm", IntSimple,
                     [(set i32:$rD, (add i32:$rA, imm32SExt16:$imm))]>;
let BaseName = "addic" in {
let Defs = [CARRY] in
def ADDIC  : DForm_2<12, (outs gprc:$rD), (ins gprc:$rA, s16imm:$imm),
                     "addic $rD, $rA, $imm", IntGeneral,
                     [(set i32:$rD, (addc i32:$rA, imm32SExt16:$imm))]>,
                     RecFormRel, PPC970_DGroup_Cracked;
let Defs = [CARRY, CR0] in
def ADDICo : DForm_2<13, (outs gprc:$rD), (ins gprc:$rA, s16imm:$imm),
                     "addic. $rD, $rA, $imm", IntGeneral,
                     []>, isDOT, RecFormRel;
}
def ADDIS  : DForm_2<15, (outs gprc:$rD), (ins gprc_nor0:$rA, s17imm:$imm),
                     "addis $rD, $rA, $imm", IntSimple,
                     [(set i32:$rD, (add i32:$rA, imm16ShiftedSExt:$imm))]>;
let isCodeGenOnly = 1 in
def LA     : DForm_2<14, (outs gprc:$rD), (ins gprc_nor0:$rA, s16imm:$sym),
                     "la $rD, $sym($rA)", IntGeneral,
                     [(set i32:$rD, (add i32:$rA,
                                          (PPClo tglobaladdr:$sym, 0)))]>;
def MULLI  : DForm_2< 7, (outs gprc:$rD), (ins gprc:$rA, s16imm:$imm),
                     "mulli $rD, $rA, $imm", IntMulLI,
                     [(set i32:$rD, (mul i32:$rA, imm32SExt16:$imm))]>;
let Defs = [CARRY] in
def SUBFIC : DForm_2< 8, (outs gprc:$rD), (ins gprc:$rA, s16imm:$imm),
                     "subfic $rD, $rA, $imm", IntGeneral,
                     [(set i32:$rD, (subc imm32SExt16:$imm, i32:$rA))]>;

let isReMaterializable = 1, isAsCheapAsAMove = 1, isMoveImm = 1 in {
  def LI  : DForm_2_r0<14, (outs gprc:$rD), (ins s16imm:$imm),
                       "li $rD, $imm", IntSimple,
                       [(set i32:$rD, imm32SExt16:$imm)]>;
  def LIS : DForm_2_r0<15, (outs gprc:$rD), (ins s17imm:$imm),
                       "lis $rD, $imm", IntSimple,
                       [(set i32:$rD, imm16ShiftedSExt:$imm)]>;
}
}

let PPC970_Unit = 1 in {  // FXU Operations.
let Defs = [CR0] in {
def ANDIo : DForm_4<28, (outs gprc:$dst), (ins gprc:$src1, u16imm:$src2),
                    "andi. $dst, $src1, $src2", IntGeneral,
                    [(set i32:$dst, (and i32:$src1, immZExt16:$src2))]>,
                    isDOT;
def ANDISo : DForm_4<29, (outs gprc:$dst), (ins gprc:$src1, u16imm:$src2),
                    "andis. $dst, $src1, $src2", IntGeneral,
                    [(set i32:$dst, (and i32:$src1, imm16ShiftedZExt:$src2))]>,
                    isDOT;
}
def ORI   : DForm_4<24, (outs gprc:$dst), (ins gprc:$src1, u16imm:$src2),
                    "ori $dst, $src1, $src2", IntSimple,
                    [(set i32:$dst, (or i32:$src1, immZExt16:$src2))]>;
def ORIS  : DForm_4<25, (outs gprc:$dst), (ins gprc:$src1, u16imm:$src2),
                    "oris $dst, $src1, $src2", IntSimple,
                    [(set i32:$dst, (or i32:$src1, imm16ShiftedZExt:$src2))]>;
def XORI  : DForm_4<26, (outs gprc:$dst), (ins gprc:$src1, u16imm:$src2),
                    "xori $dst, $src1, $src2", IntSimple,
                    [(set i32:$dst, (xor i32:$src1, immZExt16:$src2))]>;
def XORIS : DForm_4<27, (outs gprc:$dst), (ins gprc:$src1, u16imm:$src2),
                    "xoris $dst, $src1, $src2", IntSimple,
                    [(set i32:$dst, (xor i32:$src1, imm16ShiftedZExt:$src2))]>;
def NOP   : DForm_4_zero<24, (outs), (ins), "nop", IntSimple,
                         []>;
let isCompare = 1, neverHasSideEffects = 1 in {
  def CMPWI : DForm_5_ext<11, (outs crrc:$crD), (ins gprc:$rA, s16imm:$imm),
                          "cmpwi $crD, $rA, $imm", IntCompare>;
  def CMPLWI : DForm_6_ext<10, (outs crrc:$dst), (ins gprc:$src1, u16imm:$src2),
                           "cmplwi $dst, $src1, $src2", IntCompare>;
}
}

let PPC970_Unit = 1, neverHasSideEffects = 1 in {  // FXU Operations.
defm NAND : XForm_6r<31, 476, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                     "nand", "$rA, $rS, $rB", IntSimple,
                     [(set i32:$rA, (not (and i32:$rS, i32:$rB)))]>;
defm AND  : XForm_6r<31,  28, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                     "and", "$rA, $rS, $rB", IntSimple,
                     [(set i32:$rA, (and i32:$rS, i32:$rB))]>;
defm ANDC : XForm_6r<31,  60, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                     "andc", "$rA, $rS, $rB", IntSimple,
                     [(set i32:$rA, (and i32:$rS, (not i32:$rB)))]>;
defm OR   : XForm_6r<31, 444, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                     "or", "$rA, $rS, $rB", IntSimple,
                     [(set i32:$rA, (or i32:$rS, i32:$rB))]>;
defm NOR  : XForm_6r<31, 124, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                     "nor", "$rA, $rS, $rB", IntSimple,
                     [(set i32:$rA, (not (or i32:$rS, i32:$rB)))]>;
defm ORC  : XForm_6r<31, 412, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                     "orc", "$rA, $rS, $rB", IntSimple,
                     [(set i32:$rA, (or i32:$rS, (not i32:$rB)))]>;
defm EQV  : XForm_6r<31, 284, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                     "eqv", "$rA, $rS, $rB", IntSimple,
                     [(set i32:$rA, (not (xor i32:$rS, i32:$rB)))]>;
defm XOR  : XForm_6r<31, 316, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                     "xor", "$rA, $rS, $rB", IntSimple,
                     [(set i32:$rA, (xor i32:$rS, i32:$rB))]>;
defm SLW  : XForm_6r<31,  24, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                     "slw", "$rA, $rS, $rB", IntGeneral,
                     [(set i32:$rA, (PPCshl i32:$rS, i32:$rB))]>;
defm SRW  : XForm_6r<31, 536, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                     "srw", "$rA, $rS, $rB", IntGeneral,
                     [(set i32:$rA, (PPCsrl i32:$rS, i32:$rB))]>;
defm SRAW : XForm_6rc<31, 792, (outs gprc:$rA), (ins gprc:$rS, gprc:$rB),
                      "sraw", "$rA, $rS, $rB", IntShift,
                      [(set i32:$rA, (PPCsra i32:$rS, i32:$rB))]>;
}

let PPC970_Unit = 1 in {  // FXU Operations.
let neverHasSideEffects = 1 in {
defm SRAWI : XForm_10rc<31, 824, (outs gprc:$rA), (ins gprc:$rS, u5imm:$SH),
                        "srawi", "$rA, $rS, $SH", IntShift,
                        [(set i32:$rA, (sra i32:$rS, (i32 imm:$SH)))]>;
defm CNTLZW : XForm_11r<31,  26, (outs gprc:$rA), (ins gprc:$rS),
                        "cntlzw", "$rA, $rS", IntGeneral,
                        [(set i32:$rA, (ctlz i32:$rS))]>;
defm EXTSB  : XForm_11r<31, 954, (outs gprc:$rA), (ins gprc:$rS),
                        "extsb", "$rA, $rS", IntSimple,
                        [(set i32:$rA, (sext_inreg i32:$rS, i8))]>;
defm EXTSH  : XForm_11r<31, 922, (outs gprc:$rA), (ins gprc:$rS),
                        "extsh", "$rA, $rS", IntSimple,
                        [(set i32:$rA, (sext_inreg i32:$rS, i16))]>;
}
let isCompare = 1, neverHasSideEffects = 1 in {
  def CMPW   : XForm_16_ext<31, 0, (outs crrc:$crD), (ins gprc:$rA, gprc:$rB),
                            "cmpw $crD, $rA, $rB", IntCompare>;
  def CMPLW  : XForm_16_ext<31, 32, (outs crrc:$crD), (ins gprc:$rA, gprc:$rB),
                            "cmplw $crD, $rA, $rB", IntCompare>;
}
}
let PPC970_Unit = 3 in {  // FPU Operations.
//def FCMPO  : XForm_17<63, 32, (outs CRRC:$crD), (ins FPRC:$fA, FPRC:$fB),
//                      "fcmpo $crD, $fA, $fB", FPCompare>;
let isCompare = 1, neverHasSideEffects = 1 in {
  def FCMPUS : XForm_17<63, 0, (outs crrc:$crD), (ins f4rc:$fA, f4rc:$fB),
                        "fcmpu $crD, $fA, $fB", FPCompare>;
  def FCMPUD : XForm_17<63, 0, (outs crrc:$crD), (ins f8rc:$fA, f8rc:$fB),
                        "fcmpu $crD, $fA, $fB", FPCompare>;
}

let Uses = [RM] in {
  let neverHasSideEffects = 1 in {
  defm FCTIWZ : XForm_26r<63, 15, (outs f8rc:$frD), (ins f8rc:$frB),
                          "fctiwz", "$frD, $frB", FPGeneral,
                          [(set f64:$frD, (PPCfctiwz f64:$frB))]>;

  defm FRSP   : XForm_26r<63, 12, (outs f4rc:$frD), (ins f8rc:$frB),
                          "frsp", "$frD, $frB", FPGeneral,
                          [(set f32:$frD, (fround f64:$frB))]>;

  // The frin -> nearbyint mapping is valid only in fast-math mode.
  let Interpretation64Bit = 1 in
  defm FRIND  : XForm_26r<63, 392, (outs f8rc:$frD), (ins f8rc:$frB),
                          "frin", "$frD, $frB", FPGeneral,
                          [(set f64:$frD, (fnearbyint f64:$frB))]>;
  defm FRINS  : XForm_26r<63, 392, (outs f4rc:$frD), (ins f4rc:$frB),
                          "frin", "$frD, $frB", FPGeneral,
                          [(set f32:$frD, (fnearbyint f32:$frB))]>;
  }

  // These pseudos expand to rint but also set FE_INEXACT when the result does
  // not equal the argument.
  let usesCustomInserter = 1, Defs = [RM] in { // FIXME: Model FPSCR!
    def FRINDrint : Pseudo<(outs f8rc:$frD), (ins f8rc:$frB),
                            "#FRINDrint", [(set f64:$frD, (frint f64:$frB))]>;
    def FRINSrint : Pseudo<(outs f4rc:$frD), (ins f4rc:$frB),
                            "#FRINSrint", [(set f32:$frD, (frint f32:$frB))]>;
  }

  let neverHasSideEffects = 1 in {
  let Interpretation64Bit = 1 in
  defm FRIPD  : XForm_26r<63, 456, (outs f8rc:$frD), (ins f8rc:$frB),
                          "frip", "$frD, $frB", FPGeneral,
                          [(set f64:$frD, (fceil f64:$frB))]>;
  defm FRIPS  : XForm_26r<63, 456, (outs f4rc:$frD), (ins f4rc:$frB),
                          "frip", "$frD, $frB", FPGeneral,
                          [(set f32:$frD, (fceil f32:$frB))]>;
  let Interpretation64Bit = 1 in
  defm FRIZD  : XForm_26r<63, 424, (outs f8rc:$frD), (ins f8rc:$frB),
                          "friz", "$frD, $frB", FPGeneral,
                          [(set f64:$frD, (ftrunc f64:$frB))]>;
  defm FRIZS  : XForm_26r<63, 424, (outs f4rc:$frD), (ins f4rc:$frB),
                          "friz", "$frD, $frB", FPGeneral,
                          [(set f32:$frD, (ftrunc f32:$frB))]>;
  let Interpretation64Bit = 1 in
  defm FRIMD  : XForm_26r<63, 488, (outs f8rc:$frD), (ins f8rc:$frB),
                          "frim", "$frD, $frB", FPGeneral,
                          [(set f64:$frD, (ffloor f64:$frB))]>;
  defm FRIMS  : XForm_26r<63, 488, (outs f4rc:$frD), (ins f4rc:$frB),
                          "frim", "$frD, $frB", FPGeneral,
                          [(set f32:$frD, (ffloor f32:$frB))]>;

  defm FSQRT  : XForm_26r<63, 22, (outs f8rc:$frD), (ins f8rc:$frB),
                          "fsqrt", "$frD, $frB", FPSqrt,
                          [(set f64:$frD, (fsqrt f64:$frB))]>;
  defm FSQRTS : XForm_26r<59, 22, (outs f4rc:$frD), (ins f4rc:$frB),
                          "fsqrts", "$frD, $frB", FPSqrt,
                          [(set f32:$frD, (fsqrt f32:$frB))]>;
  }
  }
}

/// Note that FMR is defined as pseudo-ops on the PPC970 because they are
/// often coalesced away and we don't want the dispatch group builder to think
/// that they will fill slots (which could cause the load of a LSU reject to
/// sneak into a d-group with a store).
let neverHasSideEffects = 1 in
defm FMR   : XForm_26r<63, 72, (outs f4rc:$frD), (ins f4rc:$frB),
                       "fmr", "$frD, $frB", FPGeneral,
                       []>,  // (set f32:$frD, f32:$frB)
                       PPC970_Unit_Pseudo;

let PPC970_Unit = 3, neverHasSideEffects = 1 in {  // FPU Operations.
// These are artificially split into two different forms, for 4/8 byte FP.
defm FABSS  : XForm_26r<63, 264, (outs f4rc:$frD), (ins f4rc:$frB),
                        "fabs", "$frD, $frB", FPGeneral,
                        [(set f32:$frD, (fabs f32:$frB))]>;
let Interpretation64Bit = 1 in
defm FABSD  : XForm_26r<63, 264, (outs f8rc:$frD), (ins f8rc:$frB),
                        "fabs", "$frD, $frB", FPGeneral,
                        [(set f64:$frD, (fabs f64:$frB))]>;
defm FNABSS : XForm_26r<63, 136, (outs f4rc:$frD), (ins f4rc:$frB),
                        "fnabs", "$frD, $frB", FPGeneral,
                        [(set f32:$frD, (fneg (fabs f32:$frB)))]>;
let Interpretation64Bit = 1 in
defm FNABSD : XForm_26r<63, 136, (outs f8rc:$frD), (ins f8rc:$frB),
                        "fnabs", "$frD, $frB", FPGeneral,
                        [(set f64:$frD, (fneg (fabs f64:$frB)))]>;
defm FNEGS  : XForm_26r<63, 40, (outs f4rc:$frD), (ins f4rc:$frB),
                        "fneg", "$frD, $frB", FPGeneral,
                        [(set f32:$frD, (fneg f32:$frB))]>;
let Interpretation64Bit = 1 in
defm FNEGD  : XForm_26r<63, 40, (outs f8rc:$frD), (ins f8rc:$frB),
                        "fneg", "$frD, $frB", FPGeneral,
                        [(set f64:$frD, (fneg f64:$frB))]>;

// Reciprocal estimates.
defm FRE      : XForm_26r<63, 24, (outs f8rc:$frD), (ins f8rc:$frB),
                          "fre", "$frD, $frB", FPGeneral,
                          [(set f64:$frD, (PPCfre f64:$frB))]>;
defm FRES     : XForm_26r<59, 24, (outs f4rc:$frD), (ins f4rc:$frB),
                          "fres", "$frD, $frB", FPGeneral,
                          [(set f32:$frD, (PPCfre f32:$frB))]>;
defm FRSQRTE  : XForm_26r<63, 26, (outs f8rc:$frD), (ins f8rc:$frB),
                          "frsqrte", "$frD, $frB", FPGeneral,
                          [(set f64:$frD, (PPCfrsqrte f64:$frB))]>;
defm FRSQRTES : XForm_26r<59, 26, (outs f4rc:$frD), (ins f4rc:$frB),
                          "frsqrtes", "$frD, $frB", FPGeneral,
                          [(set f32:$frD, (PPCfrsqrte f32:$frB))]>;
}

// XL-Form instructions.  condition register logical ops.
//
let neverHasSideEffects = 1 in
def MCRF   : XLForm_3<19, 0, (outs crrc:$BF), (ins crrc:$BFA),
                      "mcrf $BF, $BFA", BrMCR>,
             PPC970_DGroup_First, PPC970_Unit_CRU;

def CRAND  : XLForm_1<19, 257, (outs crbitrc:$CRD),
                               (ins crbitrc:$CRA, crbitrc:$CRB),
                      "crand $CRD, $CRA, $CRB", BrCR, []>;

def CRNAND : XLForm_1<19, 225, (outs crbitrc:$CRD),
                               (ins crbitrc:$CRA, crbitrc:$CRB),
                      "crnand $CRD, $CRA, $CRB", BrCR, []>;

def CROR   : XLForm_1<19, 449, (outs crbitrc:$CRD),
                               (ins crbitrc:$CRA, crbitrc:$CRB),
                      "cror $CRD, $CRA, $CRB", BrCR, []>;

def CRXOR  : XLForm_1<19, 193, (outs crbitrc:$CRD),
                               (ins crbitrc:$CRA, crbitrc:$CRB),
                      "crxor $CRD, $CRA, $CRB", BrCR, []>;

def CRNOR  : XLForm_1<19, 33, (outs crbitrc:$CRD),
                              (ins crbitrc:$CRA, crbitrc:$CRB),
                      "crnor $CRD, $CRA, $CRB", BrCR, []>;

def CREQV  : XLForm_1<19, 289, (outs crbitrc:$CRD),
                               (ins crbitrc:$CRA, crbitrc:$CRB),
                      "creqv $CRD, $CRA, $CRB", BrCR, []>;

def CRANDC : XLForm_1<19, 129, (outs crbitrc:$CRD),
                               (ins crbitrc:$CRA, crbitrc:$CRB),
                      "crandc $CRD, $CRA, $CRB", BrCR, []>;

def CRORC  : XLForm_1<19, 417, (outs crbitrc:$CRD),
                               (ins crbitrc:$CRA, crbitrc:$CRB),
                      "crorc $CRD, $CRA, $CRB", BrCR, []>;

let isCodeGenOnly = 1 in {
def CRSET  : XLForm_1_ext<19, 289, (outs crbitrc:$dst), (ins),
              "creqv $dst, $dst, $dst", BrCR,
              []>;

def CRUNSET: XLForm_1_ext<19, 193, (outs crbitrc:$dst), (ins),
              "crxor $dst, $dst, $dst", BrCR,
              []>;

let Defs = [CR1EQ], CRD = 6 in {
def CR6SET  : XLForm_1_ext<19, 289, (outs), (ins),
              "creqv 6, 6, 6", BrCR,
              [(PPCcr6set)]>;

def CR6UNSET: XLForm_1_ext<19, 193, (outs), (ins),
              "crxor 6, 6, 6", BrCR,
              [(PPCcr6unset)]>;
}
}

// XFX-Form instructions.  Instructions that deal with SPRs.
//

def MFSPR : XFXForm_1<31, 339, (outs gprc:$RT), (ins i32imm:$SPR),
                      "mfspr $RT, $SPR", SprMFSPR>;
def MTSPR : XFXForm_1<31, 467, (outs), (ins i32imm:$SPR, gprc:$RT),
                      "mtspr $SPR, $RT", SprMTSPR>;

def MFTB : XFXForm_1<31, 371, (outs gprc:$RT), (ins i32imm:$SPR),
                     "mftb $RT, $SPR", SprMFTB>;

let Uses = [CTR] in {
def MFCTR : XFXForm_1_ext<31, 339, 9, (outs gprc:$rT), (ins),
                          "mfctr $rT", SprMFSPR>,
            PPC970_DGroup_First, PPC970_Unit_FXU;
}
let Defs = [CTR], Pattern = [(PPCmtctr i32:$rS)] in {
def MTCTR : XFXForm_7_ext<31, 467, 9, (outs), (ins gprc:$rS),
                          "mtctr $rS", SprMTSPR>,
            PPC970_DGroup_First, PPC970_Unit_FXU;
}
let hasSideEffects = 1, isCodeGenOnly = 1, Defs = [CTR] in {
let Pattern = [(int_ppc_mtctr i32:$rS)] in
def MTCTRloop : XFXForm_7_ext<31, 467, 9, (outs), (ins gprc:$rS),
                              "mtctr $rS", SprMTSPR>,
                PPC970_DGroup_First, PPC970_Unit_FXU;
}

let Defs = [LR] in {
def MTLR  : XFXForm_7_ext<31, 467, 8, (outs), (ins gprc:$rS),
                          "mtlr $rS", SprMTSPR>,
            PPC970_DGroup_First, PPC970_Unit_FXU;
}
let Uses = [LR] in {
def MFLR  : XFXForm_1_ext<31, 339, 8, (outs gprc:$rT), (ins),
                          "mflr $rT", SprMFSPR>,
            PPC970_DGroup_First, PPC970_Unit_FXU;
}

let isCodeGenOnly = 1 in {
  // Move to/from VRSAVE: despite being a SPR, the VRSAVE register is renamed
  // like a GPR on the PPC970.  As such, copies in and out have the same
  // performance characteristics as an OR instruction.
  def MTVRSAVE : XFXForm_7_ext<31, 467, 256, (outs), (ins gprc:$rS),
                               "mtspr 256, $rS", IntGeneral>,
                 PPC970_DGroup_Single, PPC970_Unit_FXU;
  def MFVRSAVE : XFXForm_1_ext<31, 339, 256, (outs gprc:$rT), (ins),
                               "mfspr $rT, 256", IntGeneral>,
                 PPC970_DGroup_First, PPC970_Unit_FXU;

  def MTVRSAVEv : XFXForm_7_ext<31, 467, 256,
                                (outs VRSAVERC:$reg), (ins gprc:$rS),
                                "mtspr 256, $rS", IntGeneral>,
                  PPC970_DGroup_Single, PPC970_Unit_FXU;
  def MFVRSAVEv : XFXForm_1_ext<31, 339, 256, (outs gprc:$rT),
                                (ins VRSAVERC:$reg),
                                "mfspr $rT, 256", IntGeneral>,
                  PPC970_DGroup_First, PPC970_Unit_FXU;
}

// SPILL_VRSAVE - Indicate that we're dumping the VRSAVE register,
// so we'll need to scavenge a register for it.
let mayStore = 1 in
def SPILL_VRSAVE : Pseudo<(outs), (ins VRSAVERC:$vrsave, memri:$F),
                     "#SPILL_VRSAVE", []>;

// RESTORE_VRSAVE - Indicate that we're restoring the VRSAVE register (previously
// spilled), so we'll need to scavenge a register for it.
let mayLoad = 1 in
def RESTORE_VRSAVE : Pseudo<(outs VRSAVERC:$vrsave), (ins memri:$F),
                     "#RESTORE_VRSAVE", []>;

let neverHasSideEffects = 1 in {
def MTOCRF: XFXForm_5a<31, 144, (outs crbitm:$FXM), (ins gprc:$ST),
                       "mtocrf $FXM, $ST", BrMCRX>,
            PPC970_DGroup_First, PPC970_Unit_CRU;

def MTCRF : XFXForm_5<31, 144, (outs), (ins i32imm:$FXM, gprc:$rS),
                      "mtcrf $FXM, $rS", BrMCRX>,
            PPC970_MicroCode, PPC970_Unit_CRU;

def MFOCRF: XFXForm_5a<31, 19, (outs gprc:$rT), (ins crbitm:$FXM),
                       "mfocrf $rT, $FXM", SprMFCR>,
            PPC970_DGroup_First, PPC970_Unit_CRU;

def MFCR : XFXForm_3<31, 19, (outs gprc:$rT), (ins),
                     "mfcr $rT", SprMFCR>,
                     PPC970_MicroCode, PPC970_Unit_CRU;
} // neverHasSideEffects = 1

// Pseudo instruction to perform FADD in round-to-zero mode.
let usesCustomInserter = 1, Uses = [RM] in {
  def FADDrtz: Pseudo<(outs f8rc:$FRT), (ins f8rc:$FRA, f8rc:$FRB), "",
                      [(set f64:$FRT, (PPCfaddrtz f64:$FRA, f64:$FRB))]>;
}

// The above pseudo gets expanded to make use of the following instructions
// to manipulate FPSCR.  Note that FPSCR is not modeled at the DAG level.
let Uses = [RM], Defs = [RM] in { 
  def MTFSB0 : XForm_43<63, 70, (outs), (ins u5imm:$FM),
                        "mtfsb0 $FM", IntMTFSB0, []>,
               PPC970_DGroup_Single, PPC970_Unit_FPU;
  def MTFSB1 : XForm_43<63, 38, (outs), (ins u5imm:$FM),
                        "mtfsb1 $FM", IntMTFSB0, []>,
               PPC970_DGroup_Single, PPC970_Unit_FPU;
  def MTFSF  : XFLForm<63, 711, (outs), (ins i32imm:$FM, f8rc:$rT),
                       "mtfsf $FM, $rT", IntMTFSB0, []>,
               PPC970_DGroup_Single, PPC970_Unit_FPU;
}
let Uses = [RM] in {
  def MFFS   : XForm_42<63, 583, (outs f8rc:$rT), (ins),
                         "mffs $rT", IntMFFS,
                         [(set f64:$rT, (PPCmffs))]>,
               PPC970_DGroup_Single, PPC970_Unit_FPU;
}


let PPC970_Unit = 1, neverHasSideEffects = 1 in {  // FXU Operations.
// XO-Form instructions.  Arithmetic instructions that can set overflow bit
//
defm ADD4  : XOForm_1r<31, 266, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                       "add", "$rT, $rA, $rB", IntSimple,
                       [(set i32:$rT, (add i32:$rA, i32:$rB))]>;
defm ADDC  : XOForm_1rc<31, 10, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                        "addc", "$rT, $rA, $rB", IntGeneral,
                        [(set i32:$rT, (addc i32:$rA, i32:$rB))]>,
                        PPC970_DGroup_Cracked;
defm DIVW  : XOForm_1r<31, 491, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                       "divw", "$rT, $rA, $rB", IntDivW,
                       [(set i32:$rT, (sdiv i32:$rA, i32:$rB))]>,
                       PPC970_DGroup_First, PPC970_DGroup_Cracked;
defm DIVWU : XOForm_1r<31, 459, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                       "divwu", "$rT, $rA, $rB", IntDivW,
                       [(set i32:$rT, (udiv i32:$rA, i32:$rB))]>,
                       PPC970_DGroup_First, PPC970_DGroup_Cracked;
defm MULHW : XOForm_1r<31, 75, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                       "mulhw", "$rT, $rA, $rB", IntMulHW,
                       [(set i32:$rT, (mulhs i32:$rA, i32:$rB))]>;
defm MULHWU : XOForm_1r<31, 11, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                       "mulhwu", "$rT, $rA, $rB", IntMulHWU,
                       [(set i32:$rT, (mulhu i32:$rA, i32:$rB))]>;
defm MULLW : XOForm_1r<31, 235, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                       "mullw", "$rT, $rA, $rB", IntMulHW,
                       [(set i32:$rT, (mul i32:$rA, i32:$rB))]>;
defm SUBF  : XOForm_1r<31, 40, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                       "subf", "$rT, $rA, $rB", IntGeneral,
                       [(set i32:$rT, (sub i32:$rB, i32:$rA))]>;
defm SUBFC : XOForm_1rc<31, 8, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                        "subfc", "$rT, $rA, $rB", IntGeneral,
                        [(set i32:$rT, (subc i32:$rB, i32:$rA))]>,
                        PPC970_DGroup_Cracked;
defm NEG    : XOForm_3r<31, 104, 0, (outs gprc:$rT), (ins gprc:$rA),
                        "neg", "$rT, $rA", IntSimple,
                        [(set i32:$rT, (ineg i32:$rA))]>;
let Uses = [CARRY] in {
defm ADDE  : XOForm_1rc<31, 138, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                        "adde", "$rT, $rA, $rB", IntGeneral,
                        [(set i32:$rT, (adde i32:$rA, i32:$rB))]>;
defm ADDME  : XOForm_3rc<31, 234, 0, (outs gprc:$rT), (ins gprc:$rA),
                         "addme", "$rT, $rA", IntGeneral,
                         [(set i32:$rT, (adde i32:$rA, -1))]>;
defm ADDZE  : XOForm_3rc<31, 202, 0, (outs gprc:$rT), (ins gprc:$rA),
                         "addze", "$rT, $rA", IntGeneral,
                         [(set i32:$rT, (adde i32:$rA, 0))]>;
defm SUBFE : XOForm_1rc<31, 136, 0, (outs gprc:$rT), (ins gprc:$rA, gprc:$rB),
                        "subfe", "$rT, $rA, $rB", IntGeneral,
                        [(set i32:$rT, (sube i32:$rB, i32:$rA))]>;
defm SUBFME : XOForm_3rc<31, 232, 0, (outs gprc:$rT), (ins gprc:$rA),
                         "subfme", "$rT, $rA", IntGeneral,
                         [(set i32:$rT, (sube -1, i32:$rA))]>;
defm SUBFZE : XOForm_3rc<31, 200, 0, (outs gprc:$rT), (ins gprc:$rA),
                         "subfze", "$rT, $rA", IntGeneral,
                         [(set i32:$rT, (sube 0, i32:$rA))]>;
}
}

// A-Form instructions.  Most of the instructions executed in the FPU are of
// this type.
//
let PPC970_Unit = 3, neverHasSideEffects = 1 in {  // FPU Operations.
let Uses = [RM] in {
  defm FMADD : AForm_1r<63, 29, 
                      (outs f8rc:$FRT), (ins f8rc:$FRA, f8rc:$FRC, f8rc:$FRB),
                      "fmadd", "$FRT, $FRA, $FRC, $FRB", FPFused,
                      [(set f64:$FRT, (fma f64:$FRA, f64:$FRC, f64:$FRB))]>;
  defm FMADDS : AForm_1r<59, 29,
                      (outs f4rc:$FRT), (ins f4rc:$FRA, f4rc:$FRC, f4rc:$FRB),
                      "fmadds", "$FRT, $FRA, $FRC, $FRB", FPGeneral,
                      [(set f32:$FRT, (fma f32:$FRA, f32:$FRC, f32:$FRB))]>;
  defm FMSUB : AForm_1r<63, 28,
                      (outs f8rc:$FRT), (ins f8rc:$FRA, f8rc:$FRC, f8rc:$FRB),
                      "fmsub", "$FRT, $FRA, $FRC, $FRB", FPFused,
                      [(set f64:$FRT,
                            (fma f64:$FRA, f64:$FRC, (fneg f64:$FRB)))]>;
  defm FMSUBS : AForm_1r<59, 28,
                      (outs f4rc:$FRT), (ins f4rc:$FRA, f4rc:$FRC, f4rc:$FRB),
                      "fmsubs", "$FRT, $FRA, $FRC, $FRB", FPGeneral,
                      [(set f32:$FRT,
                            (fma f32:$FRA, f32:$FRC, (fneg f32:$FRB)))]>;
  defm FNMADD : AForm_1r<63, 31,
                      (outs f8rc:$FRT), (ins f8rc:$FRA, f8rc:$FRC, f8rc:$FRB),
                      "fnmadd", "$FRT, $FRA, $FRC, $FRB", FPFused,
                      [(set f64:$FRT,
                            (fneg (fma f64:$FRA, f64:$FRC, f64:$FRB)))]>;
  defm FNMADDS : AForm_1r<59, 31,
                      (outs f4rc:$FRT), (ins f4rc:$FRA, f4rc:$FRC, f4rc:$FRB),
                      "fnmadds", "$FRT, $FRA, $FRC, $FRB", FPGeneral,
                      [(set f32:$FRT,
                            (fneg (fma f32:$FRA, f32:$FRC, f32:$FRB)))]>;
  defm FNMSUB : AForm_1r<63, 30,
                      (outs f8rc:$FRT), (ins f8rc:$FRA, f8rc:$FRC, f8rc:$FRB),
                      "fnmsub", "$FRT, $FRA, $FRC, $FRB", FPFused,
                      [(set f64:$FRT, (fneg (fma f64:$FRA, f64:$FRC,
                                                 (fneg f64:$FRB))))]>;
  defm FNMSUBS : AForm_1r<59, 30,
                      (outs f4rc:$FRT), (ins f4rc:$FRA, f4rc:$FRC, f4rc:$FRB),
                      "fnmsubs", "$FRT, $FRA, $FRC, $FRB", FPGeneral,
                      [(set f32:$FRT, (fneg (fma f32:$FRA, f32:$FRC,
                                                 (fneg f32:$FRB))))]>;
}
// FSEL is artificially split into 4 and 8-byte forms for the result.  To avoid
// having 4 of these, force the comparison to always be an 8-byte double (code
// should use an FMRSD if the input comparison value really wants to be a float)
// and 4/8 byte forms for the result and operand type..
let Interpretation64Bit = 1 in
defm FSELD : AForm_1r<63, 23,
                      (outs f8rc:$FRT), (ins f8rc:$FRA, f8rc:$FRC, f8rc:$FRB),
                      "fsel", "$FRT, $FRA, $FRC, $FRB", FPGeneral,
                      [(set f64:$FRT, (PPCfsel f64:$FRA, f64:$FRC, f64:$FRB))]>;
defm FSELS : AForm_1r<63, 23,
                      (outs f4rc:$FRT), (ins f8rc:$FRA, f4rc:$FRC, f4rc:$FRB),
                      "fsel", "$FRT, $FRA, $FRC, $FRB", FPGeneral,
                      [(set f32:$FRT, (PPCfsel f64:$FRA, f32:$FRC, f32:$FRB))]>;
let Uses = [RM] in {
  defm FADD  : AForm_2r<63, 21,
                        (outs f8rc:$FRT), (ins f8rc:$FRA, f8rc:$FRB),
                        "fadd", "$FRT, $FRA, $FRB", FPAddSub,
                        [(set f64:$FRT, (fadd f64:$FRA, f64:$FRB))]>;
  defm FADDS : AForm_2r<59, 21,
                        (outs f4rc:$FRT), (ins f4rc:$FRA, f4rc:$FRB),
                        "fadds", "$FRT, $FRA, $FRB", FPGeneral,
                        [(set f32:$FRT, (fadd f32:$FRA, f32:$FRB))]>;
  defm FDIV  : AForm_2r<63, 18,
                        (outs f8rc:$FRT), (ins f8rc:$FRA, f8rc:$FRB),
                        "fdiv", "$FRT, $FRA, $FRB", FPDivD,
                        [(set f64:$FRT, (fdiv f64:$FRA, f64:$FRB))]>;
  defm FDIVS : AForm_2r<59, 18,
                        (outs f4rc:$FRT), (ins f4rc:$FRA, f4rc:$FRB),
                        "fdivs", "$FRT, $FRA, $FRB", FPDivS,
                        [(set f32:$FRT, (fdiv f32:$FRA, f32:$FRB))]>;
  defm FMUL  : AForm_3r<63, 25,
                        (outs f8rc:$FRT), (ins f8rc:$FRA, f8rc:$FRC),
                        "fmul", "$FRT, $FRA, $FRC", FPFused,
                        [(set f64:$FRT, (fmul f64:$FRA, f64:$FRC))]>;
  defm FMULS : AForm_3r<59, 25,
                        (outs f4rc:$FRT), (ins f4rc:$FRA, f4rc:$FRC),
                        "fmuls", "$FRT, $FRA, $FRC", FPGeneral,
                        [(set f32:$FRT, (fmul f32:$FRA, f32:$FRC))]>;
  defm FSUB  : AForm_2r<63, 20,
                        (outs f8rc:$FRT), (ins f8rc:$FRA, f8rc:$FRB),
                        "fsub", "$FRT, $FRA, $FRB", FPAddSub,
                        [(set f64:$FRT, (fsub f64:$FRA, f64:$FRB))]>;
  defm FSUBS : AForm_2r<59, 20,
                        (outs f4rc:$FRT), (ins f4rc:$FRA, f4rc:$FRB),
                        "fsubs", "$FRT, $FRA, $FRB", FPGeneral,
                        [(set f32:$FRT, (fsub f32:$FRA, f32:$FRB))]>;
  }
}

let neverHasSideEffects = 1 in {
let PPC970_Unit = 1 in {  // FXU Operations.
  let isSelect = 1 in
  def ISEL  : AForm_4<31, 15,
                     (outs gprc:$rT), (ins gprc_nor0:$rA, gprc:$rB, crbitrc:$cond),
                     "isel $rT, $rA, $rB, $cond", IntGeneral,
                     []>;
}

let PPC970_Unit = 1 in {  // FXU Operations.
// M-Form instructions.  rotate and mask instructions.
//
let isCommutable = 1 in {
// RLWIMI can be commuted if the rotate amount is zero.
defm RLWIMI : MForm_2r<20, (outs gprc:$rA),
                       (ins gprc:$rSi, gprc:$rS, u5imm:$SH, u5imm:$MB,
                       u5imm:$ME), "rlwimi", "$rA, $rS, $SH, $MB, $ME", IntRotate,
                       []>, PPC970_DGroup_Cracked, RegConstraint<"$rSi = $rA">,
                       NoEncode<"$rSi">;
}
let BaseName = "rlwinm" in {
def RLWINM : MForm_2<21,
                     (outs gprc:$rA), (ins gprc:$rS, u5imm:$SH, u5imm:$MB, u5imm:$ME),
                     "rlwinm $rA, $rS, $SH, $MB, $ME", IntGeneral,
                     []>, RecFormRel;
let Defs = [CR0] in
def RLWINMo : MForm_2<21,
                      (outs gprc:$rA), (ins gprc:$rS, u5imm:$SH, u5imm:$MB, u5imm:$ME),
                      "rlwinm. $rA, $rS, $SH, $MB, $ME", IntGeneral,
                      []>, isDOT, RecFormRel, PPC970_DGroup_Cracked;
}
defm RLWNM  : MForm_2r<23, (outs gprc:$rA),
                       (ins gprc:$rS, gprc:$rB, u5imm:$MB, u5imm:$ME),
                       "rlwnm", "$rA, $rS, $rB, $MB, $ME", IntGeneral,
                       []>;
}
} // neverHasSideEffects = 1

//===----------------------------------------------------------------------===//
// PowerPC Instruction Patterns
//

// Arbitrary immediate support.  Implement in terms of LIS/ORI.
def : Pat<(i32 imm:$imm),
          (ORI (LIS (HI16 imm:$imm)), (LO16 imm:$imm))>;

// Implement the 'not' operation with the NOR instruction.
def NOT : Pat<(not i32:$in),
              (NOR $in, $in)>;

// ADD an arbitrary immediate.
def : Pat<(add i32:$in, imm:$imm),
          (ADDIS (ADDI $in, (LO16 imm:$imm)), (HA16 imm:$imm))>;
// OR an arbitrary immediate.
def : Pat<(or i32:$in, imm:$imm),
          (ORIS (ORI $in, (LO16 imm:$imm)), (HI16 imm:$imm))>;
// XOR an arbitrary immediate.
def : Pat<(xor i32:$in, imm:$imm),
          (XORIS (XORI $in, (LO16 imm:$imm)), (HI16 imm:$imm))>;
// SUBFIC
def : Pat<(sub imm32SExt16:$imm, i32:$in),
          (SUBFIC $in, imm:$imm)>;

// SHL/SRL
def : Pat<(shl i32:$in, (i32 imm:$imm)),
          (RLWINM $in, imm:$imm, 0, (SHL32 imm:$imm))>;
def : Pat<(srl i32:$in, (i32 imm:$imm)),
          (RLWINM $in, (SRL32 imm:$imm), imm:$imm, 31)>;

// ROTL
def : Pat<(rotl i32:$in, i32:$sh),
          (RLWNM $in, $sh, 0, 31)>;
def : Pat<(rotl i32:$in, (i32 imm:$imm)),
          (RLWINM $in, imm:$imm, 0, 31)>;

// RLWNM
def : Pat<(and (rotl i32:$in, i32:$sh), maskimm32:$imm),
          (RLWNM $in, $sh, (MB maskimm32:$imm), (ME maskimm32:$imm))>;

// Calls
def : Pat<(PPCcall (i32 tglobaladdr:$dst)),
          (BL tglobaladdr:$dst)>;
def : Pat<(PPCcall (i32 texternalsym:$dst)),
          (BL texternalsym:$dst)>;


def : Pat<(PPCtc_return (i32 tglobaladdr:$dst),  imm:$imm),
          (TCRETURNdi tglobaladdr:$dst, imm:$imm)>;

def : Pat<(PPCtc_return (i32 texternalsym:$dst), imm:$imm),
          (TCRETURNdi texternalsym:$dst, imm:$imm)>;

def : Pat<(PPCtc_return CTRRC:$dst, imm:$imm),
          (TCRETURNri CTRRC:$dst, imm:$imm)>;



// Hi and Lo for Darwin Global Addresses.
def : Pat<(PPChi tglobaladdr:$in, 0), (LIS tglobaladdr:$in)>;
def : Pat<(PPClo tglobaladdr:$in, 0), (LI tglobaladdr:$in)>;
def : Pat<(PPChi tconstpool:$in, 0), (LIS tconstpool:$in)>;
def : Pat<(PPClo tconstpool:$in, 0), (LI tconstpool:$in)>;
def : Pat<(PPChi tjumptable:$in, 0), (LIS tjumptable:$in)>;
def : Pat<(PPClo tjumptable:$in, 0), (LI tjumptable:$in)>;
def : Pat<(PPChi tblockaddress:$in, 0), (LIS tblockaddress:$in)>;
def : Pat<(PPClo tblockaddress:$in, 0), (LI tblockaddress:$in)>;
def : Pat<(PPChi tglobaltlsaddr:$g, i32:$in),
          (ADDIS $in, tglobaltlsaddr:$g)>;
def : Pat<(PPClo tglobaltlsaddr:$g, i32:$in),
          (ADDI $in, tglobaltlsaddr:$g)>;
def : Pat<(add i32:$in, (PPChi tglobaladdr:$g, 0)),
          (ADDIS $in, tglobaladdr:$g)>;
def : Pat<(add i32:$in, (PPChi tconstpool:$g, 0)),
          (ADDIS $in, tconstpool:$g)>;
def : Pat<(add i32:$in, (PPChi tjumptable:$g, 0)),
          (ADDIS $in, tjumptable:$g)>;
def : Pat<(add i32:$in, (PPChi tblockaddress:$g, 0)),
          (ADDIS $in, tblockaddress:$g)>;

// Standard shifts.  These are represented separately from the real shifts above
// so that we can distinguish between shifts that allow 5-bit and 6-bit shift
// amounts.
def : Pat<(sra i32:$rS, i32:$rB),
          (SRAW $rS, $rB)>;
def : Pat<(srl i32:$rS, i32:$rB),
          (SRW $rS, $rB)>;
def : Pat<(shl i32:$rS, i32:$rB),
          (SLW $rS, $rB)>;

def : Pat<(zextloadi1 iaddr:$src),
          (LBZ iaddr:$src)>;
def : Pat<(zextloadi1 xaddr:$src),
          (LBZX xaddr:$src)>;
def : Pat<(extloadi1 iaddr:$src),
          (LBZ iaddr:$src)>;
def : Pat<(extloadi1 xaddr:$src),
          (LBZX xaddr:$src)>;
def : Pat<(extloadi8 iaddr:$src),
          (LBZ iaddr:$src)>;
def : Pat<(extloadi8 xaddr:$src),
          (LBZX xaddr:$src)>;
def : Pat<(extloadi16 iaddr:$src),
          (LHZ iaddr:$src)>;
def : Pat<(extloadi16 xaddr:$src),
          (LHZX xaddr:$src)>;
def : Pat<(f64 (extloadf32 iaddr:$src)),
          (COPY_TO_REGCLASS (LFS iaddr:$src), F8RC)>;
def : Pat<(f64 (extloadf32 xaddr:$src)),
          (COPY_TO_REGCLASS (LFSX xaddr:$src), F8RC)>;

def : Pat<(f64 (fextend f32:$src)),
          (COPY_TO_REGCLASS $src, F8RC)>;

def : Pat<(atomic_fence (imm), (imm)), (SYNC 0)>;

// Additional FNMSUB patterns: -a*c + b == -(a*c - b)
def : Pat<(fma (fneg f64:$A), f64:$C, f64:$B),
          (FNMSUB $A, $C, $B)>;
def : Pat<(fma f64:$A, (fneg f64:$C), f64:$B),
          (FNMSUB $A, $C, $B)>;
def : Pat<(fma (fneg f32:$A), f32:$C, f32:$B),
          (FNMSUBS $A, $C, $B)>;
def : Pat<(fma f32:$A, (fneg f32:$C), f32:$B),
          (FNMSUBS $A, $C, $B)>;

include "PPCInstrAltivec.td"
include "PPCInstr64Bit.td"


//===----------------------------------------------------------------------===//
// PowerPC Instructions used for assembler/disassembler only
//

def ISYNC : XLForm_2_ext<19, 150, 0, 0, 0, (outs), (ins),
                         "isync", SprISYNC, []>;

def ICBI : XForm_1a<31, 982, (outs), (ins memrr:$src),
                    "icbi $src", LdStICBI, []>;

def EIEIO : XForm_24_eieio<31, 854, (outs), (ins),
                           "eieio", LdStLoad, []>;

def WAIT : XForm_24_sync<31, 62, (outs), (ins i32imm:$L),
                         "wait $L", LdStLoad, []>;

//===----------------------------------------------------------------------===//
// PowerPC Assembler Instruction Aliases
//

// Pseudo-instructions for alternate assembly syntax (never used by codegen).
// These are aliases that require C++ handling to convert to the target
// instruction, while InstAliases can be handled directly by tblgen.
class PPCAsmPseudo<string asm, dag iops>
  : Instruction {
  let Namespace = "PPC";
  bit PPC64 = 0;  // Default value, override with isPPC64

  let OutOperandList = (outs);
  let InOperandList = iops;
  let Pattern = [];
  let AsmString = asm;
  let isAsmParserOnly = 1;
  let isPseudo = 1;
}

def : InstAlias<"sc", (SC 0)>;

def : InstAlias<"sync", (SYNC 0)>;
def : InstAlias<"msync", (SYNC 0)>;
def : InstAlias<"lwsync", (SYNC 1)>;
def : InstAlias<"ptesync", (SYNC 2)>;

def : InstAlias<"wait", (WAIT 0)>;
def : InstAlias<"waitrsv", (WAIT 1)>;
def : InstAlias<"waitimpl", (WAIT 2)>;

def : InstAlias<"crset $bx", (CREQV crbitrc:$bx, crbitrc:$bx, crbitrc:$bx)>;
def : InstAlias<"crclr $bx", (CRXOR crbitrc:$bx, crbitrc:$bx, crbitrc:$bx)>;
def : InstAlias<"crmove $bx, $by", (CROR crbitrc:$bx, crbitrc:$by, crbitrc:$by)>;
def : InstAlias<"crnot $bx, $by", (CRNOR crbitrc:$bx, crbitrc:$by, crbitrc:$by)>;

def : InstAlias<"mtxer $Rx", (MTSPR 1, gprc:$Rx)>;
def : InstAlias<"mfxer $Rx", (MFSPR gprc:$Rx, 1)>;

def : InstAlias<"mftb $Rx", (MFTB gprc:$Rx, 268)>;
def : InstAlias<"mftbu $Rx", (MFTB gprc:$Rx, 269)>;

def : InstAlias<"xnop", (XORI R0, R0, 0)>;

def : InstAlias<"mr $rA, $rB", (OR8 g8rc:$rA, g8rc:$rB, g8rc:$rB)>;
def : InstAlias<"mr. $rA, $rB", (OR8o g8rc:$rA, g8rc:$rB, g8rc:$rB)>;

def : InstAlias<"not $rA, $rB", (NOR8 g8rc:$rA, g8rc:$rB, g8rc:$rB)>;
def : InstAlias<"not. $rA, $rB", (NOR8o g8rc:$rA, g8rc:$rB, g8rc:$rB)>;

def : InstAlias<"mtcr $rA", (MTCRF8 255, g8rc:$rA)>;

def LAx : PPCAsmPseudo<"la $rA, $addr", (ins gprc:$rA, memri:$addr)>;

def SUBI : PPCAsmPseudo<"subi $rA, $rB, $imm",
                        (ins gprc:$rA, gprc:$rB, s16imm:$imm)>;
def SUBIS : PPCAsmPseudo<"subis $rA, $rB, $imm",
                         (ins gprc:$rA, gprc:$rB, s16imm:$imm)>;
def SUBIC : PPCAsmPseudo<"subic $rA, $rB, $imm",
                         (ins gprc:$rA, gprc:$rB, s16imm:$imm)>;
def SUBICo : PPCAsmPseudo<"subic. $rA, $rB, $imm",
                          (ins gprc:$rA, gprc:$rB, s16imm:$imm)>;

def : InstAlias<"sub $rA, $rB, $rC", (SUBF8 g8rc:$rA, g8rc:$rC, g8rc:$rB)>;
def : InstAlias<"sub. $rA, $rB, $rC", (SUBF8o g8rc:$rA, g8rc:$rC, g8rc:$rB)>;
def : InstAlias<"subc $rA, $rB, $rC", (SUBFC8 g8rc:$rA, g8rc:$rC, g8rc:$rB)>;
def : InstAlias<"subc. $rA, $rB, $rC", (SUBFC8o g8rc:$rA, g8rc:$rC, g8rc:$rB)>;

def EXTLWI : PPCAsmPseudo<"extlwi $rA, $rS, $n, $b",
                          (ins gprc:$rA, gprc:$rS, u5imm:$n, u5imm:$b)>;
def EXTLWIo : PPCAsmPseudo<"extlwi. $rA, $rS, $n, $b",
                           (ins gprc:$rA, gprc:$rS, u5imm:$n, u5imm:$b)>;
def EXTRWI : PPCAsmPseudo<"extrwi $rA, $rS, $n, $b",
                          (ins gprc:$rA, gprc:$rS, u5imm:$n, u5imm:$b)>;
def EXTRWIo : PPCAsmPseudo<"extrwi. $rA, $rS, $n, $b",
                           (ins gprc:$rA, gprc:$rS, u5imm:$n, u5imm:$b)>;
def INSLWI : PPCAsmPseudo<"inslwi $rA, $rS, $n, $b",
                          (ins gprc:$rA, gprc:$rS, u5imm:$n, u5imm:$b)>;
def INSLWIo : PPCAsmPseudo<"inslwi. $rA, $rS, $n, $b",
                           (ins gprc:$rA, gprc:$rS, u5imm:$n, u5imm:$b)>;
def INSRWI : PPCAsmPseudo<"insrwi $rA, $rS, $n, $b",
                          (ins gprc:$rA, gprc:$rS, u5imm:$n, u5imm:$b)>;
def INSRWIo : PPCAsmPseudo<"insrwi. $rA, $rS, $n, $b",
                           (ins gprc:$rA, gprc:$rS, u5imm:$n, u5imm:$b)>;
def ROTRWI : PPCAsmPseudo<"rotrwi $rA, $rS, $n",
                          (ins gprc:$rA, gprc:$rS, u5imm:$n)>;
def ROTRWIo : PPCAsmPseudo<"rotrwi. $rA, $rS, $n",
                           (ins gprc:$rA, gprc:$rS, u5imm:$n)>;
def SLWI : PPCAsmPseudo<"slwi $rA, $rS, $n",
                        (ins gprc:$rA, gprc:$rS, u5imm:$n)>;
def SLWIo : PPCAsmPseudo<"slwi. $rA, $rS, $n",
                         (ins gprc:$rA, gprc:$rS, u5imm:$n)>;
def SRWI : PPCAsmPseudo<"srwi $rA, $rS, $n",
                        (ins gprc:$rA, gprc:$rS, u5imm:$n)>;
def SRWIo : PPCAsmPseudo<"srwi. $rA, $rS, $n",
                         (ins gprc:$rA, gprc:$rS, u5imm:$n)>;
def CLRRWI : PPCAsmPseudo<"clrrwi $rA, $rS, $n",
                          (ins gprc:$rA, gprc:$rS, u5imm:$n)>;
def CLRRWIo : PPCAsmPseudo<"clrrwi. $rA, $rS, $n",
                           (ins gprc:$rA, gprc:$rS, u5imm:$n)>;
def CLRLSLWI : PPCAsmPseudo<"clrlslwi $rA, $rS, $b, $n",
                            (ins gprc:$rA, gprc:$rS, u5imm:$b, u5imm:$n)>;
def CLRLSLWIo : PPCAsmPseudo<"clrlslwi. $rA, $rS, $b, $n",
                             (ins gprc:$rA, gprc:$rS, u5imm:$b, u5imm:$n)>;

def : InstAlias<"rotlwi $rA, $rS, $n", (RLWINM gprc:$rA, gprc:$rS, u5imm:$n, 0, 31)>;
def : InstAlias<"rotlwi. $rA, $rS, $n", (RLWINMo gprc:$rA, gprc:$rS, u5imm:$n, 0, 31)>;
def : InstAlias<"rotlw $rA, $rS, $rB", (RLWNM gprc:$rA, gprc:$rS, gprc:$rB, 0, 31)>;
def : InstAlias<"rotlw. $rA, $rS, $rB", (RLWNMo gprc:$rA, gprc:$rS, gprc:$rB, 0, 31)>;
def : InstAlias<"clrlwi $rA, $rS, $n", (RLWINM gprc:$rA, gprc:$rS, 0, u5imm:$n, 31)>;
def : InstAlias<"clrlwi. $rA, $rS, $n", (RLWINMo gprc:$rA, gprc:$rS, 0, u5imm:$n, 31)>;

def EXTLDI : PPCAsmPseudo<"extldi $rA, $rS, $n, $b",
                          (ins g8rc:$rA, g8rc:$rS, u6imm:$n, u6imm:$b)>;
def EXTLDIo : PPCAsmPseudo<"extldi. $rA, $rS, $n, $b",
                           (ins g8rc:$rA, g8rc:$rS, u6imm:$n, u6imm:$b)>;
def EXTRDI : PPCAsmPseudo<"extrdi $rA, $rS, $n, $b",
                          (ins g8rc:$rA, g8rc:$rS, u6imm:$n, u6imm:$b)>;
def EXTRDIo : PPCAsmPseudo<"extrdi. $rA, $rS, $n, $b",
                           (ins g8rc:$rA, g8rc:$rS, u6imm:$n, u6imm:$b)>;
def INSRDI : PPCAsmPseudo<"insrdi $rA, $rS, $n, $b",
                          (ins g8rc:$rA, g8rc:$rS, u6imm:$n, u6imm:$b)>;
def INSRDIo : PPCAsmPseudo<"insrdi. $rA, $rS, $n, $b",
                           (ins g8rc:$rA, g8rc:$rS, u6imm:$n, u6imm:$b)>;
def ROTRDI : PPCAsmPseudo<"rotrdi $rA, $rS, $n",
                          (ins g8rc:$rA, g8rc:$rS, u6imm:$n)>;
def ROTRDIo : PPCAsmPseudo<"rotrdi. $rA, $rS, $n",
                           (ins g8rc:$rA, g8rc:$rS, u6imm:$n)>;
def SLDI : PPCAsmPseudo<"sldi $rA, $rS, $n",
                        (ins g8rc:$rA, g8rc:$rS, u6imm:$n)>;
def SLDIo : PPCAsmPseudo<"sldi. $rA, $rS, $n",
                         (ins g8rc:$rA, g8rc:$rS, u6imm:$n)>;
def SRDI : PPCAsmPseudo<"srdi $rA, $rS, $n",
                        (ins g8rc:$rA, g8rc:$rS, u6imm:$n)>;
def SRDIo : PPCAsmPseudo<"srdi. $rA, $rS, $n",
                         (ins g8rc:$rA, g8rc:$rS, u6imm:$n)>;
def CLRRDI : PPCAsmPseudo<"clrrdi $rA, $rS, $n",
                          (ins g8rc:$rA, g8rc:$rS, u6imm:$n)>;
def CLRRDIo : PPCAsmPseudo<"clrrdi. $rA, $rS, $n",
                           (ins g8rc:$rA, g8rc:$rS, u6imm:$n)>;
def CLRLSLDI : PPCAsmPseudo<"clrlsldi $rA, $rS, $b, $n",
                            (ins g8rc:$rA, g8rc:$rS, u6imm:$b, u6imm:$n)>;
def CLRLSLDIo : PPCAsmPseudo<"clrlsldi. $rA, $rS, $b, $n",
                             (ins g8rc:$rA, g8rc:$rS, u6imm:$b, u6imm:$n)>;

def : InstAlias<"rotldi $rA, $rS, $n", (RLDICL g8rc:$rA, g8rc:$rS, u6imm:$n, 0)>;
def : InstAlias<"rotldi. $rA, $rS, $n", (RLDICLo g8rc:$rA, g8rc:$rS, u6imm:$n, 0)>;
def : InstAlias<"rotld $rA, $rS, $rB", (RLDCL g8rc:$rA, g8rc:$rS, gprc:$rB, 0)>;
def : InstAlias<"rotld. $rA, $rS, $rB", (RLDCLo g8rc:$rA, g8rc:$rS, gprc:$rB, 0)>;
def : InstAlias<"clrldi $rA, $rS, $n", (RLDICL g8rc:$rA, g8rc:$rS, 0, u6imm:$n)>;
def : InstAlias<"clrldi. $rA, $rS, $n", (RLDICLo g8rc:$rA, g8rc:$rS, 0, u6imm:$n)>;

// These generic branch instruction forms are used for the assembler parser only.
// Defs and Uses are conservative, since we don't know the BO value.
let PPC970_Unit = 7 in {
  let Defs = [CTR], Uses = [CTR, RM] in {
    def gBC : BForm_3<16, 0, 0, (outs),
                      (ins u5imm:$bo, crbitrc:$bi, condbrtarget:$dst),
                      "bc $bo, $bi, $dst">;
    def gBCA : BForm_3<16, 1, 0, (outs),
                       (ins u5imm:$bo, crbitrc:$bi, abscondbrtarget:$dst),
                       "bca $bo, $bi, $dst">;
  }
  let Defs = [LR, CTR], Uses = [CTR, RM] in {
    def gBCL : BForm_3<16, 0, 1, (outs),
                       (ins u5imm:$bo, crbitrc:$bi, condbrtarget:$dst),
                       "bcl $bo, $bi, $dst">;
    def gBCLA : BForm_3<16, 1, 1, (outs),
                        (ins u5imm:$bo, crbitrc:$bi, abscondbrtarget:$dst),
                        "bcla $bo, $bi, $dst">;
  }
  let Defs = [CTR], Uses = [CTR, LR, RM] in
    def gBCLR : XLForm_2<19, 16, 0, (outs),
                         (ins u5imm:$bo, crbitrc:$bi, i32imm:$bh),
                         "bclr $bo, $bi, $bh", BrB, []>;
  let Defs = [LR, CTR], Uses = [CTR, LR, RM] in
    def gBCLRL : XLForm_2<19, 16, 1, (outs),
                          (ins u5imm:$bo, crbitrc:$bi, i32imm:$bh),
                          "bclrl $bo, $bi, $bh", BrB, []>;
  let Defs = [CTR], Uses = [CTR, LR, RM] in
    def gBCCTR : XLForm_2<19, 528, 0, (outs),
                          (ins u5imm:$bo, crbitrc:$bi, i32imm:$bh),
                          "bcctr $bo, $bi, $bh", BrB, []>;
  let Defs = [LR, CTR], Uses = [CTR, LR, RM] in
    def gBCCTRL : XLForm_2<19, 528, 1, (outs),
                           (ins u5imm:$bo, crbitrc:$bi, i32imm:$bh),
                           "bcctrl $bo, $bi, $bh", BrB, []>;
}
def : InstAlias<"bclr $bo, $bi", (gBCLR u5imm:$bo, crbitrc:$bi, 0)>;
def : InstAlias<"bclrl $bo, $bi", (gBCLRL u5imm:$bo, crbitrc:$bi, 0)>;
def : InstAlias<"bcctr $bo, $bi", (gBCCTR u5imm:$bo, crbitrc:$bi, 0)>;
def : InstAlias<"bcctrl $bo, $bi", (gBCCTRL u5imm:$bo, crbitrc:$bi, 0)>;

multiclass BranchSimpleMnemonic1<string name, string pm, int bo> {
  def : InstAlias<"b"#name#pm#" $bi, $dst", (gBC bo, crbitrc:$bi, condbrtarget:$dst)>;
  def : InstAlias<"b"#name#"a"#pm#" $bi, $dst", (gBCA bo, crbitrc:$bi, abscondbrtarget:$dst)>;
  def : InstAlias<"b"#name#"lr"#pm#" $bi", (gBCLR bo, crbitrc:$bi, 0)>;
  def : InstAlias<"b"#name#"l"#pm#" $bi, $dst", (gBCL bo, crbitrc:$bi, condbrtarget:$dst)>;
  def : InstAlias<"b"#name#"la"#pm#" $bi, $dst", (gBCLA bo, crbitrc:$bi, abscondbrtarget:$dst)>;
  def : InstAlias<"b"#name#"lrl"#pm#" $bi", (gBCLRL bo, crbitrc:$bi, 0)>;
}
multiclass BranchSimpleMnemonic2<string name, string pm, int bo>
  : BranchSimpleMnemonic1<name, pm, bo> {
  def : InstAlias<"b"#name#"ctr"#pm#" $bi", (gBCCTR bo, crbitrc:$bi, 0)>;
  def : InstAlias<"b"#name#"ctrl"#pm#" $bi", (gBCCTRL bo, crbitrc:$bi, 0)>;
}
defm : BranchSimpleMnemonic2<"t", "", 12>;
defm : BranchSimpleMnemonic2<"f", "", 4>;
defm : BranchSimpleMnemonic2<"t", "-", 14>;
defm : BranchSimpleMnemonic2<"f", "-", 6>;
defm : BranchSimpleMnemonic2<"t", "+", 15>;
defm : BranchSimpleMnemonic2<"f", "+", 7>;
defm : BranchSimpleMnemonic1<"dnzt", "", 8>;
defm : BranchSimpleMnemonic1<"dnzf", "", 0>;
defm : BranchSimpleMnemonic1<"dzt", "", 10>;
defm : BranchSimpleMnemonic1<"dzf", "", 2>;

multiclass BranchExtendedMnemonicPM<string name, string pm, int bibo> {
  def : InstAlias<"b"#name#pm#" $cc, $dst",
                  (BCC bibo, crrc:$cc, condbrtarget:$dst)>;
  def : InstAlias<"b"#name#pm#" $dst",
                  (BCC bibo, CR0, condbrtarget:$dst)>;

  def : InstAlias<"b"#name#"a"#pm#" $cc, $dst",
                  (BCCA bibo, crrc:$cc, abscondbrtarget:$dst)>;
  def : InstAlias<"b"#name#"a"#pm#" $dst",
                  (BCCA bibo, CR0, abscondbrtarget:$dst)>;

  def : InstAlias<"b"#name#"lr"#pm#" $cc",
                  (BCLR bibo, crrc:$cc)>;
  def : InstAlias<"b"#name#"lr"#pm,
                  (BCLR bibo, CR0)>;

  def : InstAlias<"b"#name#"ctr"#pm#" $cc",
                  (BCCTR bibo, crrc:$cc)>;
  def : InstAlias<"b"#name#"ctr"#pm,
                  (BCCTR bibo, CR0)>;

  def : InstAlias<"b"#name#"l"#pm#" $cc, $dst",
                  (BCCL bibo, crrc:$cc, condbrtarget:$dst)>;
  def : InstAlias<"b"#name#"l"#pm#" $dst",
                  (BCCL bibo, CR0, condbrtarget:$dst)>;

  def : InstAlias<"b"#name#"la"#pm#" $cc, $dst",
                  (BCCLA bibo, crrc:$cc, abscondbrtarget:$dst)>;
  def : InstAlias<"b"#name#"la"#pm#" $dst",
                  (BCCLA bibo, CR0, abscondbrtarget:$dst)>;

  def : InstAlias<"b"#name#"lrl"#pm#" $cc",
                  (BCLRL bibo, crrc:$cc)>;
  def : InstAlias<"b"#name#"lrl"#pm,
                  (BCLRL bibo, CR0)>;

  def : InstAlias<"b"#name#"ctrl"#pm#" $cc",
                  (BCCTRL bibo, crrc:$cc)>;
  def : InstAlias<"b"#name#"ctrl"#pm,
                  (BCCTRL bibo, CR0)>;
}
multiclass BranchExtendedMnemonic<string name, int bibo> {
  defm : BranchExtendedMnemonicPM<name, "", bibo>;
  defm : BranchExtendedMnemonicPM<name, "-", !add(bibo, 2)>;
  defm : BranchExtendedMnemonicPM<name, "+", !add(bibo, 3)>;
}
defm : BranchExtendedMnemonic<"lt", 12>;
defm : BranchExtendedMnemonic<"gt", 44>;
defm : BranchExtendedMnemonic<"eq", 76>;
defm : BranchExtendedMnemonic<"un", 108>;
defm : BranchExtendedMnemonic<"so", 108>;
defm : BranchExtendedMnemonic<"ge", 4>;
defm : BranchExtendedMnemonic<"nl", 4>;
defm : BranchExtendedMnemonic<"le", 36>;
defm : BranchExtendedMnemonic<"ng", 36>;
defm : BranchExtendedMnemonic<"ne", 68>;
defm : BranchExtendedMnemonic<"nu", 100>;
defm : BranchExtendedMnemonic<"ns", 100>;

def : InstAlias<"cmpwi $rA, $imm", (CMPWI CR0, gprc:$rA, s16imm:$imm)>;
def : InstAlias<"cmpw $rA, $rB", (CMPW CR0, gprc:$rA, gprc:$rB)>;
def : InstAlias<"cmplwi $rA, $imm", (CMPLWI CR0, gprc:$rA, u16imm:$imm)>;
def : InstAlias<"cmplw $rA, $rB", (CMPLW CR0, gprc:$rA, gprc:$rB)>;
def : InstAlias<"cmpdi $rA, $imm", (CMPDI CR0, g8rc:$rA, s16imm:$imm)>;
def : InstAlias<"cmpd $rA, $rB", (CMPD CR0, g8rc:$rA, g8rc:$rB)>;
def : InstAlias<"cmpldi $rA, $imm", (CMPLDI CR0, g8rc:$rA, u16imm:$imm)>;
def : InstAlias<"cmpld $rA, $rB", (CMPLD CR0, g8rc:$rA, g8rc:$rB)>;

def : InstAlias<"cmpi $bf, 0, $rA, $imm", (CMPWI crrc:$bf, gprc:$rA, s16imm:$imm)>;
def : InstAlias<"cmp $bf, 0, $rA, $rB", (CMPW crrc:$bf, gprc:$rA, gprc:$rB)>;
def : InstAlias<"cmpli $bf, 0, $rA, $imm", (CMPLWI crrc:$bf, gprc:$rA, u16imm:$imm)>;
def : InstAlias<"cmpl $bf, 0, $rA, $rB", (CMPLW crrc:$bf, gprc:$rA, gprc:$rB)>;
def : InstAlias<"cmpi $bf, 1, $rA, $imm", (CMPDI crrc:$bf, g8rc:$rA, s16imm:$imm)>;
def : InstAlias<"cmp $bf, 1, $rA, $rB", (CMPD crrc:$bf, g8rc:$rA, g8rc:$rB)>;
def : InstAlias<"cmpli $bf, 1, $rA, $imm", (CMPLDI crrc:$bf, g8rc:$rA, u16imm:$imm)>;
def : InstAlias<"cmpl $bf, 1, $rA, $rB", (CMPLD crrc:$bf, g8rc:$rA, g8rc:$rB)>;

multiclass TrapExtendedMnemonic<string name, int to> {
  def : InstAlias<"td"#name#"i $rA, $imm", (TDI to, g8rc:$rA, s16imm:$imm)>;
  def : InstAlias<"td"#name#" $rA, $rB", (TD to, g8rc:$rA, g8rc:$rB)>;
  def : InstAlias<"tw"#name#"i $rA, $imm", (TWI to, gprc:$rA, s16imm:$imm)>;
  def : InstAlias<"tw"#name#" $rA, $rB", (TW to, gprc:$rA, gprc:$rB)>;
}
defm : TrapExtendedMnemonic<"lt", 16>;
defm : TrapExtendedMnemonic<"le", 20>;
defm : TrapExtendedMnemonic<"eq", 4>;
defm : TrapExtendedMnemonic<"ge", 12>;
defm : TrapExtendedMnemonic<"gt", 8>;
defm : TrapExtendedMnemonic<"nl", 12>;
defm : TrapExtendedMnemonic<"ne", 24>;
defm : TrapExtendedMnemonic<"ng", 20>;
defm : TrapExtendedMnemonic<"llt", 2>;
defm : TrapExtendedMnemonic<"lle", 6>;
defm : TrapExtendedMnemonic<"lge", 5>;
defm : TrapExtendedMnemonic<"lgt", 1>;
defm : TrapExtendedMnemonic<"lnl", 5>;
defm : TrapExtendedMnemonic<"lng", 6>;
defm : TrapExtendedMnemonic<"u", 31>;

